// Import configuration constants
import { 
    TANK_CONFIG, 
    PHYSICS_CONFIG, 
    SHOP_CONFIG, 
    ASTEROID_CONFIG, 
    NETWORK_CONFIG, 
    UI_CONFIG, 
    WEATHER_CONFIG, 
    STORAGE_KEYS, 
    POWERUP_CONFIG 
} from './core/Config.js';

// Import centralized game state management
import gameStateManager from './core/GameState.js';

// Import centralized image loading and asset management
import imageLoader from './assets/ImageLoader.js';

// Import input system
import InputSystem from './systems/InputSystem.js';

// Import weapon system
import WeaponSystem from './systems/WeaponSystem.js';

// Clean up old maps with broken paths (runs once on load)
(function cleanupOldMaps() {
    try {
        // Clean race maps with old paths
        const raceMapsKey = STORAGE_KEYS.RACE_MAPS;
        const raceMaps = JSON.parse(localStorage.getItem(raceMapsKey) || '[]');
        if (raceMaps.length > 0) {
            const hasOldPaths = raceMaps.some(m => 
                JSON.stringify(m).includes('spr_car_') || 
                JSON.stringify(m).includes('spr_Track') ||
                JSON.stringify(m).includes('spr_tile_') ||
                JSON.stringify(m).includes('spr_house') ||
                JSON.stringify(m).includes('-4') // UUID pattern
            );
            if (hasOldPaths) {
                localStorage.removeItem(raceMapsKey);
                console.log('ðŸ§¹ Cleared old race maps with broken paths');
            }
        }
        
        // Clean tank maps with old broken paths (ground_X.png or _Group_ patterns)
        const tankMapsKey = STORAGE_KEYS.TANK_MAPS;
        const tankMaps = JSON.parse(localStorage.getItem(tankMapsKey) || '[]');
        if (tankMaps.length > 0) {
            const mapStr = JSON.stringify(tankMaps);
            const hasOldGroundPaths = mapStr.includes('_Group_') || 
                                       /ground_\d+\.png/.test(mapStr) ||
                                       (mapStr.includes('Grounds/') && !mapStr.includes('/assets/tank/Grounds/'));
            if (hasOldGroundPaths) {
                localStorage.removeItem(tankMapsKey);
                console.log('ðŸ§¹ Cleared old tank maps with broken ground paths');
            }
        }
    } catch (e) {
        console.warn('Failed to cleanup old maps:', e);
    }
})();

// Lobby background rendering - now handled by RenderSystem
function renderLobbyBackground() {
    if (renderSystem) {
        renderSystem.renderLobbyBackground();
    }
}

// Test function to manually render tank background (for debugging)
window.testTankBackground = function() {
    console.log('ðŸ§ª Testing tank background rendering...');
    const canvas = document.getElementById('tankLobbyBackground');
    if (!canvas) {
        console.error('âŒ Canvas not found!');
        return;
    }
    
    console.log('âœ… Canvas found:', canvas);
    console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
    console.log('Canvas style:', canvas.style.display);
    console.log('MapRenderer available:', !!window.MapRenderer);
    console.log('MapRenderer initialized:', window.MapRenderer?.initialized);
    console.log('MapRenderer has map:', !!window.MapRenderer?.currentMap);
    
    // Test the new full map rendering
    renderLobbyBackground();
    
    console.log('âœ… Full map rendering test complete');
};

// Call this when entering lobby
if (typeof window !== 'undefined') {
    window.addEventListener('resize', () => {
        if (gameState.isInLobby) {
            renderLobbyBackground();
        }
    });
}


// Game state variables - socket management now handled by NetworkSystem

// Use centralized game state management
const gameState = gameStateManager.getGameState();

// Create and initialize input system
const inputSystem = new InputSystem();

// Create and initialize network system
import NetworkSystem from './systems/NetworkSystem.js';
const networkSystem = new NetworkSystem(gameStateManager);

// Create and initialize particle system
import ParticleSystem from './systems/ParticleSystem.js';
let particleSystem = null; // Will be initialized when canvas is available

// Create and initialize weapon system
let weaponSystem = null; // Will be initialized when other systems are available

// Create and initialize physics system
import PhysicsSystem from './systems/PhysicsSystem.js';
let physicsSystem = null; // Will be initialized when gameState is available

// Create and initialize render system
import RenderSystem from './systems/RenderSystem.js';
let renderSystem = null; // Will be initialized when canvas is available

// Import entity modules
import Player from './entities/Player.js';
import Tank from './entities/Tank.js';
import Bullet from './entities/Bullet.js';

// Import UI modules
import lobbyUI from './ui/LobbyUI.js';
import shopUI from './ui/ShopUI.js';
import lockerUI from './ui/LockerUI.js';

// Initialize physics system
physicsSystem = new PhysicsSystem(gameStateManager.getGameState());

// Entity helper functions
/**
 * Create a Player instance from player data
 * @param {string} playerId - Player ID
 * @param {Object} playerData - Player data object
 * @returns {Player} Player instance
 */
function createPlayerEntity(playerId, playerData) {
    return new Player(playerId, playerData);
}

/**
 * Create a Tank instance from tank configuration
 * @param {Object} tankConfig - Tank configuration
 * @returns {Tank} Tank instance
 */
function createTankEntity(tankConfig) {
    return new Tank(tankConfig);
}

/**
 * Create a Bullet instance from bullet data
 * @param {Object} bulletData - Bullet data object
 * @returns {Bullet} Bullet instance
 */
function createBulletEntity(bulletData) {
    return new Bullet(bulletData);
}

// Expose systems globally for backward compatibility
if (typeof window !== 'undefined') {
    window.inputSystem = inputSystem;
    window.networkSystem = networkSystem;
    window.weaponSystem = weaponSystem;
    window.physicsSystem = physicsSystem;
    window.renderSystem = renderSystem;
    
    // Expose UI modules for backward compatibility
    window.lobbyUI = lobbyUI;
    window.shopUI = shopUI;
    window.lockerUI = lockerUI;
    
    // Expose entity classes for backward compatibility
    window.Player = Player;
    window.Tank = Tank;
    window.Bullet = Bullet;
    
    // Expose entity helper functions
    window.createPlayerEntity = createPlayerEntity;
    window.createTankEntity = createTankEntity;
    window.createBulletEntity = createBulletEntity;
    
    // Expose functions needed by NetworkSystem
    window.initializePlayerAnimations = initializePlayerAnimations;
    window.updateUI = updateUI;
    window.updatePlayerCount = updatePlayerCount;
    window.createBulletTrail = (bullet) => particleSystem?.createBulletTrail(bullet);
    window.triggerWeaponAnimation = (playerTank, playerId) => weaponSystem?.triggerWeaponAnimation(playerTank, playerId);
    window.triggerTankBodyAnimation = (playerTank, playerId) => weaponSystem?.triggerTankBodyAnimation(playerTank, playerId);
    window.triggerMuzzleFlash = (playerId) => particleSystem?.triggerMuzzleFlash(playerId);
    window.createBulletImpact = (x, y, impactType, bulletColor) => particleSystem?.createBulletImpact(x, y, impactType, bulletColor);
    window.updatePlayerStats = updatePlayerStats;
    window.updateHealthDisplay = updateHealthDisplay;
    window.returnToLobby = returnToLobby;
    window.showNotification = showNotification;
    window.updateFortzDisplay = updateFortzDisplay;
    
    // Expose WeaponSystem functions for backward compatibility
    window.getTankStats = getTankStats;
    window.isShopComboOwned = isShopComboOwned;
    window.isShopComboEquipped = isShopComboEquipped;
    window.renderShopTankPreview = renderShopTankPreview;
    window.stopShopTankAnimations = stopShopTankAnimations;
    window.purchaseOrEquipShopCombo = purchaseOrEquipShopCombo;
    window.renderLockerTankWeaponOnly = renderLockerTankWeaponOnly;
    
    // Expose variables needed by NetworkSystem
    window.powerUps = powerUps;
    window.damageNumbers = damageNumbers;
    window.otherPlayerGunRecoils = () => weaponSystem?.getOtherPlayerGunRecoils() || {};
    window.wallHitAnimations = wallHitAnimations;
    window.playerHealth = playerHealth;
    window.playerShield = playerShield;
    window.displayHealth = displayHealth;
    window.displayShield = displayShield;
    // Physics-related variables now accessed through physicsSystem
    window.lastInputDirection = () => physicsSystem?.getLastInputDirection() || { x: 0, y: 0 };
    window.tankVelocity = () => physicsSystem?.getTankVelocity() || { x: 0, y: 0 };
    window.isSprinting = () => physicsSystem?.getIsSprinting() || false;
}



// Use centralized locker state management
const lockerState = gameStateManager.getLockerState();

// Expose gameState globally for animation system (already handled by GameStateManager)
// window.gameState is automatically set by GameStateManager constructor

// Expose ImageLoader functions globally for backward compatibility
if (typeof window !== 'undefined') {
    window.renderTankOnCanvas = (canvasId, tankConfig, options) => {
        return imageLoader.renderTankOnCanvas(canvasId, tankConfig, options);
    };
    
    window.renderJetOnCanvas = (canvasId, jetConfig, options) => {
        return imageLoader.renderJetOnCanvas(canvasId, jetConfig, options);
    };
    
    window.renderRaceOnCanvas = (canvasId, raceConfig, options) => {
        return imageLoader.renderRaceOnCanvas(canvasId, raceConfig, options);
    };
}

// Canvas and rendering
let canvas, ctx, minimapCanvas, minimapCtx;


// Weather and environmental effects - now handled by ParticleSystem

// Sound system (placeholder for future implementation)
const soundSystem = {
    enabled: SOUND_CONFIG.enabled,
    play: function (soundName) {
        if (!this.enabled) return;
        // Future: Play sound effects here
        // Examples: 'shoot', 'hit', 'explosion', 'powerup'
    }
};

// Weather particle functions moved to ParticleSystem

// Toggle weather (can be bound to a key)
function toggleWeather(type = 'rain') {
    if (particleSystem) {
        const isActive = particleSystem.toggleWeather(type);
        if (isActive) {
            showNotification(`Weather: ${type.toUpperCase()}`, '#87CEEB', 28);
        }
    }
}

let animationId;





// Use centralized image loading - all image variables are now managed by ImageLoader
// Legacy variables for backward compatibility (will be removed in future refactoring)
let tankImages = imageLoader.tankImages;
let weaponImages = imageLoader.weaponImages;
let lobbyTankImages = imageLoader.lobbyTankImages;
let lobbyWeaponImages = imageLoader.lobbyWeaponImages;
let imagesLoaded = false;
let lobbyImagesLoaded = false;

// Start loading images immediately when page loads
console.log('ðŸš€ Starting image loading immediately...');

// Initialize image loading using centralized ImageLoader
imageLoader.initializeTankImages();

// Set up callback for when loading completes
if (typeof window !== 'undefined') {
    window.onImageLoadingComplete = () => {
        // Update legacy variables for backward compatibility
        tankImages = imageLoader.tankImages;
        weaponImages = imageLoader.weaponImages;
        lobbyTankImages = imageLoader.lobbyTankImages;
        lobbyWeaponImages = imageLoader.lobbyWeaponImages;
        imagesLoaded = imageLoader.imagesLoaded;
        
        // Immediately render tank in lobby box
        console.log('ðŸŽ® Loading complete - rendering tank in lobby');
        if (typeof renderTankOnCanvas === 'function' && gameState.selectedTank) {
            renderTankOnCanvas('playerTankCanvas', gameState.selectedTank);
            console.log('âœ… Tank rendered on lobby canvas');
        }
        
        // Start lobby animations
        if (typeof animateLobbyTanks === 'function') {
            animateLobbyTanks();
            console.log('âœ… Lobby tank animations started');
        }
        
        // Initialize lobby background only for tank if maps exist
        if (typeof initializeLobbyBackground === 'function' && (!gameState.selectedVehicleType || gameState.selectedVehicleType === 'tank')) {
            const allMaps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]');
            const tankMaps = allMaps.filter(map => !map.vehicleType || map.vehicleType === 'tank');
            
            if (tankMaps.length > 0) {
                initializeLobbyBackground();
                console.log('âœ… Lobby background initialized');
            } else {
                updateLobbyBackgroundNoMaps('tank');
                updatePlayButtonForVehicle('tank', []);
                console.log('â„¹ï¸ No tank maps - showing create prompt');
            }
        }
    };
}

// Image loading functions are now handled by ImageLoader
// These functions are kept for backward compatibility but delegate to ImageLoader
function loadGifImage(path, callback) {
    return imageLoader.loadGifImage(path, callback);
}

function loadImageWithFallback(basePath, callback) {
    return imageLoader.loadImageWithFallback(basePath, callback);
}

function loadWeaponImagePngFirst(basePath, callback) {
    return imageLoader.loadWeaponImagePngFirst(basePath, callback);
}

// Image loading progress is now handled by ImageLoader
// These functions are kept for backward compatibility but delegate to ImageLoader
function checkImagesLoaded(success = true) {
    // Delegate to ImageLoader
    return imageLoader.checkImagesLoaded(success);
}

// Loading completion is now handled by ImageLoader through the callback
function waitForLoadingComplete() {
    // This function is now handled by ImageLoader.waitForLoadingComplete()
    // The callback is set up in the initialization above
    return imageLoader.waitForLoadingComplete();
}

// Tank image functions are now handled by ImageLoader
// These functions are kept for backward compatibility but delegate to ImageLoader
function verifyDefaultTank() {
    const verifiedTank = imageLoader.verifyDefaultTank(gameState.selectedTank);
    if (verifiedTank && verifiedTank !== gameState.selectedTank) {
        gameStateManager.updateGameState({ selectedTank: verifiedTank });
    }

    // Render player tank on center box after images load
    if (typeof renderTankOnCanvas === 'function' && gameState.selectedTank) {
        setTimeout(() => {
            renderTankOnCanvas('playerTankCanvas', gameState.selectedTank);
        }, 100);
    }
}

function findWorkingDefaultTank() {
    const workingTank = imageLoader.findWorkingDefaultTank();
    if (workingTank) {
        gameStateManager.updateGameState({ selectedTank: workingTank });
        console.log(`Switched to working default: ${workingTank.color}/${workingTank.body}/${workingTank.weapon}`);
    }
    return workingTank;
}

// Get current tank images based on player selection
function getCurrentTankImages(playerTank = gameState.selectedTank, forLobby = false) {
    return imageLoader.getCurrentTankImages(playerTank, forLobby);
}

// Initialize player animations for the AnimationManager
function initializePlayerAnimations(playerId) {
    if (window.tankAnimationManager) {
        window.tankAnimationManager.createTankBodyAnimation(playerId, gameState.players[playerId]?.selectedTank || gameState.selectedTank);
    }
    
    // Initialize weapon animation for 8-frame PNG sprites
    const playerTank = gameState.players[playerId]?.selectedTank || gameState.selectedTank;
    const weaponAssetKey = `${playerTank.color}_${playerTank.weapon}`;
    initSpriteAnimation('weapons', playerId, weaponAssetKey);
}

// Shooting animation functions moved to WeaponSystem

// Update movement animation using AnimationManager
function updateMovementAnimation(playerId, velocity) {
    if (window.tankAnimationManager) {
        window.tankAnimationManager.updateMovementAnimation(playerId, velocity);
    }
}

// Weapon animation functions moved to WeaponSystem

// Muzzle flash and screen shake systems - now handled by ParticleSystem

// Asteroid system
let asteroids = [];
let asteroidImages = {};
let asteroidsLoaded = false;



// Load asteroid images - DISABLED (only map editor asteroids are used)
function loadAsteroidImages() {
    // Asteroid loading disabled - only show asteroids placed in map editor
    asteroidsLoaded = true;
    console.log('ðŸŒŒ Asteroid loading skipped - using map editor asteroids only');
    return;
    
    // Original code below (disabled):
    console.log('ðŸŒŒ Loading asteroid images...');
    
    // Define known missing frames to skip them
    const knownMissingFrames = {
        'Small 2_Rock': [8], // Frame 08 is missing
        'Small 2_Gold': [12] // Frame 12 is missing
    };
    
    let loadedCount = 0;
    let totalAttempts = 0;

    ASTEROID_CONFIG.sizes.forEach(size => {
        ASTEROID_CONFIG.types.forEach(type => {
            const asteroidKey = `${size}_${type}`;
            const missingFrames = knownMissingFrames[asteroidKey] || [];
            asteroidImages[asteroidKey] = [];

            // Load frames 1-30, skipping known missing ones
            for (let frame = 1; frame <= 30; frame++) {
                if (missingFrames.includes(frame)) {
                    // Create placeholder for known missing frames
                    const placeholder = createAsteroidPlaceholder(type);
                    asteroidImages[asteroidKey][frame - 1] = placeholder;
                    continue;
                }

                totalAttempts++;
                const img = new Image();
                const frameStr = frame.toString().padStart(2, '0');
                
                // Fix the path generation to match actual file structure
                const sizeStr = size.toLowerCase().replace(' ', '');
                const typeStr = type.toLowerCase();
                img.src = `/assets/Asteroids/Asteroid ${size}/${type}/spr_asteroids_${sizeStr}_${typeStr}_${frameStr}.png`;
                
                img.onload = () => {
                    loadedCount++;
                    checkAsteroidLoadingComplete();
                };
                
                img.onerror = () => {
                    // Create a placeholder for unexpected missing frames
                    console.warn(`Unexpected missing asteroid frame: ${img.src}`);
                    const placeholder = createAsteroidPlaceholder(type);
                    asteroidImages[asteroidKey][frame - 1] = placeholder;
                    loadedCount++;
                    checkAsteroidLoadingComplete();
                };

                // Initialize array index
                asteroidImages[asteroidKey][frame - 1] = img;
            }
        });
    });

    function checkAsteroidLoadingComplete() {
        if (loadedCount >= totalAttempts) {
            asteroidsLoaded = true;
            console.log(`âœ… Asteroid loading completed: ${loadedCount}/${totalAttempts} attempts`);
            generateAsteroids();
        }
    }
}

// Create a placeholder image for missing asteroid frames
function createAsteroidPlaceholder(type) {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

    // Different colors for different types
    const colors = {
        'Rock': '#8B4513',
        'Ice': '#87CEEB', 
        'Gold': '#FFD700'
    };

    ctx.fillStyle = colors[type] || '#8B4513';
    ctx.beginPath();
    ctx.arc(32, 32, 25, 0, Math.PI * 2);
    ctx.fill();

    // Add some texture
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.arc(
            20 + Math.random() * 24,
            20 + Math.random() * 24,
            2 + Math.random() * 3,
            0, Math.PI * 2
        );
        ctx.fill();
    }

    return canvas;
}

// Generate asteroids randomly across the map
function generateAsteroids() {
    console.log('ðŸŒŒ Generating asteroids...');
    asteroids = [];

    for (let i = 0; i < ASTEROID_CONFIG.count; i++) {
        // Random position within map bounds
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 2000 + 500; // Between 500-2500 pixels from center
        
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;

        // Random asteroid properties
        const size = ASTEROID_CONFIG.sizes[Math.floor(Math.random() * ASTEROID_CONFIG.sizes.length)];
        const type = ASTEROID_CONFIG.types[Math.floor(Math.random() * ASTEROID_CONFIG.types.length)];
        const scale = ASTEROID_CONFIG.minSize + Math.random() * (ASTEROID_CONFIG.maxSize - ASTEROID_CONFIG.minSize);

        const asteroid = {
            x: x,
            y: y,
            size: size,
            type: type,
            scale: scale,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: ASTEROID_CONFIG.rotationSpeed.min + Math.random() * (ASTEROID_CONFIG.rotationSpeed.max - ASTEROID_CONFIG.rotationSpeed.min),
            frame: Math.floor(Math.random() * 25), // Use frames 0-24 to avoid missing frames
            maxFrames: 25,
            animationSpeed: 0.1 + Math.random() * 0.1, // 0.1-0.2 seconds per frame
            lastFrameTime: Date.now(),
            imageKey: `${size}_${type}`
        };

        asteroids.push(asteroid);
    }

    console.log(`âœ… Generated ${asteroids.length} asteroids`);
}

// Update asteroid animations
function updateAsteroids() {
    if (!asteroidsLoaded) return;
    
    const currentTime = Date.now();
    
    asteroids.forEach(asteroid => {
        // Update rotation
        asteroid.rotation += asteroid.rotationSpeed;
        
        // Update animation frame
        if (currentTime - asteroid.lastFrameTime > (asteroid.animationSpeed * 1000)) {
            asteroid.frame = (asteroid.frame + 1) % asteroid.maxFrames;
            asteroid.lastFrameTime = currentTime;
        }
    });
}

// Render asteroids
function renderAsteroids() {
    if (!asteroidsLoaded || asteroids.length === 0) return;

    const player = gameState.players[gameState.playerId];
    if (!player) return;

    asteroids.forEach(asteroid => {
        // Check if asteroid is visible on screen
        const relativeX = asteroid.x - player.x;
        const relativeY = asteroid.y - player.y;
        
        // Only render if within reasonable distance
        if (Math.abs(relativeX) > 1000 || Math.abs(relativeY) > 1000) return;

        const imageArray = asteroidImages[asteroid.imageKey];
        let rendered = false;
        
        if (imageArray && imageArray[asteroid.frame]) {
            const img = imageArray[asteroid.frame];
            
            // Check if it's a valid image (not broken)
            if (img && (img.complete && img.naturalWidth > 0) || img instanceof HTMLCanvasElement) {
                try {
                    ctx.save();
                    ctx.translate(relativeX, relativeY);
                    ctx.rotate(asteroid.rotation);
                    ctx.scale(asteroid.scale, asteroid.scale);
                    
                    const width = img.naturalWidth || img.width || 64;
                    const height = img.naturalHeight || img.height || 64;
                    
                    ctx.drawImage(img, -width/2, -height/2, width, height);
                    ctx.restore();
                    rendered = true;
                } catch (e) {
                    // Image is broken, fall back to simple shape
                    console.warn('Failed to render asteroid image:', e);
                }
            }
        }
        
        if (!rendered) {
            // Fallback: draw a simple circle
            ctx.save();
            ctx.fillStyle = asteroid.type === 'Gold' ? '#FFD700' : 
                           asteroid.type === 'Ice' ? '#87CEEB' : '#8B4513';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(relativeX, relativeY, 30 * asteroid.scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
    });
}

// Cooldown cursor system
// Cursor is now handled directly via CSS cursor property

// Cooldown cursor functions moved to WeaponSystem

// Damage numbers system - only visible to the shooter
let damageNumbers = [];
let killStreak = 0;
let killStreakTimer = 0;
let notifications = [];

// Hit markers for better feedback
let hitMarkers = [];

// Kill streak rewards and names
const KILL_STREAK_REWARDS = {
    3: { name: 'TRIPLE KILL', bonus: 100, color: '#FFD700' },
    5: { name: 'KILLING SPREE', bonus: 250, color: '#FF6B00' },
    7: { name: 'RAMPAGE', bonus: 500, color: '#FF0000' },
    10: { name: 'UNSTOPPABLE', bonus: 1000, color: '#FF00FF' },
    15: { name: 'LEGENDARY', bonus: 2000, color: '#00FFFF' }
};

// Particle trail system for bullets - now handled by ParticleSystem

// Screen distortion effects
let screenDistortion = { intensity: 0, type: 'none' };

function showNotification(text, color = '#FFD700', size = 32) {
    // Notifications now handled by RenderSystem
    if (renderSystem) {
        renderSystem.showNotification(text, color, size);
    } else {
        // Fallback for when renderSystem is not yet initialized
        notifications.push({
            text,
            color,
            y: 200,
            life: 1,
            decay: 0.01,
            size: size
        });
    }
}

function addKillStreakReward() {
    killStreak++;
    killStreakTimer = 5000; // 5 seconds to continue streak

    // Check for kill streak rewards
    if (KILL_STREAK_REWARDS[killStreak]) {
        const reward = KILL_STREAK_REWARDS[killStreak];
        gameState.fortzCurrency += reward.bonus;
        updateFortzDisplay();
        showNotification(`${reward.name}! +${reward.bonus} FORTZ`, reward.color, 48);
        if (particleSystem) {
            particleSystem.triggerScreenShake(8, 500);

            // Create massive explosion effect
            const player = gameState.players[gameState.playerId];
            if (player) {
                particleSystem.createExplosion(player.x, player.y, 3);
            }
        }
    } else {
        showNotification(`${killStreak} KILL STREAK!`, '#FFD700', 36);
    }
}

function resetKillStreak() {
    if (killStreak > 0) {
        showNotification(`Streak Ended: ${killStreak} kills`, '#FF5050', 28);
    }
    killStreak = 0;
    killStreakTimer = 0;
}

function updateAndDrawNotifications() {
    // Notifications now handled by RenderSystem
    if (renderSystem) {
        renderSystem.updateAndDrawNotifications();
    }
}

// Bullet trail functions moved to ParticleSystem

// Bullet impact and explosion particle systems - now handled by ParticleSystem

// Explosion functions moved to ParticleSystem

// Tank exhaust smoke system - now handled by ParticleSystem

// Bullet impact functions moved to ParticleSystem

// Screen shake and muzzle flash functions moved to ParticleSystem

// Sprite sheet animation system
const spriteAnimations = {
    tanks: {},
    weapons: {}
};

// Initialize sprite animation for a tank/weapon
function initSpriteAnimation(type, playerId, assetKey) {
    const key = `${playerId}_${assetKey}`;
    if (!spriteAnimations[type][key]) {
        // Tank bodies have 2 frames, weapons have 8 frames
        const numFrames = type === 'tanks' ? 2 : 8;

        spriteAnimations[type][key] = {
            currentFrame: 0,
            lastFrameTime: 0,
            frameDuration: type === 'weapons' ? 10 : 80, // Lightning fast weapon animation when shooting (5x faster), normal tank speed
            numFrames: numFrames, // 2 for tanks, 8 for weapons
            frameWidth: 128, // Default from Ground Shaker pack
            frameHeight: 128,
            isPlaying: type === 'tanks', // Only tanks play continuously, weapons play on shooting
            loop: type === 'tanks' // Only tanks loop continuously, weapons play once when shooting
        };
    }
    return spriteAnimations[type][key];
}

// Update sprite animation frame
function updateSpriteAnimation(type, playerId, assetKey, deltaTime) {
    const key = `${playerId}_${assetKey}`;
    const anim = spriteAnimations[type][key];
    if (!anim) return 0;



    // Only animate if playing
    if (anim.isPlaying) {
        anim.lastFrameTime += deltaTime;
        if (anim.lastFrameTime >= anim.frameDuration) {
            const oldFrame = anim.currentFrame;
            anim.currentFrame = (anim.currentFrame + 1) % anim.numFrames;
            anim.lastFrameTime = anim.lastFrameTime - anim.frameDuration; // Carry over extra time for smoother animation



            // Stop if not looping and reached end
            if (!anim.loop && anim.currentFrame === 0) {
                anim.isPlaying = false;
            }
        }
    }
    return anim.currentFrame;
}

// Enhanced tank body animation with sprite sheet support
function triggerTankBodyAnimation(playerTank, playerId = gameState.playerId) {
    const tankImg = tankImages[playerTank.color]?.[playerTank.body];

    // Initialize animation for this tank
    const assetKey = `${playerTank.color}_${playerTank.body}`;
    const anim = initSpriteAnimation('tanks', playerId, assetKey);

    // For PNG sprite sheets, just ensure animation is playing with faster speed
    if (tankImg && tankImg.src && tankImg.src.includes('.png')) {
        if (anim) {
            anim.isPlaying = true;
            anim.loop = true;
            anim.frameDuration = 40; // Faster animation (was 60ms, now 40ms for smoother movement)
        }
    }
    // For GIFs, they auto-animate, no need to reload constantly

    // Add track animation frame counter for non-GIF tanks
    if (!playerTank.trackFrame) playerTank.trackFrame = 0;
    playerTank.trackFrame = (playerTank.trackFrame + 1) % 60;
}

// Helper function to get current player velocity - now uses PhysicsSystem
function getCurrentPlayerVelocity(playerId) {
    if (physicsSystem) {
        return physicsSystem.getCurrentPlayerVelocity(playerId);
    }
    return { x: 0, y: 0 };
}

// Find nearest target for aimbot assist
function findNearestTarget(player) {
    let nearestTarget = null;
    let nearestDistance = AIMBOT_MAX_RANGE;

    // Check other players
    Object.values(gameState.players).forEach(otherPlayer => {
        if (otherPlayer.id !== player.id) {
            const dist = distance(player, otherPlayer);
            if (dist < nearestDistance) {
                nearestDistance = dist;
                nearestTarget = otherPlayer;
            }
        }
    });

    // Check shapes (if you want to assist aiming at shapes too)
    gameState.shapes.forEach(shape => {
        const dist = distance(player, shape);
        if (dist < nearestDistance) {
            nearestDistance = dist;
            nearestTarget = shape;
        }
    });

    return nearestTarget;
}

// Blend two angles with a strength factor
function blendAngles(angle1, angle2, strength) {
    // Normalize angle difference to [-PI, PI]
    let diff = angle2 - angle1;
    while (diff > Math.PI) diff -= 2 * Math.PI;
    while (diff < -Math.PI) diff += 2 * Math.PI;

    // Blend the angles
    return angle1 + diff * strength;
}

// Images already initialized at the top of the file

// Game constants - physics constants moved to PhysicsSystem
const TANK_VISUAL_SIZE = 428; // Size for rendering the tank - 10% smaller (476 * 0.9)
const GUN_SIZE = 1503; // Size for gun rendering - 10% smaller than 1670 (1670 * 0.9)

// Power-up system with new items - server will manage spawning
let powerUps = [];


let activePowerUps = [];
let comboMultiplier = 1;
let comboTimer = 0;




// Sprint system constants moved to PhysicsSystem

// Aimbot assist system
let aimbotEnabled = false;
const AIMBOT_ASSIST_STRENGTH = 0.3; // 30% aim assistance towards nearest target
const AIMBOT_MAX_RANGE = 600; // Maximum range for aim assist


// Player health state - dual system (shield + health)
let playerHealth = 100;
let maxPlayerHealth = 100;
let playerShield = 100;
let maxPlayerShield = 100;

// Smooth health/shield animation
let displayHealth = 100;
let displayShield = 100;
let targetHealth = 100;
let targetShield = 100;

// Tank physics state moved to PhysicsSystem

// Tank body recoil for sprint animation
let tankBodyRecoil = { offset: 0, targetOffset: 0 };

// Shooting system - now handled by WeaponSystem

// Enhanced player recoil system moved to PhysicsSystem

// Auto-fire system for Q key
let autoFireEnabled = false;

// Lava damage cooldown
let lavaDamageCooldown = 0;
const LAVA_DAMAGE_INTERVAL = 500; // 500ms cooldown between lava damage hits

// Socket.IO connection - now handled by NetworkSystem
function connectToServer() {
    const gameMode = gameState.selectedGameMode || 'ffa';
    networkSystem.connectToServer(gameMode);
}

// Message handling is now managed by NetworkSystem

function joinGame() {
    // Show loading overlay
    const loadingOverlay = document.getElementById('loadingOverlay');
    if (loadingOverlay) {
        loadingOverlay.classList.remove('hidden');
    }

    // Reset health and shield when joining game - both start at 100 and max at 100
    playerHealth = 100;
    maxPlayerHealth = 100;
    playerShield = 100;
    maxPlayerShield = 100;

    // Initialize display values for smooth animation
    displayHealth = 100;
    displayShield = 100;
    targetHealth = 100;
    targetShield = 100;

    // Update health display immediately
    updateHealthDisplay();

    // Close shop if it's open when joining game
    if (gameState.showShop) {
        gameStateManager.updateGameState({ showShop: false });
        stopLobbyShopRendering();
    }

    // Start game without name validation
    document.getElementById('lobbyScreen').style.animation = 'fadeOut 0.5s ease-out';
    setTimeout(() => {
        // Hide the entire lobby screen
        const lobbyScreen = document.getElementById('lobbyScreen');
        if (lobbyScreen) {
            lobbyScreen.classList.add('hidden');
            lobbyScreen.style.display = 'none';
        }
        
        // Hide all lobby background canvases
        const tankCanvas = document.getElementById('tankLobbyBackground');
        const jetCanvas = document.getElementById('jetLobbyBackground');
        const raceCanvas = document.getElementById('raceLobbyBackground');
        if (tankCanvas) tankCanvas.style.display = 'none';
        if (jetCanvas) jetCanvas.style.display = 'none';
        if (raceCanvas) raceCanvas.style.display = 'none';
        
        document.getElementById('gameMapArea').classList.remove('hidden');
        document.getElementById('ui').classList.remove('hidden');
        document.getElementById('scoreProgressContainer').classList.remove('hidden');
        document.getElementById('centerBottomBoxes').classList.remove('hidden');
        gameStateManager.updateGameState({ isInLobby: false });

        // Clear DOM map renderer's game container to prevent duplicate rendering
        if (window.DOMMapRenderer && typeof window.DOMMapRenderer.clearGameMap === 'function') {
            window.DOMMapRenderer.clearGameMap();
        }

        // CRITICAL: Load the selected map into the game renderer BEFORE initializing
        // Only use player-created maps, never default/built-in maps
        if (window.selectedCreatedMapId && window.MapRenderer) {
            console.log('ðŸ—ºï¸ Loading selected map into game:', window.selectedCreatedMapId);
            window.MapRenderer.loadById(window.selectedCreatedMapId);
        } else if (window.DOMMapRenderer?.currentMap && window.MapRenderer) {
            // Fallback: use the map from DOM renderer
            console.log('ðŸ—ºï¸ Loading current map from DOM renderer into game');
            window.MapRenderer.loadMap(window.DOMMapRenderer.currentMap);
        } else {
            // Try to load the first available player-created map
            try {
                const maps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]');
                const createdMaps = maps.filter(m => m.isUserCreated !== false);
                if (createdMaps.length > 0 && window.MapRenderer) {
                    console.log('ðŸ—ºï¸ Loading first available created map:', createdMaps[0].name);
                    window.MapRenderer.loadMap(createdMaps[0]);
                } else {
                    console.warn('âš ï¸ No created maps available - create a map first!');
                }
            } catch (e) {
                console.warn('âš ï¸ Error loading maps:', e);
            }
        }

        // Show game canvas for dynamic elements
        setTimeout(() => {
            const gameCanvas = document.getElementById('gameCanvas');
            if (gameCanvas) {
                gameCanvas.style.display = 'block';
            }
        }, 100);

        initializeGame();

        // Loading will be handled by waitForLoadingComplete() when images finish loading
        console.log('ðŸŽ® Game initialized, waiting for image loading to complete...');
    }, 500);
}

// Expose joinGame globally
window.joinGame = joinGame;

// Team mode selection (solo, duo, trio, squad)
let selectedTeamMode = 'solo';

function toggleTeamModeDropdown() {
    const dropdown = document.getElementById('teamModeDropdown');
    if (dropdown) {
        dropdown.classList.toggle('hidden');
    }
}

function selectTeamMode(mode) {
    selectedTeamMode = mode;
    const teamModeText = document.getElementById('teamModeText');
    if (teamModeText) {
        teamModeText.textContent = mode.toUpperCase();
    }
    
    // Update selected state
    document.querySelectorAll('.team-mode-option').forEach(opt => {
        opt.classList.remove('selected');
        if (opt.textContent.toLowerCase() === mode) {
            opt.classList.add('selected');
        }
    });
    
    // Hide dropdown
    const dropdown = document.getElementById('teamModeDropdown');
    if (dropdown) {
        dropdown.classList.add('hidden');
    }
    
    showNotification(`Team mode: ${mode.toUpperCase()}`, '#a855f7', 24);
}

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('teamModeDropdown');
    const soloBtn = document.getElementById('soloBtn');
    if (dropdown && soloBtn && !dropdown.contains(e.target) && !soloBtn.contains(e.target)) {
        dropdown.classList.add('hidden');
    }
});

window.toggleTeamModeDropdown = toggleTeamModeDropdown;
window.selectTeamMode = selectTeamMode;

// Game initialization
function initializeGame() {
    // Get the game canvas (now inside gameMapArea for dynamic elements overlay)
    canvas = document.getElementById('gameCanvas');
    if (canvas) {
        ctx = canvas.getContext('2d');
        
        // Initialize particle system with canvas and context
        particleSystem = new ParticleSystem(gameState, canvas, ctx);
        
        // Initialize weapon system with required dependencies
        weaponSystem = new WeaponSystem(gameState, networkSystem, particleSystem, imageLoader);
    }

    // Minimap still uses canvas
    minimapCanvas = document.getElementById('minimapCanvas');
    if (minimapCanvas) {
        minimapCtx = minimapCanvas.getContext('2d');
    }

    // Initialize render system with canvas and context
    renderSystem = new RenderSystem(gameState, canvas, ctx, minimapCanvas, minimapCtx);
    renderSystem.setDependencies(particleSystem, imageLoader, tankImages, weaponImages, imagesLoaded, spriteAnimations);

    resizeCanvas();

    // Connect to server
    if (!gameState.isConnected) {
        connectToServer();
    }

    updatePlayerStats();
    updateUI();
    updateHealthDisplay();

    // Initialize input system
    inputSystem.initialize();

    // Load and generate asteroids
    loadAsteroidImages();

    // Start game loop
    gameLoop();

    // Additional UI update after connection is established
    setTimeout(() => {
        updateUI();
    }, 500);

    // Trigger CrazyGames gameplay start event
    if (window.CrazyGamesIntegration) {
        window.CrazyGamesIntegration.gameplayStart();
    }
}

function resizeCanvas() {
    if (renderSystem) {
        renderSystem.resizeCanvas();
    } else {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
}

// Input handling is now managed by InputSystem

// Keyboard input handling is now managed by InputSystem

// Canvas input handling is now managed by InputSystem

// Movement updates are now managed by NetworkSystem

// Tank physics functions moved to PhysicsSystem

// Collision detection and camera functions moved to PhysicsSystem
function isNearWall(x, y) {
    if (physicsSystem) {
        return physicsSystem.isNearWall(x, y);
    }
    return false;
}

function updateCamera(player) {
    if (physicsSystem) {
        physicsSystem.updateCamera(player);
    }
}

function gameLoop() {
    if (!gameState.isInLobby) {
        update();
        render();
        animationId = requestAnimationFrame(gameLoop);
    }
}

function update() {
    // Update input system
    inputSystem.update(16.67, gameState); // ~60 FPS delta time
    
    // Update animation manager for all animations
    if (window.tankAnimationManager) {
        window.tankAnimationManager.update();
    }

    // Update asteroids
    updateAsteroids();
    
    // Update particle system
    if (particleSystem) {
        particleSystem.update();
    }

    // Update physics system
    if (physicsSystem) {
        physicsSystem.update(16.67); // ~60 FPS delta time
    }

    // ===== CLIENT-SIDE PHYSICS UPDATE (EVERY FRAME FOR SMOOTH MOVEMENT) =====
    if (gameState.playerId && gameState.players[gameState.playerId]) {
        const player = gameState.players[gameState.playerId];

        // Calculate input direction
        // Get movement input from InputSystem
        const movement = inputSystem.getMovementInput();
        let inputX = movement.x;
        let inputY = movement.y;

        // Update tank physics with sliding effect (EVERY FRAME)
        if (physicsSystem) {
            physicsSystem.updateTankPhysics(inputX, inputY);
        }

        // Initialize smooth position tracking if not exists
        if (typeof player.smoothX === 'undefined') {
            player.smoothX = player.x;
            player.smoothY = player.y;
        }

        // CLIENT-SIDE PREDICTION: Apply velocity to actual position immediately
        const tankVelocity = physicsSystem ? physicsSystem.getTankVelocity() : { x: 0, y: 0 };
        player.x += tankVelocity.x;
        player.y += tankVelocity.y;

        // Smooth visual position = actual position (no interpolation needed)
        player.smoothX = player.x;
        player.smoothY = player.y;

        // No boundaries - player can move freely on the created map

        // Hazard terrain check removed - using custom created maps only

        // Update movement animation
        const currentSpeed = Math.sqrt(tankVelocity.x * tankVelocity.x + tankVelocity.y * tankVelocity.y);
        const isMoving = currentSpeed > 0.5;

        const playerTank = player.selectedTank || gameState.selectedTank;
        const assetKey = `${playerTank.color}_${playerTank.body}`;
        const animKey = `${player.id}_${assetKey}`;
        let anim = spriteAnimations.tanks[animKey];

        if (!anim) {
            anim = initSpriteAnimation('tanks', player.id, assetKey);
        }

        if (isMoving) {
            anim.isPlaying = true;
            anim.loop = true;
            anim.frameDuration = 40;

            if (player.currentRotation !== undefined && particleSystem) {
                const isSprinting = physicsSystem ? physicsSystem.getIsSprinting() : false;
                particleSystem.createExhaustSmoke(player.x, player.y, player.currentRotation, tankVelocity, isSprinting);
            }
        } else {
            anim.isPlaying = false;
            anim.currentFrame = 0;
        }
    }

    // Update sprite animations (16ms ~= 60fps)
    Object.values(gameState.players).forEach(player => {
        const playerTank = player.selectedTank || gameState.selectedTank;
        const tankAssetKey = `${playerTank.color}_${playerTank.body}`;
        const weaponAssetKey = `${playerTank.color}_${playerTank.weapon}`;

        // Calculate if this player is moving (for other players, check position changes)
        let isMoving = false;
        if (player.id === gameState.playerId) {
            const tankVelocity = physicsSystem ? physicsSystem.getTankVelocity() : { x: 0, y: 0 };
            const currentSpeed = Math.sqrt(tankVelocity.x * tankVelocity.x + tankVelocity.y * tankVelocity.y);
            isMoving = currentSpeed > 0.5;
        } else {
            // For other players, check if they have recent position updates
            if (player.lastPosition) {
                const dx = player.x - player.lastPosition.x;
                const dy = player.y - player.lastPosition.y;
                const speed = Math.sqrt(dx * dx + dy * dy);
                isMoving = speed > 0.5;
            }
            // Store current position for next frame comparison
            player.lastPosition = { x: player.x, y: player.y };
        }

        // Update tank body animation state
        const tankAnimKey = `${player.id}_${tankAssetKey}`;
        let tankAnim = spriteAnimations.tanks[tankAnimKey];

        if (!tankAnim) {
            tankAnim = initSpriteAnimation('tanks', player.id, tankAssetKey);
        }

        if (tankAnim) {
            tankAnim.isPlaying = isMoving;
            tankAnim.loop = true;
            tankAnim.frameDuration = 40;

            if (!isMoving) {
                tankAnim.currentFrame = 0;
            }
        }

        updateSpriteAnimation('tanks', player.id, tankAssetKey, 16);
        updateSpriteAnimation('weapons', player.id, weaponAssetKey, 16);
    });

    // Smooth health/shield animation - faster for smoother counting
    const healthSpeed = 0.25;
    displayHealth += (targetHealth - displayHealth) * healthSpeed;
    displayShield += (targetShield - displayShield) * healthSpeed;

    // Update weapon system (includes gun recoil animation)
    if (weaponSystem) {
        weaponSystem.update(0.016, activePowerUps); // 16ms delta time for 60fps
    }

    // Update power-ups
    updatePowerUps();

    // Update combo system
    if (comboTimer > 0) {
        comboTimer -= 16;
        if (comboTimer <= 0) {
            comboMultiplier = 1;
        }
    }

    // Update kill streak timer
    if (killStreakTimer > 0) {
        killStreakTimer -= 16;
        if (killStreakTimer <= 0) {
            resetKillStreak();
        }
    }

    // Update screen distortion
    if (screenDistortion.intensity > 0) {
        screenDistortion.intensity *= 0.95;
        if (screenDistortion.intensity < 0.1) {
            screenDistortion.intensity = 0;
            screenDistortion.type = 'none';
        }
    }

    // Auto-fire when Q is held down
    if (autoFireEnabled && !gameState.isInLobby && weaponSystem) {
        const currentTime = Date.now();
        weaponSystem.handleShooting(currentTime, activePowerUps);
    }

    // Handle shape respawn timers
    for (const shapeId in gameState.shapeSpawnTimers) {
        gameState.shapeSpawnTimers[shapeId] -= 0.016;
        if (gameState.shapeSpawnTimers[shapeId] <= 0) {
            networkSystem.sendRequestShapeSpawn('PENTAGON', '#1E90FF');
            delete gameState.shapeSpawnTimers[shapeId];
        }
    }

    // Only update movement for the current player
    if (!gameState.playerId || !gameState.players[gameState.playerId]) return;

    const player = gameState.players[gameState.playerId];
    if (!player) return;

    // Smooth tank rotation animation for all players (360 degrees based on WASD movement)
    Object.values(gameState.players).forEach(p => {
        // Calculate tank rotation from velocity for own player, use server value for others
        let targetRotation;
        if (p.id === gameState.playerId) {
            // For own player, calculate rotation from input direction (not velocity to avoid recoil rotation)
            if (Math.abs(lastInputDirection.x) > 0.01 || Math.abs(lastInputDirection.y) > 0.01) {
                targetRotation = Math.atan2(lastInputDirection.y, lastInputDirection.x);
            } else if (p.currentRotation !== undefined) {
                // Keep current rotation if not moving
                targetRotation = p.currentRotation;
            } else {
                targetRotation = 0;
            }
        } else {
            // For other players, use the server-provided tankDirection (already in radians from atan2)
            targetRotation = p.tankDirection !== undefined ? p.tankDirection : 0;
        }

        // Initialize rotation if not set
        if (p.currentRotation === undefined) {
            p.currentRotation = targetRotation;
        }

        // Smooth interpolation to target rotation with slower speed for 360-degree rotation
        let diff = targetRotation - p.currentRotation;

        // Normalize to [-PI, PI] for shortest rotation path
        while (diff > Math.PI) diff -= 2 * Math.PI;
        while (diff < -Math.PI) diff += 2 * Math.PI;

        // Slower, smoother interpolation for full 360-degree rotation visibility
        const rotationSpeed = 0.15; // Slower than before (was 0.35) for smoother 360 rotation
        p.currentRotation += diff * rotationSpeed;

        // Keep rotation in full 360-degree range without normalization wrapping
        // This allows the rotation to accumulate and show full 360-degree turns
        if (p.currentRotation > Math.PI * 4) p.currentRotation -= Math.PI * 2;
        if (p.currentRotation < -Math.PI * 4) p.currentRotation += Math.PI * 2;

        // Initialize smooth gun rotation if not exists
        if (p.smoothGunAngle === undefined) {
            p.smoothGunAngle = p.angle || 0;
        }

        // Smooth gun rotation for all players - weapon follows mouse 360 degrees
        // For local player, use direct mouse angle for instant response
        // For other players, use server-provided angle
        let targetGunAngle;
        if (p.id === gameState.playerId) {
            // Local player: use direct mouse angle for instant 360Â° rotation
            targetGunAngle = gameState.mouse.angle;
        } else {
            // Other players: use server-provided angle
            targetGunAngle = p.angle || 0;
        }

        if (targetGunAngle !== undefined) {
            let gunDiff = targetGunAngle - p.smoothGunAngle;

            // Normalize to [-PI, PI] to find shortest rotation path
            while (gunDiff > Math.PI) gunDiff -= 2 * Math.PI;
            while (gunDiff < -Math.PI) gunDiff += 2 * Math.PI;

            // Smooth gun interpolation
            p.smoothGunAngle += gunDiff * GUN_ROTATION_SPEED;

            // Keep angle in valid range but allow full rotation
            if (p.smoothGunAngle > Math.PI * 4) p.smoothGunAngle -= Math.PI * 2;
            if (p.smoothGunAngle < -Math.PI * 4) p.smoothGunAngle += Math.PI * 2;
        }
    });

    // Update camera for our player only
    updateCamera(player);
}

// Power-up system functions
function spawnPowerUp() {
    if (powerUps.length >= 5) return;

    const types = Object.keys(POWERUP_CONFIG.TYPES);
    const type = types[Math.floor(Math.random() * types.length)];
    const config = POWERUP_CONFIG.TYPES[type];

    powerUps.push({
        id: Date.now() + Math.random(),
        type,
        x: 0,
        y: 0,
        image: config.image,
        color: config.color,
        effect: config.effect,
        duration: config.duration,
        pulse: 0
    });
}

function updatePowerUps() {
    // Server manages spawning, so we don't spawn client-side anymore

    // Update existing power-ups pulse animation
    powerUps.forEach(p => p.pulse += 0.1);

    // Check collision with player
    const player = gameState.players[gameState.playerId];
    if (player) {
        powerUps.forEach(powerUp => {
            const dx = player.x - powerUp.x;
            const dy = player.y - powerUp.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < TANK_SIZE) {
                // Notify server of collection
                networkSystem.sendCollectPowerUp(powerUp.id);
                collectPowerUp(powerUp);
            }
        });
    }

    // Update active power-ups
    activePowerUps = activePowerUps.filter(p => {
        p.timeLeft -= 16;
        return p.timeLeft > 0;
    });
}

function collectPowerUp(powerUp) {
    if (particleSystem) {
        particleSystem.createExplosion(powerUp.x, powerUp.y, 0.5);
    }

    if (powerUp.effect === 'bluehealth') {
        // Blue Health: +100 health instantly
        playerHealth = Math.min(maxPlayerHealth, playerHealth + 100);
        updateHealthDisplay();
        showNotification('HEALTH BOOST! +100 Health', '#4169E1');
    }

    // Increase combo
    comboMultiplier = Math.min(5, comboMultiplier + 0.5);
    comboTimer = POWERUP_CONFIG.COMBO_DURATION;
}

// Add power-up to display with circular timer
function addPowerUpToDisplay(effect, icon, color, duration) {
    const display = document.getElementById('powerUpDisplay');
    if (!display) return;

    // Remove existing power-up of same type if present
    const existing = document.getElementById(`powerup-${effect}`);
    if (existing) existing.remove();

    // Create power-up container
    const container = document.createElement('div');
    container.id = `powerup-${effect}`;
    container.style.position = 'relative';
    container.style.width = '70px';
    container.style.height = '70px';

    // Create SVG for circular timer
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '70');
    svg.setAttribute('height', '70');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.transform = 'rotate(-90deg)';

    // Background circle
    const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    bgCircle.setAttribute('cx', '35');
    bgCircle.setAttribute('cy', '35');
    bgCircle.setAttribute('r', '32');
    bgCircle.setAttribute('fill', 'none');
    bgCircle.setAttribute('stroke', 'rgba(100, 100, 100, 0.3)');
    bgCircle.setAttribute('stroke-width', '4');

    // Progress circle
    const progressCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    progressCircle.setAttribute('cx', '35');
    progressCircle.setAttribute('cy', '35');
    progressCircle.setAttribute('r', '32');
    progressCircle.setAttribute('fill', 'none');
    progressCircle.setAttribute('stroke', color);
    progressCircle.setAttribute('stroke-width', '4');
    const circumference = 2 * Math.PI * 32;
    progressCircle.setAttribute('stroke-dasharray', circumference);
    progressCircle.setAttribute('stroke-dashoffset', '0');
    progressCircle.style.filter = `drop-shadow(0 0 8px ${color})`;

    svg.appendChild(bgCircle);
    svg.appendChild(progressCircle);

    // Icon container (now using image)
    const iconDiv = document.createElement('div');
    iconDiv.style.position = 'absolute';
    iconDiv.style.top = '50%';
    iconDiv.style.left = '50%';
    iconDiv.style.transform = 'translate(-50%, -50%)';
    iconDiv.style.width = '50px';
    iconDiv.style.height = '50px';
    iconDiv.style.borderRadius = '50%';
    iconDiv.style.background = `${color}33`;
    iconDiv.style.display = 'flex';
    iconDiv.style.alignItems = 'center';
    iconDiv.style.justifyContent = 'center';
    iconDiv.style.border = `3px solid ${color}`;
    iconDiv.style.boxShadow = `0 0 15px ${color}80`;

    // Create image element instead of text
    const img = document.createElement('img');
    img.src = icon;
    img.style.width = '40px';
    img.style.height = '40px';
    img.style.objectFit = 'contain';
    iconDiv.appendChild(img);

    container.appendChild(svg);
    container.appendChild(iconDiv);
    display.appendChild(container);

    // Animate timer
    const startTime = Date.now();
    const timerInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const remaining = duration - elapsed;

        if (remaining <= 0) {
            clearInterval(timerInterval);
            container.remove();
            permanentPowerUps[effect] = false;
            showNotification(`${effect.toUpperCase()} EXPIRED`, '#ff5050');
        } else {
            const progress = remaining / duration;
            const offset = circumference * (1 - progress);
            progressCircle.setAttribute('stroke-dashoffset', offset);
        }
    }, 100);
}

function drawPowerUps() {
    // Power-ups removed - function kept for compatibility
    return;
}

// Sprint system update function moved to PhysicsSystem

// Update sprint bar display - now uses PhysicsSystem
function updateSprintBar() {
    if (!physicsSystem) return;
    
    const sprintBar = document.getElementById('sprintBar');
    const sprintValue = document.getElementById('sprintValue');
    const sprintStamina = physicsSystem.getSprintStamina();
    const SPRINT_DURATION = 200; // Get from physics system

    if (sprintBar) {
        const percentage = (sprintStamina / SPRINT_DURATION) * 100;
        sprintBar.style.width = percentage + '%';

        // Change color based on stamina level
        if (percentage > 60) {
            sprintBar.style.background = 'linear-gradient(90deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%)';
        } else if (percentage > 30) {
            sprintBar.style.background = 'linear-gradient(90deg, #FF8C00 0%, #FF6347 50%, #FF4500 100%)';
        } else {
            sprintBar.style.background = 'linear-gradient(90deg, #FF4500 0%, #DC143C 50%, #B22222 100%)';
        }
    }

    if (sprintValue) {
        sprintValue.textContent = Math.ceil(sprintStamina);
    }
}

// Update kill streak display
function updateKillStreakDisplay() {
    const display = document.getElementById('killStreakDisplay');
    if (!display) return;

    if (killStreak > 0) {
        display.style.display = 'block';
        const number = display.querySelector('.streak-number');
        const label = display.querySelector('.streak-label');

        if (number) number.textContent = killStreak;

        // Update color based on streak
        if (killStreak >= 15) {
            display.style.borderColor = 'rgba(0, 255, 255, 0.8)';
            display.style.background = 'linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(138, 43, 226, 0.3))';
        } else if (killStreak >= 10) {
            display.style.borderColor = 'rgba(255, 0, 255, 0.8)';
            display.style.background = 'linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(255, 20, 147, 0.3))';
        } else if (killStreak >= 7) {
            display.style.borderColor = 'rgba(255, 0, 0, 0.8)';
            display.style.background = 'linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(220, 20, 60, 0.3))';
        } else if (killStreak >= 5) {
            display.style.borderColor = 'rgba(255, 107, 0, 0.8)';
            display.style.background = 'linear-gradient(135deg, rgba(255, 107, 0, 0.3), rgba(255, 69, 0, 0.3))';
        }
    } else {
        display.style.display = 'none';
    }
}

// Gun recoil animation functions moved to WeaponSystem

// Update health display - dual system (shield + health)
function updateHealthDisplay() {
    const healthBar = document.getElementById('healthBar');
    const healthValue = document.getElementById('healthValue');
    const shieldBar = document.getElementById('shieldBar');
    const shieldValue = document.getElementById('shieldValue');

    // Clamp values to max of 100
    playerHealth = Math.min(100, Math.max(0, playerHealth));
    playerShield = Math.min(100, Math.max(0, playerShield));

    // Set target values for smooth animation
    targetHealth = playerHealth;
    targetShield = playerShield;

    // Update shield bar (blue) - fills from left to right (max 100)
    if (shieldBar) {
        const percentage = Math.min(100, Math.max(0, (displayShield / 100) * 100));
        shieldBar.style.width = percentage + '%';
    }

    if (shieldValue) {
        // Display whole number for smooth counting animation
        shieldValue.textContent = Math.round(Math.min(100, Math.max(0, displayShield)));
    }

    // Update health bar (green) - fills from left to right (max 100)
    if (healthBar) {
        const percentage = Math.min(100, Math.max(0, (displayHealth / 100) * 100));
        healthBar.style.width = percentage + '%';
    }

    if (healthValue) {
        // Display whole number for smooth counting animation
        healthValue.textContent = Math.round(Math.min(100, Math.max(0, displayHealth)));
    }
}

function render() {
    // Rendering now handled by RenderSystem
    if (renderSystem) {
        renderSystem.render();
    }
}

// Draw AI tanks - now handled by RenderSystem
function drawAITanks() {
    if (renderSystem) {
        renderSystem.drawAITanks();
    }
}

// Helper to get hex color for AI tank - now handled by RenderSystem
function getTankColorHex(color) {
    if (renderSystem) {
        return renderSystem.getTankColorHex(color);
    }
    const colors = {
        'blue': '#2196F3',
        'red': '#f44336',
        'camo': '#4CAF50',
        'desert': '#D2691E',
        'purple': '#9C27B0'
    };
    return colors[color] || colors.red;
}

// Sand background rendering for main game - matches create map editor positioning exactly
function drawSandBackground(ctx) {
    const tileWidth = 120;
    const tileHeight = 30;
    const drawHeight = 70;
    const zoom = gameState.camera.zoom || 1;

    // Get player position (camera center)
    const player = Object.values(gameState.players).find(p => p.id === gameState.playerId);
    const centerX = player ? player.x : (gameState.camera.x || 0);
    const centerY = player ? player.y : (gameState.camera.y || 0);

    // Calculate viewport dimensions in world coordinates
    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    // Calculate visible viewport bounds in world coordinates centered on player
    const viewLeft = centerX - viewWidth / 2;
    const viewTop = centerY - viewHeight / 2;
    const viewRight = centerX + viewWidth / 2;
    const viewBottom = centerY + viewHeight / 2;

    // Add generous padding to ensure full screen coverage
    const paddingX = tileWidth * 4;
    const paddingY = drawHeight * 6; // Extra padding for tile overlap

    // Calculate tile range - only visible tiles
    const startCol = Math.floor((viewLeft - paddingX) / tileWidth);
    const endCol = Math.ceil((viewRight + paddingX) / tileWidth);
    const startRow = Math.floor((viewTop - paddingY) / tileHeight);
    const endRow = Math.ceil((viewBottom + paddingY) / tileHeight);

    // Draw sand tiles (LightSand as background)
    for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
            // Calculate isometric position
            const isoX = col * tileWidth + (row % 2) * (tileWidth / 2);
            const isoY = row * tileHeight;

            // Draw sand tile with isometric shape
            drawSandTile(ctx, isoX, isoY, tileWidth, drawHeight);
        }
    }
}

// Draw a single sand tile (LightSand style)
function drawSandTile(ctx, x, y, width, height) {
    // Isometric diamond points
    const top = { x: x + width / 2, y: y };
    const right = { x: x + width, y: y + height / 2 };
    const bottom = { x: x + width / 2, y: y + height };
    const left = { x: x, y: y + height / 2 };

    // Sand gradient - tan/beige colors matching LightSand texture
    const gradient = ctx.createLinearGradient(left.x, top.y, right.x, bottom.y);
    gradient.addColorStop(0, '#e8d9b8');    // Light sand (top-left, lit by sun)
    gradient.addColorStop(0.3, '#d4c4a0');  // Medium sand
    gradient.addColorStop(0.7, '#c4b490');  // Darker sand
    gradient.addColorStop(1, '#b4a480');    // Deep sand (bottom-right, shadow)

    // Draw the sand diamond
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(top.x, top.y);
    ctx.lineTo(right.x, right.y);
    ctx.lineTo(bottom.x, bottom.y);
    ctx.lineTo(left.x, left.y);
    ctx.closePath();
    ctx.fill();

    // Subtle border for definition
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Light highlight on top-left edge
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(top.x, top.y);
    ctx.lineTo(left.x, left.y);
    ctx.stroke();

    // Subtle shadow on bottom-right edge
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(right.x, right.y);
    ctx.lineTo(bottom.x, bottom.y);
    ctx.stroke();
}

// ============================================
// GROUND RENDERING SYSTEM - 3D-STYLE
// ============================================

/**
 * 3D-style ground with perspective grid (2D canvas implementation)
 */
// Ground rendering removed - only show created maps
function drawGround() {
    // No default ground rendering - maps provide their own
}

function drawGrid() {
    // No grid rendering
}

function drawHexagonShape(ctx, centerX, centerY, size) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const x = centerX + size * Math.cos(angle);
        const y = centerY + size * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.stroke();
}

function drawArenaFence() {
    // Fence removed - no boundary rendering
}

// Wall hit animations
let wallHitAnimations = [];

function drawWalls() {
    const time = Date.now() * 0.001;
    const hexSize = 60;  // Bigger hexagons to match ground grid (was 40)

    gameState.walls.forEach((wall, index) => {
        ctx.save();

        const centerX = wall.x;
        const centerY = wall.y;
        const hexagonSize = wall.radius || hexSize;

        // Check for hit animation
        const hitAnim = wallHitAnimations.find(a => a.wallId === wall.id);
        const hitPulse = hitAnim ? 1 + (hitAnim.intensity * 0.3) : 1;

        // Draw shadow hexagon
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = centerX + 4 + hexagonSize * Math.cos(angle);
            const y = centerY + 4 + hexagonSize * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Dynamic gradient with animated pulse
        const pulse = (Math.sin(time * 1.5 + index * 0.3) * 0.1 + 0.9) * hitPulse;
        const baseColor = gameState.wallColor || '#FF6B6B';

        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 107, b: 107 };
        };
        const rgb = hexToRgb(baseColor);

        const wallGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, hexagonSize * hitPulse);
        wallGradient.addColorStop(0, `rgba(${rgb.r}, ${Math.floor(rgb.g * 1.2)}, ${Math.floor(rgb.b * 1.2)}, ${pulse})`);
        wallGradient.addColorStop(0.3, `rgba(${Math.floor(rgb.r * 0.85)}, ${Math.floor(rgb.g * 0.85)}, ${Math.floor(rgb.b * 0.85)}, ${pulse})`);
        wallGradient.addColorStop(0.6, `rgba(${Math.floor(rgb.r * 0.7)}, ${Math.floor(rgb.g * 0.7)}, ${Math.floor(rgb.b * 0.7)}, ${pulse})`);
        wallGradient.addColorStop(1, `rgba(${Math.floor(rgb.r * 0.4)}, ${Math.floor(rgb.g * 0.4)}, ${Math.floor(rgb.b * 0.4)}, ${pulse})`);

        ctx.fillStyle = wallGradient;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = centerX + hexagonSize * hitPulse * Math.cos(angle);
            const y = centerY + hexagonSize * hitPulse * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing border
        const glowIntensity = hitAnim ? 25 + hitAnim.intensity * 10 : 15 + Math.sin(time * 2 + index) * 5;
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 3;
        ctx.shadowColor = baseColor;
        ctx.shadowBlur = glowIntensity;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = centerX + hexagonSize * hitPulse * Math.cos(angle);
            const y = centerY + hexagonSize * hitPulse * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = `rgba(${Math.min(255, rgb.r + 100)}, ${Math.min(255, rgb.g + 100)}, ${Math.min(255, rgb.b + 100)}, 0.8)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = centerX + (hexagonSize - 2) * Math.cos(angle);
            const y = centerY + (hexagonSize - 2) * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]);


        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = centerX + (hexagonSize - 1) * Math.cos(angle);
            const y = centerY + (hexagonSize - 1) * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.restore();
    });

    // Update wall hit animations
    wallHitAnimations = wallHitAnimations.filter(anim => {
        anim.intensity -= 0.05;
        return anim.intensity > 0;
    });
}

function drawShapes() {
    gameState.shapes.forEach((shape, index) => {
        ctx.save();

        // Add knockback visual effect - slight shake when being knocked back
        let shakeX = 0, shakeY = 0;
        if (shape.knockbackVX || shape.knockbackVY) {
            const intensity = Math.sqrt((shape.knockbackVX || 0) ** 2 + (shape.knockbackVY || 0) ** 2);
            if (intensity > 1) {
                shakeX = (Math.random() - 0.5) * Math.min(intensity * 0.3, 3);
                shakeY = (Math.random() - 0.5) * Math.min(intensity * 0.3, 3);
            }
        }

        ctx.translate(shape.x + shakeX, shape.y + shakeY);

        // Multi-layer shadow for depth
        ctx.save();
        for (let shadowLayer = 0; shadowLayer < 3; shadowLayer++) {
            const shadowOffset = (shadowLayer + 1) * 3;
            const shadowAlpha = 0.5 - shadowLayer * 0.15;

            ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
            ctx.translate(shadowOffset, shadowOffset);
            drawShapeGeometry(ctx, shape.type, shape.size);
            ctx.translate(-shadowOffset, -shadowOffset);
        }
        ctx.restore();

        // Static 3D gradient with fixed light source
        const lightX = -shape.size * 0.3;
        const lightY = -shape.size * 0.3;

        const gradient = ctx.createRadialGradient(
            lightX, lightY, 0,
            0, 0, shape.size / 2
        );

        gradient.addColorStop(0, lightenColor(shape.color, 90));
        gradient.addColorStop(0.2, lightenColor(shape.color, 60));
        gradient.addColorStop(0.4, lightenColor(shape.color, 30));
        gradient.addColorStop(0.7, shape.color);
        gradient.addColorStop(0.9, darkenColor(shape.color, 40));
        gradient.addColorStop(1, darkenColor(shape.color, 70));

        ctx.fillStyle = gradient;

        // Draw shape with 3D effect based on type
        if (shape.type === 'CIRCLE') {
            draw3DCircle(ctx, shape.size, true);
        } else if (shape.type === 'TRIANGLE') {
            draw3DTriangle(ctx, shape.size, true);
        } else if (shape.type === 'STAR') {
            draw3DStar(ctx, shape.size, true);
        } else if (shape.type === 'DIAMOND') {
            draw3DDiamond(ctx, shape.size, true);
        } else if (shape.type === 'PLUS') {
            draw3DPlus(ctx, shape.size, true);
        } else if (shape.type === 'PENTAGON') {
            draw3DPentagon(ctx, shape.size, true);
        }

        // Static border outline
        ctx.shadowBlur = 0;
        ctx.strokeStyle = lightenColor(shape.color, 70);
        ctx.lineWidth = 2;
        drawShapeGeometry(ctx, shape.type, shape.size, true);

        ctx.restore();

        // Enhanced health bar for damaged shapes
        if (shape.health < shape.maxHealth) {
            drawEnhancedHealthBar(shape.x, shape.y - shape.size / 2 - 25, shape.size + 8, shape.health, shape.maxHealth);
        }
    });
}

function drawPlayers() {
    // Player rendering now handled by RenderSystem
    if (renderSystem) {
        renderSystem.drawPlayers();
    }
}

// Draw shape geometry based on type
function drawShapeGeometry(ctx, type, size, strokeOnly = false) {
    if (type === 'CIRCLE') {
        const radius = size / 2;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    } else if (type === 'TRIANGLE') {
        const height = size / 2;
        const base = size / 2;
        ctx.beginPath();
        ctx.moveTo(0, -height);
        ctx.lineTo(-base, height);
        ctx.lineTo(base, height);
        ctx.closePath();
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    } else if (type === 'STAR') {
        const spikes = 5;
        const outerRadius = size / 2;
        const innerRadius = outerRadius * 0.4;
        ctx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
            const angle = (i * Math.PI) / spikes;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    } else if (type === 'DIAMOND') {
        const radius = size / 2;
        ctx.beginPath();
        ctx.moveTo(0, -radius);          // Top
        ctx.lineTo(radius * 0.6, 0);     // Right
        ctx.lineTo(0, radius);           // Bottom
        ctx.lineTo(-radius * 0.6, 0);    // Left
        ctx.closePath();
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    } else if (type === 'PLUS') {
        const radius = size / 2;
        const thickness = radius * 0.3;
        ctx.beginPath();
        // Vertical bar
        ctx.rect(-thickness / 2, -radius, thickness, size);
        // Horizontal bar
        ctx.rect(-radius, -thickness / 2, size, thickness);
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    } else if (type === 'PENTAGON') {
        const radius = size / 2;
        const numSides = 5;
        ctx.beginPath();
        for (let i = 0; i < numSides; i++) {
            const angle = (Math.PI * 2 * i) / numSides - Math.PI / 2; // Adjust angle for top point
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        if (strokeOnly) {
            ctx.stroke();
        } else {
            ctx.fill();
        }
    }
}

// Enhanced 3D circle with depth rings
function draw3DCircle(ctx, size, isMainLayer) {
    const radius = size / 2;

    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    if (isMainLayer) {
        ctx.stroke();

        // Add concentric rings for depth
        for (let i = 1; i <= 3; i++) {
            const ringRadius = radius * (0.8 - i * 0.15);
            const ringAlpha = 0.6 - i * 0.15;

            ctx.strokeStyle = `rgba(255, 255, 255, ${ringAlpha})`;
            ctx.lineWidth = 1.5 - i * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Central highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(-radius * 0.2, -radius * 0.2, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Enhanced 3D triangle with beveled edges
function draw3DTriangle(ctx, size, isMainLayer) {
    const height = size / 2;
    const base = size / 2;

    ctx.beginPath();
    ctx.moveTo(0, -height);
    ctx.lineTo(-base, height);
    ctx.lineTo(base, height);
    ctx.closePath();
    ctx.fill();

    if (isMainLayer) {
        ctx.stroke();

        // Add beveled edges
        const bevelSize = size * 0.15;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1.5;

        // Inner triangle
        ctx.beginPath();
        ctx.moveTo(0, -height * 0.6);
        ctx.lineTo(-base * 0.6, height * 0.3);
        ctx.lineTo(base * 0.6, height * 0.3);
        ctx.closePath();
        ctx.stroke();

        // Highlight edges
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-base * 0.2, -height * 0.3);
        ctx.lineTo(-base * 0.6, height * 0.3);
        ctx.stroke();

        // Central bright spot
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(-size * 0.1, -size * 0.1, size * 0.08, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Static 3D star with dimensional spikes
function draw3DStar(ctx, size, isMainLayer) {
    const spikes = 5;
    const outerRadius = size / 2;
    const innerRadius = outerRadius * 0.4;

    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const angle = (i * Math.PI) / spikes;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;

        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fill();

    if (isMainLayer) {
        ctx.stroke();

        // Add static dimensional spike highlights
        for (let i = 0; i < spikes; i++) {
            const angle = (i * 2 * Math.PI) / spikes;
            const tipX = Math.cos(angle) * outerRadius * 0.8;
            const tipY = Math.sin(angle) * outerRadius * 0.8;

            // Static spike highlight
            const highlightGradient = ctx.createRadialGradient(
                tipX, tipY, 0,
                tipX, tipY, outerRadius * 0.3
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(tipX, tipY, outerRadius * 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Static bright core
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(0, 0, innerRadius * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Static energy rings for depth
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        for (let ring = 0; ring < 2; ring++) {
            const ringRadius = innerRadius * (0.8 + ring * 0.3);

            ctx.beginPath();
            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// Static 3D diamond with crystalline facets
function draw3DDiamond(ctx, size, isMainLayer) {
    const radius = size / 2;

    ctx.beginPath();
    ctx.moveTo(0, -radius);          // Top
    ctx.lineTo(radius * 0.7, 0);     // Right
    ctx.lineTo(0, radius);           // Bottom
    ctx.lineTo(-radius * 0.7, 0);    // Left
    ctx.closePath();
    ctx.fill();

    if (isMainLayer) {
        ctx.stroke();

        // Create static crystalline facet effect
        const facets = [
            // Top facets (brightest)
            { points: [[0, -radius], [radius * 0.35, -radius * 0.5], [0, 0]], alpha: 0.8 },
            { points: [[0, -radius], [-radius * 0.35, -radius * 0.5], [0, 0]], alpha: 0.6 },
            // Right facets
            { points: [[radius * 0.7, 0], [radius * 0.35, -radius * 0.5], [0, 0]], alpha: 0.5 },
            { points: [[radius * 0.7, 0], [radius * 0.35, radius * 0.5], [0, 0]], alpha: 0.3 },
            // Bottom facets (darkest)
            { points: [[0, radius], [radius * 0.35, radius * 0.5], [0, 0]], alpha: 0.2 },
            { points: [[0, radius], [-radius * 0.35, radius * 0.5], [0, 0]], alpha: 0.1 },
            // Left facets
            { points: [[-radius * 0.7, 0], [-radius * 0.35, -radius * 0.5], [0, 0]], alpha: 0.7 },
            { points: [[-radius * 0.7, 0], [-radius * 0.35, radius * 0.5], [0, 0]], alpha: 0.3 }
        ];

        facets.forEach((facet) => {
            ctx.fillStyle = `rgba(255, 255, 255, ${facet.alpha})`;

            ctx.beginPath();
            ctx.moveTo(facet.points[0][0], facet.points[0][1]);
            ctx.lineTo(facet.points[1][0], facet.points[1][1]);
            ctx.lineTo(facet.points[2][0], facet.points[2][1]);
            ctx.closePath();
            ctx.fill();
        });

        // Static brilliant center sparkle
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.arc(0, 0, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Static sparkle rays in cross pattern
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const rayAngle = (i * Math.PI) / 2;
            const rayLength = radius * 0.4;

            ctx.save();
            ctx.rotate(rayAngle);
            ctx.beginPath();
            ctx.moveTo(0, -radius * 0.1);
            ctx.lineTo(0, -rayLength);
            ctx.stroke();
            ctx.restore();
        }

        // Static prismatic edge highlights
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-radius * 0.2, -radius * 0.7);
        ctx.lineTo(radius * 0.2, -radius * 0.3);
        ctx.stroke();

        // Additional edge highlight on the right
        ctx.beginPath();
        ctx.moveTo(radius * 0.5, -radius * 0.2);
        ctx.lineTo(radius * 0.3, radius * 0.3);
        ctx.stroke();
    }
}

// Simple green plus shape for health items
function draw3DPlus(ctx, size, isMainLayer) {
    const radius = size / 2;
    const thickness = radius * 0.3;

    // Draw the plus shape base
    ctx.beginPath();
    // Vertical bar
    ctx.rect(-thickness / 2, -radius, thickness, size);
    // Horizontal bar
    ctx.rect(-radius, -thickness / 2, size, thickness);
    ctx.fill();

    if (isMainLayer) {
        // Simple white border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// New function for drawing a 3D Pentagon
function draw3DPentagon(ctx, size, isMainLayer) {
    const radius = size / 2;
    const numSides = 5;

    ctx.beginPath();
    for (let i = 0; i < numSides; i++) {
        const angle = (Math.PI * 2 * i) / numSides - Math.PI / 2; // Adjust angle for top point
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.fill();

    if (isMainLayer) {
        ctx.stroke();

        // Add a subtle glow effect
        ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
        ctx.shadowBlur = 10;

        // Add some internal shading for a 3D feel
        const shadeColor = 'rgba(255, 255, 255, 0.3)';
        const shadeSize = radius * 0.3;
        const shadeX = radius * 0.3;
        const shadeY = radius * 0.2;

        // Side shading
        ctx.save();
        ctx.fillStyle = shadeColor;
        ctx.beginPath();
        ctx.moveTo(0, -radius);
        ctx.lineTo(shadeX, -radius * 0.5);
        ctx.lineTo(shadeX, -radius * 0.5 + shadeSize);
        ctx.lineTo(0, -radius + shadeSize);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Bottom shading
        ctx.save();
        ctx.fillStyle = shadeColor;
        ctx.beginPath();
        ctx.moveTo(radius * 0.6, radius * 0.8);
        ctx.lineTo(radius * 0.3, radius);
        ctx.lineTo(radius * 0.3 + shadeSize, radius * 0.9);
        ctx.lineTo(radius * 0.6 + shadeSize, radius * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Central highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(0, 0, radius * 0.2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawStar(ctx, x, y, radius) {
    const spikes = 5;
    const outerRadius = radius;
    const innerRadius = radius * 0.5;

    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const angle = (i * Math.PI) / spikes;
        const r = i % 2 === 0 ? outerRadius : innerRadius;
        const px = x + Math.cos(angle) * r;
        const py = y + Math.sin(angle) * r;

        if (i === 0) {
            ctx.moveTo(px, py);
        } else {
            ctx.lineTo(px, py);
        }
    }
    ctx.closePath();
}

function drawDiamond(ctx, x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);      // Top point
    ctx.lineTo(x + size * 0.7, y); // Right point
    ctx.lineTo(x, y + size);      // Bottom point
    ctx.lineTo(x - size * 0.7, y); // Left point
    ctx.closePath();
}

function drawEnhancedHealthBar(x, y, width, health, maxHealth) {
    const barWidth = width;
    const barHeight = 6;
    const healthPercent = health / maxHealth;

    ctx.save();

    // Background shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(x - barWidth / 2, y, barWidth, barHeight);

    // Background
    ctx.fillStyle = 'rgba(120, 0, 0, 0.8)';
    ctx.fillRect(x - barWidth / 2, y + 1, barWidth, barHeight - 2);

    // Health gradient
    const healthGradient = ctx.createLinearGradient(x - barWidth / 2, 0, x + barWidth / 2, 0);
    if (healthPercent > 0.6) {
        healthGradient.addColorStop(0, '#4CAF50');
        healthGradient.addColorStop(1, '#66BB6A');
    } else if (healthPercent > 0.3) {
        healthGradient.addColorStop(0, '#FF9800');
        healthGradient.addColorStop(1, '#FFB74D');
    } else {
        healthGradient.addColorStop(0, '#F44336');
        healthGradient.addColorStop(1, '#EF5350');
    }

    ctx.fillStyle = healthGradient;
    ctx.fillRect(x - barWidth / 2, y + 1, barWidth * healthPercent, barHeight - 2);

    // Border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x - barWidth / 2, y, barWidth, barHeight);

    ctx.restore();
}

// New function for drawing a dual health bar (blue shield + green health)
function drawDualHealthBar(x, y, width, health, maxHealth, shield, maxShield) {
    const barWidth = width;
    const barHeight = 8;
    const shieldPercent = shield / maxShield;
    const healthPercent = health / maxHealth;

    ctx.save();

    // Background shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(x - barWidth / 2, y, barWidth, barHeight);

    // Background
    ctx.fillStyle = 'rgba(60, 60, 60, 0.8)';
    ctx.fillRect(x - barWidth / 2, y + 1, barWidth, barHeight - 2);

    // Shield bar (blue) - top half
    if (shield > 0) {
        const shieldGradient = ctx.createLinearGradient(x - barWidth / 2, 0, x + barWidth / 2, 0);
        shieldGradient.addColorStop(0, '#2196F3');  // Blue
        shieldGradient.addColorStop(1, '#42A5F5');  // Lighter blue

        ctx.fillStyle = shieldGradient;
        ctx.fillRect(x - barWidth / 2, y + 1, barWidth * shieldPercent, (barHeight - 2) / 2);
    }

    // Health bar (green) - bottom half
    if (health > 0) {
        const healthGradient = ctx.createLinearGradient(x - barWidth / 2, 0, x + barWidth / 2, 0);
        healthGradient.addColorStop(0, '#4CAF50');  // Green
        healthGradient.addColorStop(1, '#66BB6A');  // Lighter green

        ctx.fillStyle = healthGradient;
        ctx.fillRect(x - barWidth / 2, y + 1 + (barHeight - 2) / 2, barWidth * healthPercent, (barHeight - 2) / 2);
    }

    // Border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x - barWidth / 2, y, barWidth, barHeight);

    // Divider line between shield and health
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(x - barWidth / 2, y + barHeight / 2);
    ctx.lineTo(x + barWidth / 2, y + barHeight / 2);
    ctx.stroke();

    ctx.restore();
}

function drawMinimap() {
    // Map is centered at (0,0) and extends from -gameWidth/2 to +gameWidth/2
    const mapSize = Math.max(gameState.gameWidth, gameState.gameHeight);
    const minimapSize = 150;
    const scale = minimapSize / mapSize;
    const halfMinimap = minimapSize / 2;

    // Clear minimap with LightSand color (matches ground edges)
    minimapCtx.fillStyle = '#d4c4a8';
    minimapCtx.fillRect(0, 0, minimapSize, minimapSize);

    // Draw circular map boundary
    minimapCtx.save();
    minimapCtx.beginPath();
    minimapCtx.arc(halfMinimap, halfMinimap, halfMinimap - 2, 0, Math.PI * 2);
    minimapCtx.clip();

    // Fill entire clipped area with LightSand color first
    minimapCtx.fillStyle = '#d4c4a8';
    minimapCtx.fillRect(0, 0, minimapSize, minimapSize);
    
    // Fill inner area with GreenGrass color (matches center ground)
    minimapCtx.fillStyle = '#5a8f3a';
    minimapCtx.beginPath();
    minimapCtx.arc(halfMinimap, halfMinimap, (halfMinimap - 2) * 0.85, 0, Math.PI * 2);
    minimapCtx.fill();

    // Draw walls (offset by half map size since map is centered at 0,0)
    minimapCtx.fillStyle = '#ff4444';
    gameState.walls.forEach(wall => {
        const minimapX = (wall.x + mapSize / 2) * scale;
        const minimapY = (wall.y + mapSize / 2) * scale;
        minimapCtx.fillRect(
            minimapX,
            minimapY,
            wall.width * scale,
            wall.height * scale
        );
    });

    // Draw power-ups
    minimapCtx.fillStyle = '#FFD700';
    powerUps.forEach(p => {
        const minimapX = (p.x + mapSize / 2) * scale;
        const minimapY = (p.y + mapSize / 2) * scale;
        minimapCtx.beginPath();
        minimapCtx.arc(minimapX, minimapY, 2, 0, Math.PI * 2);
        minimapCtx.fill();
    });

    // Draw other players
    Object.values(gameState.players).forEach(p => {
        if (p.id !== gameState.playerId) {
            const minimapX = (p.x + mapSize / 2) * scale;
            const minimapY = (p.y + mapSize / 2) * scale;
            minimapCtx.fillStyle = '#ff6666';
            minimapCtx.beginPath();
            minimapCtx.arc(minimapX, minimapY, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }
    });

    // Draw viewport rectangle (what's currently visible on screen)
    if (gameState.playerId && gameState.players[gameState.playerId]) {
        const player = gameState.players[gameState.playerId];
        const zoom = gameState.camera.zoom || 1;
        
        // Calculate viewport dimensions in world coordinates
        const viewWidth = canvas.width / zoom;
        const viewHeight = canvas.height / zoom;
        
        // Viewport is centered on player
        const viewLeft = player.x - viewWidth / 2;
        const viewTop = player.y - viewHeight / 2;
        
        // Convert to minimap coordinates (offset by half map size)
        const minimapViewX = (viewLeft + mapSize / 2) * scale;
        const minimapViewY = (viewTop + mapSize / 2) * scale;
        const minimapViewWidth = viewWidth * scale;
        const minimapViewHeight = viewHeight * scale;
        
        // Draw viewport rectangle
        minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        minimapCtx.lineWidth = 1.5;
        minimapCtx.strokeRect(minimapViewX, minimapViewY, minimapViewWidth, minimapViewHeight);
    }

    // Draw player location with direction arrow
    if (gameState.playerId && gameState.players[gameState.playerId]) {
        const player = gameState.players[gameState.playerId];
        const playerX = (player.x + mapSize / 2) * scale;
        const playerY = (player.y + mapSize / 2) * scale;
        const angle = (player.smoothGunAngle || player.angle) + Math.PI / 2;

        minimapCtx.save();
        minimapCtx.translate(playerX, playerY);
        minimapCtx.rotate(angle);

        // Pulsing glow
        minimapCtx.shadowColor = '#00f7ff';
        minimapCtx.shadowBlur = 5 + Math.sin(Date.now() * 0.005) * 3;

        minimapCtx.fillStyle = '#00f7ff';
        minimapCtx.strokeStyle = '#ffffff';
        minimapCtx.lineWidth = 1;

        minimapCtx.beginPath();
        minimapCtx.moveTo(0, -5);
        minimapCtx.lineTo(-3, 3);
        minimapCtx.lineTo(0, 1);
        minimapCtx.lineTo(3, 3);
        minimapCtx.closePath();
        minimapCtx.fill();
        minimapCtx.stroke();

        minimapCtx.restore();
    }

    minimapCtx.restore();

    // Draw circular border on top
    minimapCtx.strokeStyle = '#00f7ff';
    minimapCtx.lineWidth = 2;
    minimapCtx.beginPath();
    minimapCtx.arc(halfMinimap, halfMinimap, halfMinimap - 1, 0, Math.PI * 2);
    minimapCtx.stroke();
}

// Draw damage numbers
function drawDamageNumbers() {
    const currentTime = Date.now();

    // Filter out expired damage numbers
    damageNumbers = damageNumbers.filter(dmg => {
        const elapsed = currentTime - dmg.startTime;
        return elapsed < dmg.duration;
    });

    // Draw each damage number
    damageNumbers.forEach(dmg => {
        const elapsed = currentTime - dmg.startTime;
        const progress = elapsed / dmg.duration;

        // Float upward and fade out
        const offsetY = -30 - (progress * 50); // Rise up 50 pixels
        const opacity = 1 - progress; // Fade out

        ctx.save();

        // Draw damage number with outline
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Black outline for visibility
        ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
        ctx.lineWidth = 4;
        ctx.strokeText(dmg.damage.toString(), dmg.x, dmg.y + offsetY);

        // Yellow fill for damage
        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
        ctx.fillText(dmg.damage.toString(), dmg.x, dmg.y + offsetY);

        ctx.restore();
    });
}

// Draw hit markers
function drawHitMarkers() {
    const currentTime = Date.now();

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    hitMarkers = hitMarkers.filter(marker => {
        const elapsed = currentTime - marker.startTime;
        if (elapsed >= marker.duration) return false;

        const progress = elapsed / marker.duration;
        const opacity = 1 - progress;
        const size = 20 + (progress * 10);

        // Draw X marker in center of screen
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = `rgba(255, 100, 100, ${opacity})`;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        ctx.beginPath();
        ctx.moveTo(centerX - size, centerY - size);
        ctx.lineTo(centerX + size, centerY + size);
        ctx.moveTo(centerX + size, centerY - size);
        ctx.lineTo(centerX - size, centerY + size);
        ctx.stroke();

        return true;
    });

    ctx.shadowBlur = 0;
    ctx.restore();
}

// Draw bullets with enhanced trail and spark effects
function drawBullets() {
    gameState.bullets.forEach(bulletData => {
        // Create Bullet instance if not already one
        let bullet = bulletData;
        if (!(bulletData instanceof Bullet)) {
            bullet = new Bullet(bulletData);
        }

        // Get bullet color from weapon system
        const bulletColor = weaponSystem ? weaponSystem.getBulletColorFromWeapon(bullet.color || 'blue') : null;

        // Render bullet using Bullet class method
        bullet.render(ctx, bulletColor);
    });
}

// Bullet color and muzzle flash functions moved to WeaponSystem

// Helper functions for color manipulation
function lightenColor(color, percent) {
    // Simple color lightening - for more complex colors, would need proper color parsing
    if (color.startsWith('hsl')) {
        return color.replace(/(\d+)%\)/, (match, p1) => `${Math.min(100, parseInt(p1) + percent)}%)`);
    }
    return color;
}

function darkenColor(color, percent) {
    // Simple color darkening - for more complex colors, would need proper color parsing
    if (color.startsWith('hsl')) {
        return color.replace(/(\d+)%\)/, (match, p1) => `${Math.max(0, parseInt(p1) - percent)}%)`);
    }
    return color;
}

// UI Updates
function updateUI() {
    updatePlayerCount();
    updatePlayerStats();
}

function updatePlayerCount() {
    const playerCount = Object.keys(gameState.players).length;
    const playerCountElement = document.getElementById('playerCountValue');
    if (playerCountElement) {
        playerCountElement.textContent = playerCount;
    }
}

function updateFortzDisplay() {
    const fortzElement = document.getElementById('fortzAmount');
    if (fortzElement) {
        fortzElement.textContent = gameState.fortzCurrency;
    }
}

// Watch rewarded ad for free Fortz
function watchAdForFortz() {
    if (window.CrazyGamesIntegration) {
        window.CrazyGamesIntegration.showRewardedAd(() => {
            // Give player 100 Fortz as reward
            const rewardAmount = 100;
            const newCurrency = (gameState.fortzCurrency || 0) + rewardAmount;
            gameStateManager.updateGameState({ fortzCurrency: newCurrency });
            updateFortzDisplay();

            // Save to server if user is logged in
            if (window.currentUser && window.currentUser.username) {
                networkSystem.sendUpdateFortzCurrency(rewardAmount);
            }

            showNotification(`+${rewardAmount} Fortz! Thanks for watching!`, '#FFD700', 32);
            console.log(`Rewarded ${rewardAmount} Fortz for watching ad`);
        });
    } else {
        showNotification('Ads not available in development mode', '#FFA500', 24);
    }
}

// Enhanced Shop Functions with Modern Square Design
function drawShop() {
    // Determine which context to use (game canvas or lobby canvas)
    let currentCtx = ctx;
    let currentCanvas = canvas;

    if (gameState.isInLobby) {
        const lobbyCanvas = getCurrentLobbyCanvas();
        if (lobbyCanvas) {
            currentCtx = lobbyCanvas.getContext('2d');
            currentCanvas = lobbyCanvas;
        }
    }

    // Save context
    currentCtx.save();
    currentCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformations for UI

    // Clear shop content area to prevent artifacts
    currentCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);

    // Full-screen shop background - completely full screen in dev mode
    const time = Date.now() * 0.001;
    const topBarHeight = 0; // Remove top bar space for full screen

    // Enhanced multi-layer gradient background with depth
    const bgGradient = currentCtx.createRadialGradient(
        currentCanvas.width / 2, currentCanvas.height / 2, 0,
        currentCanvas.width / 2, currentCanvas.height / 2, Math.max(currentCanvas.width, currentCanvas.height)
    );
    bgGradient.addColorStop(0, 'rgba(30, 35, 60, 0.98)');
    bgGradient.addColorStop(0.3, 'rgba(20, 25, 45, 0.98)');
    bgGradient.addColorStop(0.7, 'rgba(15, 15, 30, 0.98)');
    bgGradient.addColorStop(1, 'rgba(5, 5, 15, 0.98)');
    currentCtx.fillStyle = bgGradient;
    currentCtx.fillRect(0, 0, currentCanvas.width, currentCanvas.height);

    // Add subtle animated overlay patterns
    drawShopOverlayPatterns(time, currentCtx, currentCanvas);

    // Enhanced tech grid pattern for the shop area
    drawEnhancedTechGrid(time, currentCtx, currentCanvas, 0);

    // Full-screen shop panel dimensions
    const panelX = 0;
    const panelY = 0;
    const panelWidth = currentCanvas.width;
    const panelHeight = currentCanvas.height;

    // Add enhanced ambient lighting effects with particles
    drawEnhancedAmbientEffects(time, currentCtx, currentCanvas);

    // Top bar with currency and leave icon - enhanced styling
    const topBarGradient = currentCtx.createLinearGradient(0, 0, 0, 80);
    topBarGradient.addColorStop(0, 'rgba(0, 15, 25, 0.9)');
    topBarGradient.addColorStop(1, 'rgba(0, 5, 15, 0.7)');
    currentCtx.fillStyle = topBarGradient;
    currentCtx.fillRect(0, 0, currentCanvas.width, 80);

    // Enhanced currency display in upper right
    const creditPulse = 1 + Math.sin(time * 3) * 0.03;
    const creditGlow = 0.8 + Math.sin(time * 4) * 0.2;

    // Currency background panel
    const currencyPanelWidth = 250;
    const currencyPanelHeight = 50;
    const currencyPanelX = currentCanvas.width - currencyPanelWidth - 20;
    const currencyPanelY = 15;

    // Panel gradient background
    const panelGradient = currentCtx.createLinearGradient(
        currencyPanelX, currencyPanelY,
        currencyPanelX + currencyPanelWidth, currencyPanelY + currencyPanelHeight
    );
    panelGradient.addColorStop(0, 'rgba(255, 215, 0, 0.2)');
    panelGradient.addColorStop(0.5, 'rgba(255, 185, 0, 0.15)');
    panelGradient.addColorStop(1, 'rgba(200, 150, 0, 0.1)');

    currentCtx.fillStyle = panelGradient;
    currentCtx.fillRect(currencyPanelX, currencyPanelY, currencyPanelWidth, currencyPanelHeight);

    // Panel border with glow
    currentCtx.strokeStyle = `rgba(255, 215, 0, ${creditGlow})`;
    currentCtx.lineWidth = 2;
    currentCtx.shadowBlur = 8;
    currentCtx.shadowColor = '#FFD700';
    currentCtx.strokeRect(currencyPanelX, currencyPanelY, currencyPanelWidth, currencyPanelHeight);
    currentCtx.shadowBlur = 0;

    // Currency icon - Fortz coin image
    // Load Fortz coin image if not already loaded
    if (!window.fortzCoinImg) {
        window.fortzCoinImg = imageLoader.loadFortzCoinImage();
    }
    
    // Draw Fortz coin icon
    const coinIconSize = 32;
    const coinIconX = currencyPanelX + 12;
    const coinIconY = currencyPanelY + (currencyPanelHeight - coinIconSize) / 2;
    
    if (window.fortzCoinImg && window.fortzCoinImg.complete && window.fortzCoinImg.naturalWidth > 0) {
        currentCtx.shadowBlur = 8;
        currentCtx.shadowColor = '#FFD700';
        currentCtx.drawImage(window.fortzCoinImg, coinIconX, coinIconY, coinIconSize, coinIconSize);
        currentCtx.shadowBlur = 0;
    } else {
        // Fallback to text icon
        currentCtx.fillStyle = `rgba(255, 215, 0, ${creditGlow})`;
        currentCtx.font = 'bold 20px "Courier New", monospace';
        currentCtx.textAlign = 'left';
        currentCtx.textBaseline = 'middle';
        currentCtx.shadowBlur = 6;
        currentCtx.shadowColor = '#FFD700';
        currentCtx.fillText('ðŸ’°', currencyPanelX + 15, currencyPanelY + 32);
    }

    // Currency text with enhanced styling
    currentCtx.save();
    currentCtx.scale(creditPulse, creditPulse);
    currentCtx.fillStyle = `rgba(255, 255, 255, ${creditGlow})`;
    currentCtx.font = 'bold 18px "Courier New", monospace';
    currentCtx.textAlign = 'right';
    currentCtx.shadowBlur = 6;
    currentCtx.shadowColor = '#FFD700';
    const creditText = `${gameState.fortzCurrency.toLocaleString()} FORTZ`;
    const textX = (currencyPanelX + currencyPanelWidth - 15) / creditPulse;
    const textY = (currencyPanelY + 32) / creditPulse;
    currentCtx.fillText(creditText, textX, textY);
    currentCtx.restore();
    currentCtx.shadowBlur = 0;

    // Leave icon on the left side of the top bar - show when any feature is open
    const showLeaveIcon = true; // Always show in shop view
    if (showLeaveIcon) {
        const leaveIconSize = 30;
        const leaveIconX = 40;
        const leaveIconY = (topBarHeight - leaveIconSize) / 2;

        // Add a click area for the leave icon
        if (!window.shopClickAreas) window.shopClickAreas = {};
        window.shopClickAreas['leave_icon'] = {
            x: leaveIconX - 5, y: leaveIconY - 5, width: leaveIconSize + 10, height: leaveIconSize + 10,
            action: gameState.isInLobby ? 'close_shop' : 'leave_lobby'
        };
    }

    // Close button in top-right corner for ANY open feature (not just inside showLeaveIcon block)
    const closeButtonSize = 50;
    const closeButtonX = currentCanvas.width - closeButtonSize - 30;
    const closeButtonY = 120; // Same Y position as shop

    const isMouseOverCloseBtn = gameState.mouse &&
        gameState.mouse.x >= closeButtonX && gameState.mouse.x <= closeButtonX + closeButtonSize &&
        gameState.mouse.y >= closeButtonY && gameState.mouse.y <= closeButtonY + closeButtonSize;

    const closeBtnHoverScale = isMouseOverCloseBtn ? 1.1 : 1.0;
    const closeBtnOpacity = isMouseOverCloseBtn ? 1.0 : 0.8;
    const closeBtnGlow = isMouseOverCloseBtn ? 15 : 8;

    currentCtx.save();
    currentCtx.translate(closeButtonX + closeButtonSize / 2, closeButtonY + closeButtonSize / 2);
    currentCtx.scale(closeBtnHoverScale, closeBtnHoverScale);
    currentCtx.translate(-closeButtonSize / 2, -closeButtonSize / 2);

    // Close button gradient background
    const closeBtnGradient = currentCtx.createRadialGradient(
        closeButtonSize / 2, closeButtonSize / 2, 0,
        closeButtonSize / 2, closeButtonSize / 2, closeButtonSize / 2
    );
    closeBtnGradient.addColorStop(0, `rgba(255, 120, 120, ${closeBtnOpacity})`);
    closeBtnGradient.addColorStop(0.7, `rgba(255, 80, 80, ${closeBtnOpacity * 0.8})`);
    closeBtnGradient.addColorStop(1, `rgba(200, 50, 50, ${closeBtnOpacity * 0.6})`);

    currentCtx.fillStyle = closeBtnGradient;
    currentCtx.fillRect(0, 0, closeButtonSize, closeButtonSize);

    // Close button border with glow
    currentCtx.strokeStyle = `rgba(255, 100, 100, ${closeBtnOpacity})`;
    currentCtx.lineWidth = 2;
    currentCtx.shadowBlur = closeBtnGlow;
    currentCtx.shadowColor = '#ff6464';
    currentCtx.strokeRect(0, 0, closeButtonSize, closeButtonSize);
    currentCtx.shadowBlur = 0;

    // Enhanced close button X with better styling
    currentCtx.strokeStyle = `rgba(255, 255, 255, ${closeBtnOpacity})`;
    currentCtx.lineWidth = isMouseOverCloseBtn ? 4 : 3;
    currentCtx.lineCap = 'round';
    currentCtx.shadowBlur = 3;
    currentCtx.shadowColor = '#ffffff';
    currentCtx.beginPath();
    currentCtx.moveTo(15, 15);
    currentCtx.lineTo(35, 35);
    currentCtx.moveTo(35, 15);
    currentCtx.lineTo(15, 35);
    currentCtx.stroke();
    currentCtx.shadowBlur = 0;

    currentCtx.restore();

    // Store close button click area
    if (!window.shopClickAreas) window.shopClickAreas = {};
    window.shopClickAreas.closeButton = {
        x: closeButtonX,
        y: closeButtonY,
        width: closeButtonSize,
        height: closeButtonSize,
        action: 'close'
    };

    // Close instruction removed - no longer needed
    currentCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    currentCtx.font = 'bold 14px "Courier New", monospace';
    currentCtx.textAlign = 'right';
    const closeText = '';
    currentCtx.fillText(closeText, currentCanvas.width - 40, topBarHeight + 25);

    // Initialize scroll offsets if not exists
    if (typeof window.shopScrollOffsetX === 'undefined') {
        window.shopScrollOffsetX = 0;
    }
    if (typeof window.shopScrollOffsetY === 'undefined') {
        window.shopScrollOffsetY = 0;
    }
    if (typeof window.shopTargetScrollOffsetY === 'undefined') {
        window.shopTargetScrollOffsetY = window.shopScrollOffsetY;
    }

    //// Apply smooth vertical scrolling animation (same smoothing as horizontal)
    const verticalSmoothingFactor = 0.15;
    const verticalScrollDiff = window.shopTargetScrollOffsetY - window.shopScrollOffsetY;
    if (Math.abs(verticalScrollDiff) > 1) {
        window.shopScrollOffsetY += verticalScrollDiff * verticalSmoothingFactor;
    } else {
        window.shopScrollOffsetY = window.shopTargetScrollOffsetY;
    }

    // Draw all items in order: blue to red, bodies then weapons for each color
    const startX = 40 - window.shopScrollOffsetX;
    const startY = 120 - window.shopScrollOffsetY; // Move content down to account for top bar
    const itemsPerRow = 2; // Fixed to 2 boxes per row

    drawAllShopItems(startX, startY, time, currentCtx, itemsPerRow);

    currentCtx.restore();
}

// Enhanced tech grid background for modern shop styling
function drawEnhancedTechGrid(time, currentCtx, currentCanvas, topOffset = 0) {
    currentCtx.save();

    // Multi-layered animated grid lines
    const gridLayers = [
        { size: 60, opacity: 0.15, speed: 0.5, color: [0, 247, 255] },
        { size: 40, opacity: 0.1, speed: 1.0, color: [100, 200, 255] },
        { size: 20, opacity: 0.05, speed: 1.5, color: [150, 150, 255] }
    ];

    gridLayers.forEach((layer, layerIndex) => {
        const offsetX = (time * layer.speed * 20) % layer.size;
        const offsetY = (time * layer.speed * 15) % layer.size;

        currentCtx.strokeStyle = `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.opacity})`;
        currentCtx.lineWidth = layerIndex === 0 ? 1.5 : 1;

        // Vertical lines
        for (let x = -layer.size + offsetX; x < currentCanvas.width + layer.size; x += layer.size) {
            currentCtx.beginPath();
            currentCtx.moveTo(x, topOffset);
            currentCtx.lineTo(x, currentCanvas.height);
            currentCtx.stroke();
        }

        // Horizontal lines
        for (let y = -layer.size + offsetY + topOffset; y < currentCanvas.height + layer.size; y += layer.size) {
            currentCtx.beginPath();
            currentCtx.moveTo(0, y);
            currentCtx.lineTo(currentCanvas.width, y);
            currentCtx.stroke();
        }
    });

    // Enhanced animated data nodes with particle effects
    for (let i = 0; i < 25; i++) {
        const x = (currentCanvas.width * (i * 0.157 + time * 0.008)) % (currentCanvas.width + 100);
        const y = topOffset + ((currentCanvas.height - topOffset) * (i * 0.243 + time * 0.006)) % (currentCanvas.height - topOffset + 100);
        const size = 2 + Math.sin(time * 4 + i) * 0.8;
        const opacity = 0.6 + Math.sin(time * 2 + i * 1.5) * 0.4;

        // Node glow effect
        const nodeGradient = currentCtx.createRadialGradient(x, y, 0, x, y, size * 4);
        nodeGradient.addColorStop(0, `rgba(0, 247, 255, ${opacity})`);
        nodeGradient.addColorStop(0.5, `rgba(0, 247, 255, ${opacity * 0.3})`);
        nodeGradient.addColorStop(1, `rgba(0, 247, 255, 0)`);

        currentCtx.fillStyle = nodeGradient;
        currentCtx.beginPath();
        currentCtx.arc(x, y, size * 4, 0, Math.PI * 2);
        currentCtx.fill();

        // Core node
        currentCtx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
        currentCtx.beginPath();
        currentCtx.arc(x, y, size, 0, Math.PI * 2);
        currentCtx.fill();

        // Enhanced data streams with curves
        if (i % 2 === 0) {
            const streamLength = 50 + Math.sin(time + i) * 20;
            const streamAngle = time * 0.5 + i;
            const endX = x + Math.cos(streamAngle) * streamLength;
            const endY = y + Math.sin(streamAngle) * streamLength;

            currentCtx.strokeStyle = `rgba(0, 247, 255, ${opacity * 0.4})`;
            currentCtx.lineWidth = 2;
            currentCtx.shadowBlur = 5;
            currentCtx.shadowColor = '#00f7ff';
            currentCtx.beginPath();
            currentCtx.moveTo(x, y);
            currentCtx.quadraticCurveTo(
                x + Math.cos(streamAngle + 0.5) * streamLength * 0.5,
                y + Math.sin(streamAngle + 0.5) * streamLength * 0.5,
                endX, endY
            );
            currentCtx.stroke();
            currentCtx.shadowBlur = 0;
        }
    }

    currentCtx.restore();
}

// Add overlay patterns for visual depth
function drawShopOverlayPatterns(time, currentCtx, currentCanvas) {
    currentCtx.save();

    // Animated hexagonal pattern overlay - BIGGER AND BETTER!
    const hexSize = 60;  // Bigger hexagons (was 40)
    const hexSpacing = hexSize * 1.5;
    // Better colors - brighter cyan
    currentCtx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
    currentCtx.lineWidth = 2;  // Thicker lines (was 1)

    for (let x = -hexSize; x < currentCanvas.width + hexSize; x += hexSpacing) {
        for (let y = -hexSize; y < currentCanvas.height + hexSize; y += hexSpacing * 0.866) {
            const offsetX = (y / (hexSpacing * 0.866)) % 2 === 0 ? 0 : hexSpacing / 2;
            const hexX = x + offsetX + Math.sin(time * 0.5 + x * 0.01) * 3;
            const hexY = y + Math.cos(time * 0.3 + y * 0.01) * 2;

            drawHexagon(currentCtx, hexX, hexY, hexSize * 0.6);
        }
    }

    currentCtx.restore();
}

function drawHexagon(ctx, x, y, size) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hexX = x + size * Math.cos(angle);
        const hexY = y + size * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(hexX, hexY);
        } else {
            ctx.lineTo(hexX, hexY);
        }
    }
    ctx.closePath();
    ctx.stroke();
}

// Enhanced ambient lighting effects with particles
function drawEnhancedAmbientEffects(time, currentCtx, currentCanvas) {
    currentCtx.save();

    // Enhanced floating light orbs with trails
    for (let i = 0; i < 12; i++) {
        const x = (currentCanvas.width * 0.05) + (currentCanvas.width * 0.9 * (i / 11)) + Math.sin(time * 0.4 + i) * 50;
        const y = 80 + Math.cos(time * 0.25 + i * 1.5) * 80 + Math.sin(time * 0.8 + i) * 20;
        const size = 18 + Math.sin(time * 1.5 + i) * 8;
        const opacity = 0.15 + Math.sin(time * 0.7 + i) * 0.08;
        const hue = (i * 30 + time * 20) % 360;

        // Orb trail effect
        for (let trail = 0; trail < 5; trail++) {
            const trailX = x - Math.sin(time * 0.4 + i) * trail * 8;
            const trailY = y - Math.cos(time * 0.25 + i * 1.5) * trail * 6;
            const trailSize = size * (1 - trail * 0.15);
            const trailOpacity = opacity * (1 - trail * 0.2);

            const trailGradient = currentCtx.createRadialGradient(
                trailX, trailY, 0,
                trailX, trailY, trailSize * 3
            );
            trailGradient.addColorStop(0, `hsla(${hue}, 70%, 70%, ${trailOpacity})`);
            trailGradient.addColorStop(0.7, `hsla(${hue}, 60%, 50%, ${trailOpacity * 0.3})`);
            trailGradient.addColorStop(1, `hsla(${hue}, 50%, 30%, 0)`);

            currentCtx.fillStyle = trailGradient;
            currentCtx.beginPath();
            currentCtx.arc(trailX, trailY, trailSize * 3, 0, Math.PI * 2);
            currentCtx.fill();
        }
    }

    // Enhanced scan lines with varying intensities
    const scanSpeed = time * 60;
    for (let y = (scanSpeed % 12); y < currentCanvas.height; y += 12) {
        const intensity = 0.04 + Math.sin(y * 0.02 + time * 2) * 0.02;
        currentCtx.strokeStyle = `rgba(0, 247, 255, ${intensity})`;
        currentCtx.lineWidth = 1;
        currentCtx.beginPath();
        currentCtx.moveTo(0, y);
        currentCtx.lineTo(currentCanvas.width, y);        currentCtx.stroke();
    }

    // Floating particles
    for (let i = 0; i < 20; i++) {
        const particleX = (currentCanvas.width * (i * 0.123 + time * 0.01)) % (currentCanvas.width + 50);
        const particleY = (currentCanvas.height * (i * 0.456 + time * 0.008)) % (currentCanvas.height + 50);
        const particleSize = 1 + Math.sin(time * 3 + i) * 0.5;
        const particleOpacity = 0.3 + Math.sin(time * 2 + i * 2) * 0.2;

        currentCtx.fillStyle = `rgba(255, 255, 255, ${particleOpacity})`;
        currentCtx.shadowBlur = 4;
        currentCtx.shadowColor = 'rgba(255, 255, 255, 0.5)';
        currentCtx.beginPath();
        currentCtx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        currentCtx.fill();
    }

    currentCtx.shadowBlur = 0;
    currentCtx.restore();
}

function drawShopCategory(title, items, prices, x, y, type) {
    // Category title
    ctx.fillStyle = '#00f7ff';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(title, x, y);

    // Initialize owned items if not exists
    if (!gameState.ownedItems) {
        gameStateManager.updateGameState({
            ownedItems: {
                color: ['blue'],
                body: ['body_halftrack'],
                weapon: ['turret_01_mk1']
            }
        });
    }

    let displayIndex = 0;
    // Items - only show items with successfully loaded images
    items.forEach((item, index) => {
        // Check if item has valid images
        const hasValidImage = type === 'color' ?
            (tankImages[item] && Object.keys(tankImages[item]).length > 0) :
            type === 'body' ?
                (tankImages[gameState.selectedTank.color]?.[item] && tankImages[gameState.selectedTank.color][item] !== null) :
                (weaponImages[gameState.selectedTank.color]?.[item] && weaponImages[gameState.selectedTank.color][item] !== null);

        if (!hasValidImage) return; // Skip items without valid images

        const itemY = y + 30 + (displayIndex * 60);
        const price = prices[item];
        const isSelected = gameState.selectedTank[type] === item;
        const canAfford = gameState.fortzCurrency >= price;
        const isOwned = price === 0 || gameState.ownedItems[type]?.includes(item);

        // Item background
        ctx.fillStyle = isSelected ? 'rgba(0, 247, 255, 0.3)' : 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(x, itemY - 20, 200, 50);

        // Item border
        ctx.strokeStyle = isSelected ? '#00f7ff' : '#666';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, itemY - 20, 200, 50);

        // Item name
        ctx.fillStyle = isOwned ? '#ffffff' : (canAfford ? '#cccccc' : '#666666');
        ctx.font = '14px Arial';
        ctx.fillText(item.replace('_', ' ').replace('turret', 'T').replace('mk', 'MK'), x + 10, itemY - 2);

        // Price/Status
        if (isOwned) {
            ctx.fillStyle = '#00ff00';
            ctx.fillText(isSelected ? 'EQUIPPED' : 'OWNED', x + 10, itemY + 15);
        } else {
            ctx.fillStyle = canAfford ? '#FFD700' : '#ff6666';
            ctx.fillText(`${price} F`, x + 10, itemY + 15);
        }

        // Store click area for this item
        if (!window.shopClickAreas) window.shopClickAreas = {};
        window.shopClickAreas[`${type}_${displayIndex}`] = {
            x: x, y: itemY - 20, width: 200, height: 50,
            type: type, item: item, price: price, isOwned: isOwned, canAfford: canAfford
        };

        displayIndex++;
    });
}

// Helper function to get color-based styling
function getColorStyle(itemColor) {
    switch (itemColor) {
        case 'blue':
            return {
                r: 30, g: 144, b: 255,
                textColor: '#1E90FF'
            }; // Dodger blue
        case 'camo':
            return {
                r: 34, g: 139, b: 34,
                textColor: '#32CD32'
            }; // Forest green
        case 'desert':
            return {
                r: 255, g: 215, b: 0,
                textColor: '#FFD700'
            }; // Gold
        case 'purple':
            return {
                r: 147, g: 0, b: 211,
                textColor: '#9400D3'
            }; // Dark violet
        case 'red':
            return {
                r: 220, g: 20, b: 60,
                textColor: '#DC143C'
            }; // Crimson
        default:
            return {
                r: 100, g: 100, b: 100,
                textColor: '#888888'
            }; // Gray fallback
    }
}

// Helper function to get consistent viewport width
function getViewportWidth() {
    const currentCanvas = gameState.isInLobby ?
        (getCurrentLobbyCanvas() || canvas) : canvas;
    return currentCanvas.width - 80;
}

// Create HTML scroll buttons for each shop row
function createRowScrollButtons(color, rowY, squareSize, itemCount, canvasWidth) {
    // Only create buttons if shop is open
    if (!gameState.showShop) return;

    // Remove existing buttons for this color
    const existingLeftBtn = document.getElementById(`leftBtn_${color}`);
    const existingRightBtn = document.getElementById(`rightBtn_${color}`);
    if (existingLeftBtn) existingLeftBtn.remove();
    if (existingRightBtn) existingRightBtn.remove();

    // Calculate if scrolling is possible
    const totalRowWidth = itemCount * (squareSize + SHOP_CONFIG.GRID_SPACING);
    const viewportWidth = canvasWidth - 160;

    // Initialize scroll offsets if they don't exist
    if (!window.shopRowScrollOffsets) window.shopRowScrollOffsets = {};
    if (!window.shopTargetScrollOffsets) window.shopTargetScrollOffsets = {};
    if (typeof window.shopRowScrollOffsets[color] === 'undefined') {
        window.shopRowScrollOffsets[color] = 0;
    }
    if (typeof window.shopTargetScrollOffsets[color] === 'undefined') {
        window.shopTargetScrollOffsets[color] = window.shopRowScrollOffsets[color];
    }

    const currentOffset = window.shopTargetScrollOffsets[color];
    const targetOffset = window.shopTargetScrollOffsets[color];
    const maxScroll = Math.max(0, totalRowWidth - viewportWidth);
    const canScrollLeft = targetOffset > 5;
    const canScrollRight = targetOffset < (maxScroll - 5) && totalRowWidth > viewportWidth;

    console.log(`Button state for ${color}: offset=${targetOffset}, max=${maxScroll}, canLeft=${canScrollLeft}, canScrollRight=${canScrollRight}`);

    // Get the correct canvas container
    const canvas = gameState.isInLobby ?
        getCurrentLobbyCanvas() :
        document.getElementById('gameCanvas');
    if (!canvas) return;

    // Create button container if it doesn't exist
    let buttonContainer = document.getElementById('shopScrollButtons');
    if (!buttonContainer) {
        buttonContainer = document.createElement('div');
        buttonContainer.id = 'shopScrollButtons';
        buttonContainer.style.position = 'absolute';
        buttonContainer.style.top = '0';
        buttonContainer.style.left = '0';
        buttonContainer.style.pointerEvents = 'none';
        buttonContainer.style.zIndex = '1000';
        canvas.parentElement.appendChild(buttonContainer);
    }

    const arrowSize = 60;
    const arrowY = rowY + squareSize / 2 - arrowSize / 2;

    // Left scroll button
    const leftBtn = document.createElement('button');
    leftBtn.id = `leftBtn_${color}`;
    leftBtn.innerHTML = 'â—„';
    leftBtn.style.position = 'absolute';
    leftBtn.style.left = '15px';
    leftBtn.style.top = `${arrowY}px`;
    leftBtn.style.width = `${arrowSize}px`;
    leftBtn.style.height = `${arrowSize}px`;
    leftBtn.style.borderRadius = '50%';
    leftBtn.style.border = '4px solid #FFD700';
    leftBtn.style.background = canScrollLeft ?
        'radial-gradient(circle, #FFD700 0%, #FF8C00 100%)' :
        'radial-gradient(circle, #666 0%, #444 100%)';
    leftBtn.style.color = canScrollLeft ? '#000' : '#888';
    leftBtn.style.fontSize = '24px';
    leftBtn.style.fontWeight = 'bold';
    leftBtn.style.cursor = canScrollLeft ? 'pointer' : 'not-allowed';
    leftBtn.style.pointerEvents = 'auto';
    leftBtn.style.opacity = canScrollLeft ? '1' : '0.3';
    leftBtn.style.zIndex = '1001';
    leftBtn.disabled = !canScrollLeft;

    // Right scroll button
    const rightBtn = document.createElement('button');
    rightBtn.id = `rightBtn_${color}`;
    rightBtn.innerHTML = 'â–º';
    rightBtn.style.position = 'absolute';
    rightBtn.style.left = `${canvasWidth - arrowSize - 15}px`;
    rightBtn.style.top = `${arrowY}px`;
    rightBtn.style.width = `${arrowSize}px`;
    rightBtn.style.height = `${arrowSize}px`;
    rightBtn.style.borderRadius = '50%';
    rightBtn.style.border = '4px solid #FFD700';
    rightBtn.style.background = canScrollRight ?
        'radial-gradient(circle, #FFD700 0%, #FF8C00 100%)' :
        'radial-gradient(circle, #666 0%, #444 100%)';
    rightBtn.style.color = canScrollRight ? '#000' : '#888';
    rightBtn.style.fontSize = '24px';
    rightBtn.style.fontWeight = 'bold';
    rightBtn.style.cursor = canScrollRight ? 'pointer' : 'not-allowed';
    rightBtn.style.pointerEvents = 'auto';
    rightBtn.style.opacity = canScrollRight ? '1' : '0.3';
    rightBtn.style.zIndex = '1001';
    rightBtn.disabled = !canScrollRight;

    // Add click handlers
    leftBtn.addEventListener('click', () => {
        if (canScrollLeft) {
            scrollShopRow(color, 'left');
        }
    });

    rightBtn.addEventListener('click', () => {
        if (canScrollRight) {
            scrollShopRow(color, 'right');
        }
    });

    // Add buttons to container
    buttonContainer.appendChild(leftBtn);
    buttonContainer.appendChild(rightBtn);
}

// Function to handle shop row scrolling
function scrollShopRow(color, direction) {
    // Initialize scroll offsets if needed
    if (!window.shopRowScrollOffsets) {
        window.shopRowScrollOffsets = {};
    }
    if (!window.shopTargetScrollOffsets) {
        window.shopTargetScrollOffsets = {};
    }

    if (typeof window.shopRowScrollOffsets[color] === 'undefined') {
        window.shopRowScrollOffsets[color] = 0;
    }
    if (typeof window.shopTargetScrollOffsets[color] === 'undefined') {
        window.shopTargetScrollOffsets[color] = window.shopRowScrollOffsets[color];
    }

    const rowArea = window.shopRowAreas[color];
    if (!rowArea) {
        console.warn(`No row area found for color: ${color}`);
        return;
    }

    // Calculate viewport and scroll amounts
    const canvas = gameState.isInLobby ?
        getCurrentLobbyCanvas() :
        document.getElementById('gameCanvas');

    if (!canvas) return;

    const viewportWidth = canvas.width - 160; // Account for arrow button space
    const itemWidth = (SHOP_CONFIG.SQUARE_SIZE + SHOP_CONFIG.GRID_SPACING); // Use consistent item width

    // LEFT button should scroll LEFT (decrease offset to move content RIGHT)
    // RIGHT button should scroll RIGHT (increase offset to move content LEFT)
    const scrollAmount = direction === 'right' ? itemWidth * 2 : -itemWidth * 2;

    // Update target scroll position
    const currentOffset = window.shopTargetScrollOffsets[color] || 0;
    window.shopTargetScrollOffsets[color] = currentOffset + scrollAmount;

    // Calculate max scroll bounds more accurately
    const totalRowWidth = rowArea.itemCount * itemWidth;
    const maxScrollX = Math.max(0, totalRowWidth - viewportWidth + 40);

    // Clamp scroll position
    window.shopTargetScrollOffsets[color] = Math.max(0, Math.min(maxScrollX, window.shopTargetScrollOffsets[color]));

    console.log(`Scrolling ${color} row ${direction}: offset ${currentOffset} -> ${window.shopTargetScrollOffsets[color]} (max: ${maxScrollX})`);
}

// Draw all shop items grouped by color in horizontal rows with independent scrolling
function drawAllShopItems(x, y, time, currentCtx, itemsPerRow = 8) {
    // Initialize owned items if not exists
    if (!gameState.ownedItems) {
        gameStateManager.updateGameState({
            ownedItems: {
                color: ['blue'],
                body: ['body_halftrack'],
                weapon: ['turret_01_mk1']
            }
        });
    }

    // Initialize smooth scroll system for Netflix-style browsing
    if (!window.shopRowScrollOffsets) {
        window.shopRowScrollOffsets = {};
    }
    if (!window.shopTargetScrollOffsets) {
        window.shopTargetScrollOffsets = {};
    }
    if (!window.shopScrollVelocity) {
        window.shopScrollVelocity = {};
    }

    // Use module-scope constants for consistent sizing
    const squareSize = SHOP_CONFIG.SQUARE_SIZE;
    const gridSpacing = SHOP_CONFIG.GRID_SPACING;
    const previewSize = SHOP_CONFIG.PREVIEW_SIZE;

    let globalDisplayIndex = 0;
    let currentRowY = y;

    // Order: blue, camo, desert, purple, red
    const colorOrder = ['blue', 'camo', 'desert', 'purple', 'red'];
    const colorNames = {
        'blue': 'BLUE',
        'camo': 'CAMO',
        'desert': 'DESERT',
        'purple': 'PURPLE',
        'red': 'RED'
    };

    // Group items by color and display each color group in its own row
    colorOrder.forEach((color, colorIndex) => {
        let colorItems = [];

        // Get color multiplier for pricing
        const colorMultiplier = TANK_CONFIG.colorMultipliers[color] || 1;

        // Collect all items for this color - show all successfully loaded images (GIF or PNG)
        TANK_CONFIG.bodies.forEach(body => {
            const img = tankImages[color]?.[body];
            const hasValidImage = img && img !== null && img.complete;
            if (hasValidImage) {
                colorItems.push({
                    type: 'body',
                    item: body,
                    price: TANK_CONFIG.prices.bodies[body] * colorMultiplier
                });
            }
        });

        TANK_CONFIG.weapons.forEach(weapon => {
            const img = weaponImages[color]?.[weapon];
            const hasValidImage = img && img !== null && img.complete;
            if (hasValidImage) {
                colorItems.push({
                    type: 'weapon',
                    item: weapon,
                    price: TANK_CONFIG.prices.weapons[weapon] * colorMultiplier
                });
            }
        });

        // Skip if no valid items for this color
        if (colorItems.length === 0) return;

        // Initialize smooth scroll variables for this row
        if (!window.shopRowScrollOffsets[color]) {
            window.shopRowScrollOffsets[color] = 0;
        }
        if (!window.shopTargetScrollOffsets[color]) {
            window.shopTargetScrollOffsets[color] = 0;
        }

        // Draw color group title centered
        const canvasWidth = currentCtx.canvas.width;
        currentCtx.save();
        currentCtx.fillStyle = getColorStyle(color).textColor;
        currentCtx.font = 'bold 32px "Courier New", monospace';
        currentCtx.textAlign = 'center';
        currentCtx.shadowBlur = 8;
        currentCtx.shadowColor = getColorStyle(color).textColor;
        currentCtx.fillText(colorNames[color], canvasWidth / 2, currentRowY - 20);
        currentCtx.shadowBlur = 0;
        currentCtx.restore();

        // Create clipping area for this row
        const rowHeight = squareSize + 80; // Height of the row including text

        currentCtx.save();
        currentCtx.beginPath();
        currentCtx.rect(0, currentRowY - 10, canvasWidth, rowHeight);
        currentCtx.clip();

        // Initialize scroll offsets for this row if not set
        if (!window.shopRowScrollOffsets[color]) {
            window.shopRowScrollOffsets[color] = 0;
        }
        if (!window.shopTargetScrollOffsets[color]) {
            window.shopTargetScrollOffsets[color] = 0;
        }

        // Get current scroll offset for this row (smoothly interpolated in renderLobbyShop)
        const currentScrollOffset = window.shopRowScrollOffsets[color];

        // Draw all items for this color in one scrollable row
        colorItems.forEach((itemData, itemIndex) => {
            // Apply the scroll offset correctly - subtract to move items left when scrolling right
            const baseItemX = x + itemIndex * (squareSize + gridSpacing);
            const itemX = baseItemX - currentScrollOffset;
            const itemY = currentRowY;

            // Only draw items that are visible in the viewport (with larger buffer for smooth scrolling)
            if (itemX + squareSize > -200 && itemX < canvasWidth + 200) {
                drawShopItemBox(itemX, itemY, squareSize, gridSpacing, colorItems.length, itemIndex,
                    itemData.type, itemData.item, color, itemData.price,
                    previewSize, time, currentCtx, globalDisplayIndex, color);
                globalDisplayIndex++;
            }
        });

        // Store row info for click detection
        if (!window.shopRowAreas) window.shopRowAreas = {};
        window.shopRowAreas[color] = {
            y: currentRowY - 10,
            height: rowHeight,
            itemCount: colorItems.length,
            itemWidth: SHOP_CONFIG.SQUARE_SIZE + SHOP_CONFIG.GRID_SPACING
        };

        currentCtx.restore();

        // Create HTML scroll buttons OUTSIDE the clipping area so they're always visible
        createRowScrollButtons(color, currentRowY, squareSize, colorItems.length, canvasWidth);

        // Move to next row with extra spacing between color groups
        currentRowY += squareSize + 120; // Extra spacing between color groups
    });
}

// Draw individual shop item box
function drawShopItemBox(x, y, squareSize, gridSpacing, itemsPerRow, displayIndex, type, item, color, price, previewSize, time, currentCtx, globalIndex = null, rowColor = null) {
    // Use provided x, y coordinates directly for new layout
    const itemX = x;
    const itemY = y;

    // Only mark as selected if this exact item is currently equipped (matching type, item, and color)
    const isSelected = (type === 'body' && gameState.selectedTank.body === item && gameState.selectedTank.color === color) ||
        (type === 'weapon' && gameState.selectedTank.weapon === item && gameState.selectedTank.color === color);
    const canAfford = gameState.fortzCurrency >= price;
    // Check if item is owned - for bodies/weapons, also check if the color is owned
    let isOwned = false;
    if (type === 'body' || type === 'weapon') {
        // Item is owned if both the item and color are owned
        isOwned = (price === 0 || gameState.ownedItems[type]?.includes(item)) &&
            (color === 'blue' || gameState.ownedItems.color?.includes(color));
    } else {
        // For colors, just check if color is owned
        isOwned = price === 0 || gameState.ownedItems.color?.includes(item);
    }

    // Calculate power level for the item
    let powerLevel = 1;
    if (type === 'weapon') {
        // Extract power level from weapon name - start at 5
        if (item.includes('mk1')) powerLevel = 5;
        else if (item.includes('mk2')) powerLevel = 6;
        else if (item.includes('mk3')) powerLevel = 7;
        else if (item.includes('mk4')) powerLevel = 8;
        else if (item.includes('turret_02_mk1')) powerLevel = 9;
        else if (item.includes('turret_02_mk2')) powerLevel = 10;
        else if (item.includes('turret_02_mk3')) powerLevel = 11;
        else if (item.includes('turret_02_mk4')) powerLevel = 12;
    } else if (type === 'body') {
        // Body power levels - start at 3
        if (item === 'body_halftrack') powerLevel = 3; // Halftrack starts at 3
        else if (item === 'body_tracks') powerLevel = 4; // Tracks starts at 4
    }

    // Enhanced modern square design with advanced animations
    currentCtx.save();

    // Enhanced animation effects with smooth easing
    const animPhase = time * 1.5 + displayIndex * 0.8;
    const baseHover = isSelected ? 1.0 : 0.4 + Math.sin(animPhase) * 0.2;
    const pulseEffect = isSelected ? 1.06 + Math.sin(time * 5) * 0.03 : 1.0 + Math.sin(time * 2.5 + displayIndex) * 0.012;
    const glowIntensity = isSelected ? 0.9 + Math.sin(time * 4) * 0.3 : baseHover * 0.6;
    const floatOffset = isSelected ? Math.sin(time * 3) * 2 : Math.sin(time * 1.5 + displayIndex) * 1;

    currentCtx.translate(itemX + squareSize / 2, itemY + squareSize / 2 + floatOffset);
    currentCtx.scale(pulseEffect, pulseEffect);
    currentCtx.translate(-squareSize / 2, -squareSize / 2);

    // Enhanced multi-layer drop shadow for depth
    if (isSelected) {
        // Multiple shadow layers for selected items
        for (let layer = 0; layer < 3; layer++) {
            const shadowOffset = 4 + layer * 2;
            const shadowAlpha = 0.3 - layer * 0.08;
            currentCtx.shadowColor = 'rgba(0, 0, 0, ${shadowAlpha})';
            currentCtx.shadowBlur = 20 - layer * 5;
            currentCtx.shadowOffsetX = shadowOffset;
            currentCtx.shadowOffsetY = shadowOffset;
            currentCtx.fillStyle = 'rgba(0, 0, 0, 0)';
            currentCtx.fillRect(-1, -1, squareSize + 2, squareSize + 2);
        }
    } else {
        currentCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        currentCtx.shadowBlur = canAfford ? 12 : 6;
        currentCtx.shadowOffsetX = 3;
        currentCtx.shadowOffsetY = 3;
    }



    // Use the tank color for ALL items (bodies and weapons inherit tank color)
    const boxColor = color;
    const colorStyle = getColorStyle(boxColor);

    // Enhanced gradient backgrounds with modern effects
    if (isSelected) {
        // Selected item - premium gradient with animated glow
        const selectedGradient = currentCtx.createRadialGradient(
            squareSize / 2, squareSize / 2, 0,
            squareSize / 2, squareSize / 2, squareSize * 0.9
        );
        const glowPulse = 0.8 + Math.sin(time * 6) * 0.2;
        selectedGradient.addColorStop(0, `rgba(${Math.min(255, colorStyle.r + 80)}, ${Math.min(255, colorStyle.g + 80)}, ${Math.min(255, colorStyle.b + 80)}, ${0.95 * glowIntensity})`);
        selectedGradient.addColorStop(0.4, `rgba(${Math.min(255, colorStyle.r + 40)}, ${Math.min(255, colorStyle.g + 40)}, ${Math.min(255, colorStyle.b + 40)}, ${0.8 * glowIntensity})`);
        selectedGradient.addColorStop(0.7, `rgba(${colorStyle.r}, ${colorStyle.g}, ${colorStyle.b}, ${0.6 * glowIntensity})`);
        selectedGradient.addColorStop(1, `rgba(${Math.max(0, colorStyle.r - 40)}, ${Math.max(0, colorStyle.g - 40)}, ${Math.max(0, colorStyle.b - 40)}, ${0.4 * glowIntensity})`);

        currentCtx.fillStyle = selectedGradient;
        currentCtx.fillRect(-3, -3, squareSize + 6, squareSize + 6);

        // Enhanced outer glow with animation
        currentCtx.shadowColor = `rgba(${colorStyle.r}, ${colorStyle.g}, ${colorStyle.b}, ${glowPulse})`;
        currentCtx.shadowBlur = 25 + Math.sin(time * 4) * 5;
        currentCtx.fillRect(-1, -1, squareSize + 2, squareSize + 2);
        currentCtx.shadowBlur = 0;

    } else if (canAfford && isOwned) {
        // Owned item - gradient with subtle glow
        const ownedGradient = currentCtx.createLinearGradient(0, 0, squareSize, squareSize);
        ownedGradient.addColorStop(0, `rgba(${colorStyle.r}, ${colorStyle.g}, ${colorStyle.b}, ${0.6 * glowIntensity})`);
        ownedGradient.addColorStop(1, `rgba(${Math.max(0, colorStyle.r - 40)}, ${Math.max(0, colorStyle.g - 40)}, ${Math.max(0, colorStyle.b - 40)}, ${0.4 * glowIntensity})`);

        currentCtx.fillStyle = ownedGradient;
        currentCtx.fillRect(0, 0, squareSize, squareSize);

    } else if (canAfford) {
        // Affordable item - dimmed gradient
        const affordableGradient = currentCtx.createLinearGradient(0, 0, squareSize, squareSize);
        affordableGradient.addColorStop(0, `rgba(${colorStyle.r}, ${colorStyle.g}, ${colorStyle.b}, ${0.4 * glowIntensity})`);
        affordableGradient.addColorStop(1, `rgba(${Math.max(0, colorStyle.r - 60)}, ${Math.max(0, colorStyle.g - 60)}, ${Math.max(0, colorStyle.b - 60)}, ${0.2 * glowIntensity})`);

        currentCtx.fillStyle = affordableGradient;
        currentCtx.fillRect(0, 0, squareSize, squareSize);

    } else {
        // Unaffordable item - very dim with desaturated colors
        const lockedGradient = currentCtx.createLinearGradient(0, 0, squareSize, squareSize);
        const desatR = Math.floor(colorStyle.r * 0.5 + 60);
        const desatG = Math.floor(colorStyle.g * 0.5 + 60);
        const desatB = Math.floor(colorStyle.b * 0.5 + 60);

        lockedGradient.addColorStop(0, `rgba(${desatR}, ${desatG}, ${desatB}, ${0.3 * glowIntensity})`);
        lockedGradient.addColorStop(1, `rgba(${Math.max(0, desatR - 40)}, ${Math.max(0, desatG - 40)}, ${Math.max(0, desatB - 40)}, ${0.15 * glowIntensity})`);

        currentCtx.fillStyle = lockedGradient;
        currentCtx.fillRect(0, 0, squareSize, squareSize);
    }

    // Reset shadow for subsequent elements
    currentCtx.shadowColor = 'transparent';
    currentCtx.shadowBlur = 0;
    currentCtx.shadowOffsetX = 0;
    currentCtx.shadowOffsetY = 0;

    // Enhanced corner accents and frame effects
    if (isSelected) {
        // Simple corner brackets without white glow
        const cornerSize = 12;
        const cornerThickness = 3;
        const colorStyle = getColorStyle(boxColor);

        currentCtx.strokeStyle = colorStyle.textColor;
        currentCtx.lineWidth = cornerThickness;
        currentCtx.lineCap = 'round';

        // Top-left corner
        currentCtx.beginPath();
        currentCtx.moveTo(-3, cornerSize - 3);
        currentCtx.lineTo(-3, -3);
        currentCtx.lineTo(cornerSize - 3, -3);
        currentCtx.stroke();

        // Top-right corner
        currentCtx.beginPath();
        currentCtx.moveTo(squareSize - cornerSize + 3, -3);
        currentCtx.lineTo(squareSize + 3, -3);
        currentCtx.lineTo(squareSize + 3, cornerSize - 3);
        currentCtx.stroke();

        // Bottom-left corner
        currentCtx.beginPath();
        currentCtx.moveTo(-3, squareSize - cornerSize + 3);
        currentCtx.lineTo(-3, squareSize + 3);
        currentCtx.lineTo(cornerSize - 3, squareSize + 3);
        currentCtx.stroke();

        // Bottom-right corner
        currentCtx.beginPath();
        currentCtx.moveTo(squareSize - cornerSize + 3, squareSize + 3);
        currentCtx.lineTo(squareSize + 3, squareSize + 3);
        currentCtx.lineTo(squareSize + 3, squareSize - cornerSize + 3);
        currentCtx.stroke();
    }

    // Draw price value OR stats below the box
    currentCtx.save();

    // For BODY items, show health and armor stats instead of price
    if (type === 'body') {
        // Position on the LEFT SIDE under the box
        currentCtx.translate(20, squareSize + 25);

        // Calculate health and armor based on body type and color tier
        let baseHealth = 100;
        let baseArmor = 100;

        // Adjust base stats based on body type
        if (item === 'body_tracks') {
            baseHealth = 150;
            baseArmor = 150;
        }

        // Color tier multiplier
        const tierMultiplier = {
            'blue': 1,
            'camo': 2,
            'desert': 2.5,
            'purple': 3,
            'red': 3.5
        };

        const multiplier = tierMultiplier[color] || 1;
        const health = Math.floor(baseHealth * multiplier);
        const armor = Math.floor(baseArmor * multiplier);

        // Draw health icon (heart-like) on the left
        currentCtx.strokeStyle = '#4CAF50';
        currentCtx.fillStyle = '#4CAF50';
        currentCtx.lineWidth = 2;
        currentCtx.beginPath();
        currentCtx.arc(0, 0, 5, 0, Math.PI * 2);
        currentCtx.fill();
        currentCtx.stroke();

        // Draw health value (green) next to icon
        currentCtx.fillStyle = '#4CAF50';
        currentCtx.font = 'bold 16px "Courier New", monospace';
        currentCtx.textAlign = 'left';
        currentCtx.textBaseline = 'middle';
        currentCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        currentCtx.shadowBlur = 4;
        currentCtx.fillText(health.toString(), 10, 0);

        // Draw armor icon (shield-like) below health
        currentCtx.shadowBlur = 0;
        currentCtx.strokeStyle = '#2196F3';
        currentCtx.fillStyle = '#2196F3';
        currentCtx.beginPath();
        currentCtx.moveTo(-4, 16);
        currentCtx.lineTo(0, 24);
        currentCtx.lineTo(4, 16);
        currentCtx.lineTo(4, 20);
        currentCtx.lineTo(0, 22);
        currentCtx.lineTo(-4, 20);
        currentCtx.closePath();
        currentCtx.fill();
        currentCtx.stroke();

        // Draw armor value (blue) next to icon
        currentCtx.fillStyle = '#2196F3';
        currentCtx.shadowBlur = 4;
        currentCtx.fillText(armor.toString(), 10, 20);
        currentCtx.shadowBlur = 0;

    } else {
        // For weapons and other items, show price with Fortz coin
        currentCtx.translate(squareSize / 2, squareSize + 30);

        // Load Fortz coin image if not already loaded
        if (!window.fortzCoinImg) {
            window.fortzCoinImg = imageLoader.loadFortzCoinImage();
        }

        // Draw coin icon if loaded
        const coinSize = 24;
        if (window.fortzCoinImg && window.fortzCoinImg.complete) {
            currentCtx.drawImage(window.fortzCoinImg, -coinSize - 35, -coinSize / 2, coinSize, coinSize);
        }

        // Draw price text
        currentCtx.fillStyle = isSelected ? '#FFD700' : (isOwned ? '#4CAF50' : (canAfford ? '#FFD700' : '#666'));
        currentCtx.font = 'bold 20px "Courier New", monospace';
        currentCtx.textAlign = 'left';
        currentCtx.textBaseline = 'middle';
        currentCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        currentCtx.shadowBlur = 4;

        if (isOwned) {
            currentCtx.fillText('EQUIPPED', -30, 0);
        } else {
            currentCtx.fillText(price.toLocaleString(), -5, 0);
        }

        currentCtx.shadowBlur = 0;
    }

    currentCtx.restore();

    // Enhanced premium star rating indicator with 3D effects
    currentCtx.save();

    // Determine number of stars based on color tier
    let starCount = 1; // Default for blue
    if (color === 'camo') starCount = 2;
    else if (color === 'desert') starCount = 3;
    else if (color === 'purple') starCount = 4;
    else if (color === 'red') starCount = 5;

    // Premium star badge with enhanced dimensions
    const starSize = 12; // Larger stars
    const starSpacing = 16; // More space between stars
    const badgeWidth = Math.max(60, starCount * starSpacing + 20); // Much wider badge
    const badgeHeight = 32; // Taller badge
    const badgeX = squareSize - badgeWidth - 8;
    const badgeY = 8;
    const badgePulse = isSelected ? 1.08 + Math.sin(time * 6) * 0.04 : 1.0 + Math.sin(time * 2.5 + displayIndex) * 0.015;

    currentCtx.translate(badgeX + badgeWidth / 2, badgeY + badgeHeight / 2);
    currentCtx.scale(badgePulse, badgePulse);
    currentCtx.translate(-badgeWidth / 2, -badgeHeight / 2);

    // Multi-layer badge background with premium gradient
    const badgeGradient = currentCtx.createRadialGradient(
        badgeWidth / 2, badgeHeight / 2, 0,
        badgeWidth / 2, badgeHeight / 2, Math.max(badgeWidth, badgeHeight) / 2
    );
    badgeGradient.addColorStop(0, 'rgba(255, 248, 220, 0.95)'); // Cream center
    badgeGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.9)');   // Gold
    badgeGradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.8)');   // Orange
    badgeGradient.addColorStop(1, 'rgba(184, 134, 11, 0.7)');    // Dark gold

    // Badge shadow for depth
    currentCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    currentCtx.shadowBlur = 8;
    currentCtx.shadowOffsetX = 2;
    currentCtx.shadowOffsetY = 2;
    currentCtx.fillStyle = badgeGradient;
    currentCtx.fillRect(0, 0, badgeWidth, badgeHeight);
    currentCtx.shadowBlur = 0;
    currentCtx.shadowOffsetX = 0;
    currentCtx.shadowOffsetY = 0;

    // Premium metallic border with multiple layers
    currentCtx.strokeStyle = 'rgba(255, 215, 0, 1.0)';
    currentCtx.lineWidth = 2;
    currentCtx.strokeRect(1, 1, badgeWidth - 2, badgeHeight - 2);

    currentCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    currentCtx.lineWidth = 1;
    currentCtx.strokeRect(2, 2, badgeWidth - 4, badgeHeight - 4);

    // Inner highlight for premium look
    const innerGradient = currentCtx.createLinearGradient(0, 0, 0, badgeHeight);
    innerGradient.addColorStop(0, 'rgba(255, 235, 59, 0.3)');
    innerGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.1)');
    innerGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
    currentCtx.fillRect(3, 3, badgeWidth - 6, badgeHeight / 2);

    // Calculate star positioning for perfect centering
    const totalStarsWidth = (starCount - 1) * starSpacing + starSize * 2;
    const startX = (badgeWidth - totalStarsWidth) / 2 + starSize;

    // Draw premium stars with 3D effects
    for (let i = 0; i < starCount; i++) {
        const starX = startX + i * starSpacing;
        const starY = badgeHeight / 2;
        const starAnimOffset = time * 0.003 + i * 0.8;
        const starTwinkle = 0.9 + Math.sin(starAnimOffset) * 0.1;
        const starRotation = Math.sin(time * 0.001 + i * 1.2) * 0.1;

        currentCtx.save();
        currentCtx.translate(starX, starY);
        currentCtx.rotate(starRotation);
        currentCtx.scale(starTwinkle, starTwinkle);

        // Star shadow for 3D depth
        currentCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        currentCtx.shadowBlur = 4;
        currentCtx.shadowOffsetX = 1;
        currentCtx.shadowOffsetY = 1;

        // Draw premium 3D star with gradient
        const starGradient = currentCtx.createRadialGradient(
            -starSize * 0.3, -starSize * 0.3, 0,
            0, 0, starSize
        );
        starGradient.addColorStop(0, 'rgba(255, 248, 220, 0.95)'); // Cream center
        starGradient.addColorStop(0.4, 'rgba(255, 215, 0, 0.9)');  // Gold
        starGradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.8)');  // Orange
        starGradient.addColorStop(1, 'rgba(218, 165, 32, 0.8)');   // Dark gold

        currentCtx.fillStyle = starGradient;

        // Draw enhanced 5-pointed star
        currentCtx.beginPath();
        const spikes = 5;
        const outerRadius = starSize;
        const innerRadius = starSize * 0.45; // Better proportions

        for (let j = 0; j < spikes * 2; j++) {
            const angle = (j * Math.PI) / spikes - Math.PI / 2;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (j === 0) {
                currentCtx.moveTo(x, y);
            } else {
                currentCtx.lineTo(x, y);
            }
        }
        currentCtx.closePath();
        currentCtx.fill();

        // Premium star outline
        currentCtx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
        currentCtx.lineWidth = 1.5;
        currentCtx.stroke();

        currentCtx.restore();
    }

    // Add premium badge glow effect
    currentCtx.shadowColor = 'rgba(255, 215, 0, 0.6)';
    currentCtx.shadowBlur = isSelected ? 12 + Math.sin(time * 4) * 3 : 6;
    currentCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
    currentCtx.lineWidth = isSelected ? 2 : 1;
    currentCtx.strokeRect(0, 0, badgeWidth, badgeHeight);
    currentCtx.shadowBlur = 0;

    currentCtx.restore();

    // Draw tank preview - perfectly centered in the box
    currentCtx.save();
    // Center the tank object perfectly in the box, accounting for text space below
    const finalPreviewSize = Math.min(previewSize, squareSize * 0.7); // Larger preview size for better visibility
    const centerX = squareSize / 2;
    const centerY = squareSize / 2 - 20; // Better vertical centering with small offset for text space
    drawAnimatedTankPreview(centerX, centerY, finalPreviewSize, type, item, color, displayIndex, currentCtx);
    currentCtx.restore();

    currentCtx.restore();

    // Store click area for this item
    if (!window.shopClickAreas) window.shopClickAreas = {};
    const clickKey = `${type}_${item}_${globalIndex || displayIndex}`;
    window.shopClickAreas[clickKey] = {
        x: itemX, y: itemY, width: squareSize, height: squareSize + 50, // Adjusted height for smaller boxes
        type: type, item: item, color: color, price: price
    };
}

// Draw animated tank preview - now shows tank body only OR weapon only
function drawAnimatedTankPreview(x, y, size, type, item, colorOrIndex, indexOrCtx, currentCtx) {
    if (!imagesLoaded) return;

    // Handle different parameter combinations
    let color, index, ctx;
    if (typeof colorOrIndex === 'string') {
        // New signature: (x, y, size, type, item, color, index, currentCtx)
        color = colorOrIndex;
        index = indexOrCtx || 0;
        ctx = currentCtx || window.ctx;
    } else {
        // Old signature: (x, y, size, type, item, index, currentCtx)
        index = colorOrIndex || 0;
        ctx = indexOrCtx || window.ctx;
        color = gameState.selectedTank.color;
    }

    // Use global ctx if not provided (for backward compatibility)
    if (!ctx) ctx = window.ctx;

    // Create animation time based on index for staggered animations
    const time = Date.now() + (index * 800); // More staggered animations
    const rotationSpeed = 0.0003; // Slower, more elegant rotation
    const rotation = (time * rotationSpeed) % (Math.PI * 2);

    // Get preview tank configuration
    let previewTank = { ...gameState.selectedTank };
    if (type === 'color') {
        previewTank.color = item;
    } else if (type === 'body') {
        previewTank.body = item;
        previewTank.color = color; // Use the provided color
    } else if (type === 'weapon') {
        previewTank.weapon = item;
        previewTank.color = color; // Use the provided color
    }

    const { tankImg, weaponImg } = getCurrentTankImages(previewTank);

    ctx.save();
    ctx.translate(x, y); // Use the provided x,y as the center point

    // Add subtle pulsing effect for selected items
    const isSelected = (type === 'body' && gameState.selectedTank.body === item && gameState.selectedTank.color === color) ||
        (type === 'weapon' && gameState.selectedTank.weapon === item && gameState.selectedTank.color === color) ||
        (type === 'color' && gameState.selectedTank.color === item);
    if (isSelected) {
        const pulse = 1 + Math.sin(time * 0.002) * 0.05; // More subtle, slower pulse
        ctx.scale(pulse, pulse);
    }

    if (type === 'weapon') {
        // Show ONLY weapon for weapon category
        if (!weaponImg || !weaponImg.complete) {
            ctx.restore();
            return;
        }

        ctx.rotate(rotation);
        const weaponScale = size / Math.max(weaponImg.width, weaponImg.height) * 0.9; // Normal size for shop preview
        ctx.drawImage(
            weaponImg,
            -weaponImg.width * weaponScale / 2,
            -weaponImg.height * weaponScale / 2,
            weaponImg.width * weaponScale,
            weaponImg.height * weaponScale
        );
    } else {
        // Show ONLY tank body for color and body categories (no weapon)
        if (!tankImg || !tankImg.complete) {
            ctx.restore();
            return;
        }

        ctx.rotate(rotation);
        const tankScale = size / Math.max(tankImg.width, tankImg.height) * 0.9; // Much bigger tank bodies
        ctx.drawImage(
            tankImg,
            -tankImg.width * tankScale / 2,
            -tankImg.height * tankScale / 2,
            tankImg.width * tankScale,
            tankImg.height * tankScale
        );
    }

    ctx.restore();
}

function handleShopClick(e) {
    if (!window.shopClickAreas) return;

    // Determine which canvas we're clicking on
    let targetCanvas = canvas;
    if (gameState.isInLobby) {
        const lobbyCanvas = getCurrentLobbyCanvas();
        if (lobbyCanvas) {
            targetCanvas = lobbyCanvas;
        }
    }

    const rect = targetCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Check close button click first
    if (window.shopClickAreas.closeButton &&
        clickX >= window.shopClickAreas.closeButton.x && clickX <= window.shopClickAreas.closeButton.x + window.shopClickAreas.closeButton.width &&
        clickY >= window.shopClickAreas.closeButton.y && clickY <= window.shopClickAreas.closeButton.y + window.shopClickAreas.closeButton.height) {

        closeAllPanels();
        return;
    }

    // Check for leave icon click
    if (window.shopClickAreas['leave_icon'] &&
        clickX >= window.shopClickAreas['leave_icon'].x && clickX <= window.shopClickAreas['leave_icon'].x + window.shopClickAreas['leave_icon'].width &&
        clickY >= window.shopClickAreas['leave_icon'].y && clickY <= window.shopClickAreas['leave_icon'].y + window.shopClickAreas['leave_icon'].height) {

        if (window.shopClickAreas['leave_icon'].action === 'leave_lobby') {
            returnToLobby();
            return;
        } else if (window.shopClickAreas['leave_icon'].action === 'close_shop') {
            // Close shop and return to lobby view
            stopLobbyShopRendering();
            closeAllPanels();
            return;
        }
    }

    // Arrow clicks are now handled by HTML buttons, so we removed this section

    // Check all other click areas
    for (const [key, area] of Object.entries(window.shopClickAreas)) {
        if (key === 'leave_icon') continue; // Skip leave icon, already handled

        if (clickX >= area.x && clickX <= area.x + area.width &&
            clickY >= area.y && clickY <= area.y + area.height) {

            if (area.isOwned) {
                // Equip the item and color
                gameState.selectedTank[area.type] = area.item;
                gameState.selectedTank.color = area.color;
                console.log(`Equipped ${area.color} ${area.item}`);
            } else if (area.canAfford && gameState.fortzCurrency >= area.price) {
                // Purchase the item with proper validation
                let totalCost = area.price;

                // If we don't own this color yet, add color cost
                if (area.color !== 'blue' && !gameState.ownedItems.colors.includes(area.color)) {
                    totalCost += TANK_CONFIG.prices.colors[area.color];
                }

                if (gameState.fortzCurrency >= totalCost) {
                    gameState.fortzCurrency -= totalCost;
                    gameState.selectedTank[area.type] = area.item;
                    gameState.selectedTank.color = area.color;

                    // Mark item as owned (use correct plural keys)
                    const itemKey = area.type === 'body' ? 'bodies' : area.type === 'weapon' ? 'weapons' : 'colors';
                    if (!gameState.ownedItems[itemKey].includes(area.item)) {
                        gameState.ownedItems[itemKey].push(area.item);
                    }

                    // Mark color as owned
                    if (!gameState.ownedItems.colors.includes(area.color)) {
                        gameState.ownedItems.colors.push(area.color);
                    }

                    console.log(`Purchased and equipped ${area.color} ${area.item} for ${totalCost} Fortz`);
                    updateFortzDisplay();
                } else {
                    console.log(`Cannot afford ${area.color} ${area.item} (${totalCost} Fortz total)`);
                }
            } else {
                console.log(`Cannot afford ${area.color} ${area.item} (${area.price} Fortz)`);
            }
            break; // Exit loop after handling the click
        }
    }
}

// Render current vehicle on the hexagon preview canvas
function renderVehicleHexagon() {
    const canvas = document.getElementById('vehiclePreviewCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const vehicleType = gameState.selectedVehicleType || 'tank';
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Rotate 110 degrees to the left (counter-clockwise)
    const rotation = -110 * (Math.PI / 180);
    
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation);
    
    if (vehicleType === 'tank') {
        const selectedTank = gameState.selectedTank;
        if (selectedTank) {
            // Use GIF images from lobby cache
            const tankImg = lobbyTankImages[selectedTank.color]?.[selectedTank.body];
            const weaponImg = lobbyWeaponImages[selectedTank.color]?.[selectedTank.weapon];
            
            // Draw tank body (GIF)
            if (tankImg && tankImg.complete) {
                const scale = 0.35;
                const w = tankImg.width * scale;
                const h = tankImg.height * scale;
                ctx.drawImage(tankImg, -w / 2, -h / 2, w, h);
            }
            
            // Draw weapon on top of body (positioned at tank center)
            if (weaponImg && weaponImg.complete) {
                const scale = 0.3;
                const w = weaponImg.width * scale;
                const h = weaponImg.height * scale;
                // Weapon sits on top of tank body, slightly forward
                ctx.drawImage(weaponImg, -w / 2, -h / 2, w, h);
            }
        }
    } else if (vehicleType === 'jet') {
        const selectedJet = gameState.selectedJet || { type: 'ship1', color: 'purple' };
        const imagePath = `/assets/jet/spr_${selectedJet.type}_${selectedJet.color}.png`;
        
        const jetImg = imageLoader.jetImageCache[imagePath];
        if (jetImg && jetImg.complete) {
            const scale = 0.162;
            const w = jetImg.width * scale;
            const h = jetImg.height * scale;
            ctx.drawImage(jetImg, -w / 2, -h / 2, w, h);
        } else {
            // Load image if not cached
            imageLoader.loadJetImage(imagePath);
        }
    } else if (vehicleType === 'race') {
        const selectedRace = gameState.selectedRace || { type: 'endurance', color: 'blue' };
        const imagePath = `/assets/race/sprites/cars/${selectedRace.type}_${selectedRace.color}.png`;
        
        const raceImg = imageLoader.raceImageCache[imagePath];
        if (raceImg && raceImg.complete) {
            const scale = 0.225;
            const w = raceImg.width * scale;
            const h = raceImg.height * scale;
            ctx.drawImage(raceImg, -w / 2, -h / 2, w, h);
        } else {
            // Load image if not cached
            imageLoader.loadRaceImage(imagePath);
        }
    }
    
    ctx.restore();
}

// Start continuous rendering for vehicle hexagon (for GIF animation)
let vehicleHexagonInterval = null;
function startVehicleHexagonRendering() {
    if (vehicleHexagonInterval) return;
    vehicleHexagonInterval = setInterval(renderVehicleHexagon, 50);
}

function stopVehicleHexagonRendering() {
    if (vehicleHexagonInterval) {
        clearInterval(vehicleHexagonInterval);
        vehicleHexagonInterval = null;
    }
}

// Render vehicles on friend profile canvases
function renderFriendVehicles() {
    const canvases = document.querySelectorAll('.friend-vehicle-canvas');
    canvases.forEach(canvas => {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const vehicleType = canvas.dataset.vehicle || 'tank';
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Rotate 110 degrees to the left
        const rotation = -110 * (Math.PI / 180);
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        
        if (vehicleType === 'tank') {
            const color = canvas.dataset.color || 'blue';
            const body = canvas.dataset.body || 'body_halftrack';
            const weapon = canvas.dataset.weapon || 'turret_01_mk1';
            
            const tankImg = lobbyTankImages[color]?.[body];
            const weaponImg = lobbyWeaponImages[color]?.[weapon];
            
            if (tankImg && tankImg.complete) {
                const scale = 0.3;
                const w = tankImg.width * scale;
                const h = tankImg.height * scale;
                ctx.drawImage(tankImg, -w / 2, -h / 2, w, h);
            }
            
            if (weaponImg && weaponImg.complete) {
                const scale = 0.25;
                const w = weaponImg.width * scale;
                const h = weaponImg.height * scale;
                ctx.drawImage(weaponImg, -w / 2, -h / 2, w, h);
            }
        } else if (vehicleType === 'jet') {
            const type = canvas.dataset.type || 'ship1';
            const color = canvas.dataset.color || 'purple';
            const imagePath = `/assets/jet/spr_${type}_${color}.png`;
            
            const jetImg = imageLoader.jetImageCache[imagePath];
            if (jetImg && jetImg.complete) {
                const scale = 0.15;
                const w = jetImg.width * scale;
                const h = jetImg.height * scale;
                ctx.drawImage(jetImg, -w / 2, -h / 2, w, h);
            } else {
                imageLoader.loadJetImage(imagePath);
            }
        } else if (vehicleType === 'race') {
            const type = canvas.dataset.type || 'endurance';
            const color = canvas.dataset.color || 'blue';
            const imagePath = `/assets/race/sprites/cars/${type}_${color}.png`;
            
            const raceImg = imageLoader.raceImageCache[imagePath];
            if (raceImg && raceImg.complete) {
                const scale = 0.2;
                const w = raceImg.width * scale;
                const h = raceImg.height * scale;
                ctx.drawImage(raceImg, -w / 2, -h / 2, w, h);
            } else {
                imageLoader.loadRaceImage(imagePath);
            }
        }
        
        ctx.restore();
    });
}

// Start continuous rendering for friend vehicles
let friendVehicleInterval = null;
function startFriendVehicleRendering() {
    if (friendVehicleInterval) return;
    friendVehicleInterval = setInterval(renderFriendVehicles, 50);
}

function stopFriendVehicleRendering() {
    if (friendVehicleInterval) {
        clearInterval(friendVehicleInterval);
        friendVehicleInterval = null;
    }
}

// Update level progress image based on XP percentage
function updateLevelProgressImage(level, currentXP, xpToNext) {
    const levelProgressBg = document.getElementById('levelProgressBg');
    const userLevelEl = document.getElementById('userLevel');
    
    if (!levelProgressBg) return;
    
    // Calculate XP percentage
    const xpPercent = xpToNext > 0 ? (currentXP / xpToNext) * 100 : 0;
    
    // Select the appropriate progress image
    let progressImage = 'assets/images/ui/defaultprofile.png';
    if (xpPercent >= 90) {
        progressImage = 'assets/images/ui/complet90%lvl.png';
    } else if (xpPercent >= 60) {
        progressImage = 'assets/images/ui/Complet60%lvl.png';
    } else if (xpPercent >= 30) {
        progressImage = 'assets/images/ui/Complet30%lvlProfile.png';
    }
    
    levelProgressBg.src = progressImage;
    
    // Update level text
    if (userLevelEl) {
        userLevelEl.textContent = `LVL ${level}`;
    }
}

function updatePlayerStats(data) {
    const player = gameState.players[gameState.playerId];
    let currentScore = 0;
    let currentLevel = 1;

    // Always update from current player data first
    if (player) {
        currentScore = player.score || 0;
        currentLevel = player.level || 1;
        document.getElementById('scoreValue').textContent = currentScore.toLocaleString();
        document.getElementById('levelValue').textContent = currentLevel;
    }

    // If we have new data from server, update everything
    if (data) {
        currentScore = data.score || currentScore;
        currentLevel = data.level || currentLevel;

        // Update UI immediately
        document.getElementById('scoreValue').textContent = currentScore.toLocaleString();
        document.getElementById('levelValue').textContent = currentLevel;

        // Update the player object in game state immediately
        if (gameState.players[gameState.playerId]) {
            gameState.players[gameState.playerId].score = currentScore;
            gameState.players[gameState.playerId].level = currentLevel;
            if (data.exp !== undefined) gameState.players[gameState.playerId].exp = data.exp;
            if (data.kills) gameState.players[gameState.playerId].kills = data.kills;
        }
    }

    // Update lobby level display
    const lobbyLevelDisplay = document.getElementById('levelDisplayLobby');
    if (lobbyLevelDisplay) {
        lobbyLevelDisplay.textContent = currentLevel;
    }

    // Update level progress PNG based on XP percentage
    updateLevelProgressImage(currentLevel, data ? data.exp : 0, data ? data.expToNext : 100);

    // Update progress calculation
    const currentLevelThreshold = (currentLevel - 1) * 1000;
    const progressInCurrentLevel = currentScore - currentLevelThreshold;

    // Update level progress bar (for hidden stats compatibility)
    const progressPercentage = (progressInCurrentLevel / 1000) * 100;
    const progressBar = document.getElementById('levelProgress');
    if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, progressPercentage)) + '%';
    }

    // Update top center score progress bar
    const scoreProgressBar = document.getElementById('scoreProgress');
    const scoreProgressText = document.getElementById('scoreProgressText');
    if (scoreProgressBar && scoreProgressText) {
        scoreProgressBar.style.width = Math.min(100, Math.max(0, progressPercentage)) + '%';
        scoreProgressText.textContent = `Level ${currentLevel}`;
    }
}

function returnToLobby() {
    // Trigger CrazyGames gameplay stop event
    if (window.CrazyGamesIntegration) {
        window.CrazyGamesIntegration.gameplayStop();
    }

    // Set lobby state first to prevent reconnection attempts
    gameStateManager.updateGameState({ 
        isInLobby: true,
        isConnected: false
    });
    
    // Reset vehicle type to tank (default) when returning to lobby
    window.currentLobbyVehicleType = 'tank';
    gameStateManager.updateGameState({ selectedVehicleType: 'tank' });

    // Disconnect from current game
    networkSystem.disconnect();

    // Close lobby socket too if it exists
    if (lobbySocket) {
        lobbySocket.close();
        lobbySocket = null;
    }

    // Reset game state
    gameStateManager.updateGameState({
        playerId: null,
        players: {},
        shapes: [],
        walls: [],
        bullets: [],
        shapeSpawnTimers: {} // Clear shape respawn timers
    });

    // Show lobby and restore all UI elements
    const lobbyScreen = document.getElementById('lobbyScreen');
    if (lobbyScreen) {
        lobbyScreen.classList.remove('hidden');
        // Restore all lobby UI elements that were hidden during game
        const children = lobbyScreen.children;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.id !== 'tankLobbyBackground') {
                child.style.display = '';
            }
        }
        // Reset tank background canvas z-index
        const tankCanvas = document.getElementById('tankLobbyBackground');
        if (tankCanvas) {
            tankCanvas.style.zIndex = '1';
        }
    }
    document.getElementById('gameMapArea').classList.add('hidden');

    // Hide game canvas during lobby
    const gameCanvas = document.getElementById('gameCanvas');
    if (gameCanvas) {
        gameCanvas.style.display = 'none';
    }

    document.getElementById('ui').classList.add('hidden');
    document.getElementById('scoreProgressContainer').classList.add('hidden');
    document.getElementById('centerBottomBoxes').classList.add('hidden');
    document.getElementById('respawnScreen').classList.add('hidden');

    // Render DOM map to lobby
    if (window.DOMMapRenderer && window.DOMMapRenderer.initialized) {
        window.DOMMapRenderer.renderToLobby();
    }

    // Reset vehicle buttons to show tank as active
    updateVehicleButtons();
    
    // Initialize all canvases but only show the selected vehicle type
    const tankCanvas = document.getElementById('tankLobbyBackground');
    const jetCanvas = document.getElementById('jetLobbyBackground');
    const raceCanvas = document.getElementById('raceLobbyBackground');
    
    // Set canvas sizes
    if (tankCanvas) {
        // Full screen tank canvas for map rendering
        tankCanvas.width = window.innerWidth;
        tankCanvas.height = window.innerHeight;
    }
    if (jetCanvas) {
        jetCanvas.width = window.innerWidth;
        jetCanvas.height = window.innerHeight;
    }
    if (raceCanvas) {
        raceCanvas.width = window.innerWidth;
        raceCanvas.height = window.innerHeight;
    }
    
    // Show the correct canvas based on selected vehicle type
    const selectedVehicle = gameState.selectedVehicleType || 'tank';
    window.currentLobbyVehicleType = selectedVehicle;
    
    if (tankCanvas) tankCanvas.style.display = selectedVehicle === 'tank' ? 'block' : 'none';
    if (jetCanvas) jetCanvas.style.display = selectedVehicle === 'jet' ? 'block' : 'none';
    if (raceCanvas) raceCanvas.style.display = selectedVehicle === 'race' ? 'block' : 'none';
    
    // Only start tank background if tank is selected
    if (selectedVehicle === 'tank') {
        initializeLobbyBackground();
    }
    
    // Reset Play button to default
    const playButton = document.getElementById('joinGameBtn');
    const playButtonText = playButton?.querySelector('span:first-child');
    const playButtonSubtext = document.getElementById('playButtonMapName');
    if (playButton) {
        playButton.onclick = () => joinGame();
        if (playButtonText) playButtonText.textContent = 'PLAY';
        if (playButtonSubtext) playButtonSubtext.textContent = 'JOIN GAME';
        playButton.style.background = '';
    }

    console.log('Returned to lobby');
}

// Lobby background with live game preview
let lobbySocket = null;
let lobbyWalls = [];
let lobbyPlayers = {};
let gameModePlayers = {}; // Track player counts for each game mode
let lobbyMapData = {
    walls: [],
    shapes: [],
    players: [],
    bullets: [],
    gameWidth: 7500,
    gameHeight: 7500
};

// Ensure dimensions are exactly 7500x7500 (never changes)
Object.defineProperty(lobbyMapData, 'gameWidth', {
    value: 7500,
    writable: false,
    configurable: false
});
Object.defineProperty(lobbyMapData, 'gameHeight', {
    value: 7500,
    writable: false,
    configurable: false
});

// Helper function to get the correct lobby canvas based on vehicle type
function getCurrentLobbyCanvas() {
    const vehicleType = window.currentLobbyVehicleType || gameState.selectedVehicleType || 'tank';
    
    if (vehicleType === 'jet') {
        return document.getElementById('jetLobbyBackground');
    } else if (vehicleType === 'race') {
        return document.getElementById('raceLobbyBackground');
    } else {
        return document.getElementById('tankLobbyBackground');
    }
}

function initializeLobbyBackground() {
    const canvas = document.getElementById('tankLobbyBackground');
    if (!canvas) {
        console.warn('Tank lobby background canvas not found');
        return;
    }
    
    // If jet or race mode is active, don't override their backgrounds
    if (window.currentLobbyVehicleType === 'jet' || window.currentLobbyVehicleType === 'race') {
        console.log('Skipping tank background - vehicle mode active:', window.currentLobbyVehicleType);
        return;
    }
    
    // Clear any DOM maps when switching back to canvas mode
    if (window.DOMMapRenderer?.clearLobbyMap) {
        window.DOMMapRenderer.clearLobbyMap();
    }
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // First, render the full map background immediately
    renderLobbyBackground();

    // Connect to server to get live map data
    connectLobbyToServer();

    let time = 0;
    let cameraX = 0;
    let cameraY = 0;
    let targetCameraX = 0;
    let targetCameraY = 0;
    let lastCameraUpdate = 0;
    const CAMERA_UPDATE_INTERVAL = 5000; // 5 seconds between camera movements
    
    let lastFrameTime = performance.now();
    let frameCount = 0;

    function drawBackground(currentTime) {
        // Stop if not in lobby or if jet/race mode is active
        if (!gameState.isInLobby) return;
        if (window.currentLobbyVehicleType === 'jet' || window.currentLobbyVehicleType === 'race') {
            return; // Stop the tank background animation
        }
        
        // Limit to 30 FPS for lobby (performance optimization)
        const deltaTime = currentTime - lastFrameTime;
        if (deltaTime < 33) { // ~30 FPS
            window.tankBackgroundAnimationId = requestAnimationFrame(drawBackground);
            return;
        }
        lastFrameTime = currentTime;
        frameCount++;

        // Clear with dark background
        ctx.fillStyle = '#0a0a15';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update camera target every 5 seconds
        if (currentTime - lastCameraUpdate > CAMERA_UPDATE_INTERVAL) {
            targetCameraX = (Math.random() - 0.5) * 2000;
            targetCameraY = (Math.random() - 0.5) * 2000;
            lastCameraUpdate = currentTime;
        }

        // Smooth camera movement (very slow)
        const smoothing = 0.001; // Very slow smooth movement
        cameraX += (targetCameraX - cameraX) * smoothing;
        cameraY += (targetCameraY - cameraY) * smoothing;

        // Render created map ONLY (no water fallback)
        if (window.MapRenderer && window.MapRenderer.currentMap) {
            ctx.save();
            ctx.translate(-cameraX, -cameraY);
            
            const lobbyCamera = { x: cameraX, y: cameraY };
            window.MapRenderer.render(ctx, lobbyCamera, canvas);
            
            ctx.restore();
        }
        // No fallback - just show dark background if no map

            // Draw shapes and other elements on top (only visible ones)
            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            // Only animate shapes in viewport
            lobbyMapData.shapes.forEach((shape, index) => {
                const screenX = shape.x - cameraX;
                const screenY = shape.y - cameraY;
                
                // Skip shapes outside viewport
                if (screenX < -100 || screenX > canvas.width + 100 ||
                    screenY < -100 || screenY > canvas.height + 100) {
                    return;
                }

                const pulse = Math.sin(time * 0.0015 + index * 0.5) * 0.15 + 1;
                const rotation = time * 0.001 + index;

                ctx.save();
                ctx.translate(shape.x, shape.y);
                ctx.rotate(rotation);
                ctx.scale(pulse, pulse);

                // Glow effect
                ctx.shadowColor = shape.color;
                ctx.shadowBlur = 15 + Math.sin(time * 0.003 + index) * 5;

                ctx.fillStyle = shape.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                if (shape.type === 'CIRCLE') {
                    ctx.beginPath();
                    ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (shape.type === 'TRIANGLE') {
                    ctx.beginPath();
                    ctx.moveTo(0, -shape.size / 2);
                    ctx.lineTo(-shape.size / 2, shape.size / 2);
                    ctx.lineTo(shape.size / 2, shape.size / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (shape.type === 'STAR') {
                    drawStar(ctx, 0, 0, shape.size / 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (shape.type === 'DIAMOND') {
                    drawDiamond(ctx, 0, 0, shape.size / 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (shape.type === 'PENTAGON') {
                    // Draw pentagon with a dark blue color
                    const darkBlue = '#1E90FF'; // Dodger blue
                    ctx.fillStyle = darkBlue;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;

                    // Draw pentagon manually for lobby
                    const radius = shape.size / 2;
                    const numSides = 5;
                    ctx.beginPath();
                    for (let i = 0; i < numSides; i++) {
                        const angle = (Math.PI * 2 * i) / numSides - Math.PI / 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });

            // Draw live players (tanks) - only visible ones
            if (imagesLoaded && lobbyMapData.players && Array.isArray(lobbyMapData.players)) {
                lobbyMapData.players.forEach(player => {
                    if (!player || !player.selectedTank || typeof player.x !== 'number' || typeof player.y !== 'number') return;

                    const screenX = player.x - cameraX;
                    const screenY = player.y - cameraY;
                    
                    // Skip tanks outside viewport
                    if (screenX < -100 || screenX > canvas.width + 100 ||
                        screenY < -100 || screenY > canvas.height + 100) {
                        return;
                    }

                    ctx.save();
                    ctx.translate(player.x, player.y);

                    // Smooth rotation animation (slow)
                    const targetRotation = typeof player.rotation === 'number' ? player.rotation : 0;
                    if (!player.smoothRotation) player.smoothRotation = targetRotation;
                    player.smoothRotation += (targetRotation - player.smoothRotation) * 0.05;
                    
                    const weaponRotation = typeof player.weaponRotation === 'number' ? player.weaponRotation : 0;
                    ctx.rotate(player.smoothRotation);

                    // Get player's tank images
                    const { tankImg, weaponImg } = getCurrentTankImages(player.selectedTank);

                    // Draw tank body
                    const tankSize = 40;
                    if (tankImg && tankImg.complete) {
                        ctx.drawImage(tankImg, -tankSize / 2, -tankSize / 2, tankSize, tankSize);
                    }

                    // Draw weapon
                    if (weaponImg && weaponImg.complete) {
                        ctx.rotate(weaponRotation - player.smoothRotation);
                        ctx.drawImage(weaponImg, -tankSize / 2, -tankSize / 2, tankSize, tankSize);
                    }

                    ctx.restore();

                    // Draw player name above tank
                    if (player.name) {
                        ctx.save();
                        ctx.fillStyle = '#fff';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.strokeText(player.name, player.x, player.y - 25);
                        ctx.fillText(player.name, player.x, player.y - 25);
                        ctx.restore();
                    }
                });
            }

            // Draw live bullets
            if (lobbyMapData.bullets && Array.isArray(lobbyMapData.bullets)) {
                ctx.fillStyle = '#ff0';
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 10;
                lobbyMapData.bullets.forEach(bullet => {
                    if (!bullet) return;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            ctx.restore();

            // Add subtle overlay
            ctx.fillStyle = 'rgba(26, 42, 65, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time++;
            window.tankBackgroundAnimationId = requestAnimationFrame(drawBackground);
    }

    window.tankBackgroundAnimationId = requestAnimationFrame(drawBackground);
}

function drawLobbyGrid(ctx, cameraX, cameraY, canvasWidth, canvasHeight) {
    const hexSize = 60;  // Bigger hexagons (was 40)
    const hexWidth = hexSize * Math.sqrt(3); // Correct horizontal spacing
    const hexHeight = hexSize * 2;
    const vertSpacing = hexHeight * 0.75; // Vertical spacing for perfect fit

    const worldSize = 4500;
    const viewLeft = cameraX;
    const viewRight = cameraX + canvasWidth;
    const viewTop = cameraY;
    const viewBottom = cameraY + canvasHeight;

    // Better colors - brighter cyan with glow
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
    ctx.lineWidth = 3;  // Thicker/fatter lines (was 1.5)

    // Calculate starting points to ensure perfect grid alignment
    const startRow = Math.floor(viewTop / vertSpacing);
    const endRow = Math.ceil(viewBottom / vertSpacing);
    const startCol = Math.floor(viewLeft / hexWidth);
    const endCol = Math.ceil(viewRight / hexWidth);

    // Draw hexagons in perfect grid pattern, ONLY inside boundaries
    for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
            const y = row * vertSpacing;
            const offsetX = (row % 2 === 0) ? 0 : hexWidth / 2;
            const x = col * hexWidth + offsetX;

            // Only draw if STRICTLY within game boundaries
            if (x >= hexSize && x <= worldSize - hexSize &&
                y >= hexSize && y <= worldSize - hexSize) {
                drawHexagonShape(ctx, x, y, hexSize);
            }
        }
    }
}

function connectLobbyToServer() {
    if (lobbySocket) return;

    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    // Include selected game mode for correct map preview
    const gameMode = gameState.selectedGameMode || 'ffa';
    const wsUrl = `${protocol}//${window.location.host}/ws?lobby=true&mode=${gameMode}`;

    lobbySocket = new WebSocket(wsUrl);

    lobbySocket.onopen = () => {
        console.log('Lobby connected to server for map preview');
    };

    lobbySocket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'gameState') {
                lobbyMapData.walls = data.walls || [];
                lobbyMapData.shapes = data.shapes || [];
                // Update lobby background vars
                lobbyWalls = data.walls || [];
                lobbyPlayers = data.players || {};
                // Convert players object to array
                lobbyMapData.players = data.players ? Object.values(data.players) : [];
                // Convert bullets object to array if needed
                lobbyMapData.bullets = data.bullets ? (Array.isArray(data.bullets) ? data.bullets : Object.values(data.bullets)) : [];
                // Re-render lobby background with new data
                if (gameState.isInLobby) {
                    renderLobbyBackground();
                }
            } else if (data.type === 'shapeSpawned') {
                lobbyMapData.shapes.push(data.shape);
            } else if (data.type === 'shapeDestroyed') {
                lobbyMapData.shapes = lobbyMapData.shapes.filter(s => s.id !== data.shapeId);
            } else if (data.type === 'lobbyState') {
                lobbyMapData.walls = data.walls || [];
                lobbyMapData.shapes = data.shapes || [];
                lobbyWalls = data.walls || [];
                lobbyPlayers = data.players || {};
                // Re-render lobby background
                if (gameState.isInLobby) {
                    renderLobbyBackground();
                }
            } else if (data.type === 'playerCounts') {
                // Update player counts for each game mode
                if (data.counts) {
                    Object.keys(data.counts).forEach(mode => {
                        gameModePlayers[mode] = data.counts[mode];
                    });
                }
            }
        } catch (error) {
            console.error('Error parsing lobby message:', error);
        }
    };

    lobbySocket.onclose = () => {
        lobbySocket = null;
        // Only reconnect if we're still in lobby
        if (gameState.isInLobby) {
            setTimeout(connectLobbyToServer, 3000);
        }
    };
}

// Function to close all panels and restore lobby state
function closeAllPanels() {
    // Close all features
    gameStateManager.updateGameState({
        showShop: false,
        showLocker: false,
        showSettings: false,
        showPass: false,
        showCreateMap: false,
        showFriends: false,
        showChampions: false,
        openedFeature: null
    });

    // Show level display
    const levelDisplay = document.getElementById('levelDisplayLobby');
    if (levelDisplay) {
        levelDisplay.style.display = 'flex';
    }

    // Show game buttons
    const bottomRightContainer = document.querySelector('.bottom-right-container');
    if (bottomRightContainer) bottomRightContainer.style.display = 'flex';

    // Show party boxes
    const partySlot1 = document.getElementById('partySlot1');
    const partySlot2 = document.getElementById('partySlot2');
    const playerTankSlot = document.getElementById('playerTankSlot');
    if (partySlot1) partySlot1.style.display = 'block';
    if (partySlot2) partySlot2.style.display = 'block';
    if (playerTankSlot) playerTankSlot.style.display = 'block';

    // Show auth buttons, user info, and chat indicator
    const authButtons = document.getElementById('authButtons');
    const userInfo = document.getElementById('userInfo');
    const chatIndicator = document.querySelector('.chat-indicator');
    if (authButtons) authButtons.style.display = 'flex';
    if (userInfo) userInfo.style.display = 'flex';
    if (chatIndicator) chatIndicator.style.display = 'flex';

    // Remove shop-open class from shop button
    const shopButton = document.getElementById('shopButton');
    if (shopButton) {
        shopButton.classList.remove('shop-open');
    }

    // Hide the HTML screens
    const createMapScreen = document.getElementById('createMapScreen');
    if (createMapScreen) {
        createMapScreen.classList.add('hidden');
    }

    const shopScreen = document.getElementById('shopScreen');
    if (shopScreen) {
        shopScreen.classList.add('hidden');
    }

    const lockerScreen = document.getElementById('lockerScreen');
    if (lockerScreen) {
        lockerScreen.classList.add('hidden');
    }
    
    // Stop locker preview animation
    if (typeof stopLockerPreviewAnimation === 'function') {
        stopLockerPreviewAnimation();
    }

    const settingsScreen = document.getElementById('settingsScreen');
    if (settingsScreen) {
        settingsScreen.classList.add('hidden');
    }

    const championsScreen = document.getElementById('championsScreen');
    if (championsScreen) {
        championsScreen.classList.add('hidden');
    }

    // Stop canvas-based rendering for features
    if (typeof window.stopPassRendering === 'function') {
        window.stopPassRendering();
    }
    if (typeof window.stopFriendsRendering === 'function') {
        window.stopFriendsRendering();
    }
    if (typeof stopFriendVehicleRendering === 'function') {
        stopFriendVehicleRendering();
    }

    // Stop game state flags
    gameStateManager.updateGameState({
        showSettings: false,
        showPass: false,
        showFriends: false
    });

    // Clear click areas
    window.shopClickAreas = {};
    window.featureClickAreas = {};
    window.createMapClickAreas = {};
    window.passClickAreas = {};
}

// Champions tab switching function
window.switchChampionsTab = function(tabName) {
    // Hide all tab contents
    const tabContents = document.querySelectorAll('.champions-tab-content');
    tabContents.forEach(tab => tab.style.display = 'none');
    
    // Remove active class from all buttons
    const tabButtons = document.querySelectorAll('.champions-tab-btn');
    tabButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = btn.style.background.replace('0.3', '0.1');
    });
    
    // Show selected tab content
    const tabId = 'championsTab' + tabName.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
    const selectedTab = document.getElementById(tabId);
    if (selectedTab) {
        selectedTab.style.display = 'block';
    }
    
    // Activate the clicked button
    const buttonId = 'tab' + tabName.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
    const activeButton = document.getElementById(buttonId);
    if (activeButton) {
        activeButton.classList.add('active');
        if (tabName === 'top-players') {
            activeButton.style.background = 'linear-gradient(180deg, rgba(255,215,0,0.3) 0%, rgba(255,165,0,0.2) 100%)';
        } else if (tabName === 'top-creators') {
            activeButton.style.background = 'linear-gradient(180deg, rgba(0,247,255,0.3) 0%, rgba(0,200,255,0.2) 100%)';
        } else if (tabName === 'champions') {
            activeButton.style.background = 'linear-gradient(180deg, rgba(147,112,219,0.3) 0%, rgba(138,43,226,0.2) 100%)';
        } else if (tabName === 'award') {
            activeButton.style.background = 'linear-gradient(180deg, rgba(255,105,180,0.3) 0%, rgba(255,20,147,0.2) 100%)';
        }
    }
    
    // Load data for the selected tab
    loadChampionsData(tabName);
};

// Load champions data based on tab
window.loadChampionsData = function(tabName) {
    if (tabName === 'top-players') {
        loadTopPlayers();
    } else if (tabName === 'top-creators') {
        loadTopCreators();
    } else if (tabName === 'champions') {
        loadChampionsHall();
    } else if (tabName === 'award') {
        loadAwards();
    }
};

// Load top players leaderboard
function loadTopPlayers() {
    const container = document.getElementById('topPlayersListContent');
    if (!container) return;
    
    // Get ranking data if available
    let players = [];
    if (window.RankingSystem && typeof window.RankingSystem.getLeaderboard === 'function') {
        players = window.RankingSystem.getLeaderboard('global', 20);
    }
    
    if (players.length === 0) {
        // Show sample data
        players = [
            { name: 'ProTanker99', wins: 156, kd: 3.2, elo: 2450 },
            { name: 'DestroyerX', wins: 142, kd: 2.8, elo: 2380 },
            { name: 'TankMaster', wins: 128, kd: 2.5, elo: 2290 },
            { name: 'BattleKing', wins: 115, kd: 2.3, elo: 2180 },
            { name: 'WarriorElite', wins: 98, kd: 2.1, elo: 2050 }
        ];
    }
    
    container.innerHTML = players.map((player, index) => `
        <div style="display: flex; align-items: center; padding: 12px 15px; background: ${index % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent'}; border-radius: 6px; margin-bottom: 5px;">
            <span style="flex: 0.5; color: ${index < 3 ? '#FFD700' : '#888'}; font-weight: bold;">${index + 1}</span>
            <span style="flex: 2; color: #fff;">${player.name || player.playerId || 'Unknown'}</span>
            <span style="flex: 1; color: #4CAF50; text-align: center;">${player.wins || 0}</span>
            <span style="flex: 1; color: #FF9800; text-align: center;">${(player.kd || player.elo / 1000 || 0).toFixed(1)}</span>
            <span style="flex: 1; color: #00f7ff; text-align: right; font-weight: bold;">${player.elo || player.rating || 0}</span>
        </div>
    `).join('');
}

// Load top creators leaderboard
function loadTopCreators() {
    const container = document.getElementById('topCreatorsListContent');
    if (!container) return;
    
    // Get saved maps and count by creator
    const maps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]');
    const creatorStats = {};
    
    maps.forEach(map => {
        const creator = map.creator || 'Anonymous';
        if (!creatorStats[creator]) {
            creatorStats[creator] = { maps: 0, plays: 0, likes: 0 };
        }
        creatorStats[creator].maps++;
        creatorStats[creator].plays += map.plays || 0;
        creatorStats[creator].likes += map.likes || 0;
    });
    
    let creators = Object.entries(creatorStats).map(([name, stats]) => ({
        name, ...stats
    })).sort((a, b) => b.maps - a.maps).slice(0, 20);
    
    if (creators.length === 0) {
        creators = [
            { name: 'MapMaker Pro', maps: 25, plays: 1250, likes: 340 },
            { name: 'CreativeBuilder', maps: 18, plays: 890, likes: 220 },
            { name: 'DesignGuru', maps: 15, plays: 720, likes: 180 },
            { name: 'ArtistTank', maps: 12, plays: 540, likes: 145 },
            { name: 'WorldCreator', maps: 10, plays: 380, likes: 95 }
        ];
    }
    
    container.innerHTML = creators.map((creator, index) => `
        <div style="display: flex; align-items: center; padding: 12px 15px; background: ${index % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent'}; border-radius: 6px; margin-bottom: 5px;">
            <span style="flex: 0.5; color: ${index < 3 ? '#00f7ff' : '#888'}; font-weight: bold;">${index + 1}</span>
            <span style="flex: 2; color: #fff;">${creator.name}</span>
            <span style="flex: 1; color: #4CAF50; text-align: center;">${creator.maps}</span>
            <span style="flex: 1; color: #FF9800; text-align: center;">${creator.plays}</span>
            <span style="flex: 1; color: #FF69B4; text-align: right;">${creator.likes}</span>
        </div>
    `).join('');
}

// Load champions hall of fame
function loadChampionsHall() {
    const container = document.getElementById('championsHallContent');
    if (!container) return;
    
    // Sample champions data
    const champions = [
        { title: 'Season 1 Champion', name: 'LegendaryTank', date: 'Jan 2025', reward: 'ðŸ¥‡ Gold Trophy' },
        { title: 'Tournament Winner', name: 'ProDestroyer', date: 'Dec 2024', reward: 'ðŸ† Champion Belt' },
        { title: 'Weekly Champion', name: 'BattleMaster', date: 'Nov 2024', reward: 'â­ Star Badge' },
        { title: 'Map Contest Winner', name: 'CreativeGenius', date: 'Oct 2024', reward: 'ðŸŽ¨ Creator Crown' }
    ];
    
    container.innerHTML = champions.map(champ => `
        <div style="background: linear-gradient(135deg, rgba(147,112,219,0.2) 0%, rgba(75,0,130,0.1) 100%); border: 1px solid rgba(147,112,219,0.4); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3 style="color: #9370DB; margin: 0 0 5px 0;">${champ.title}</h3>
                    <p style="color: #fff; font-size: 1.2rem; margin: 0;">${champ.name}</p>
                    <span style="color: #888; font-size: 0.9rem;">${champ.date}</span>
                </div>
                <div style="text-align: right;">
                    <span style="font-size: 2rem;">${champ.reward.split(' ')[0]}</span>
                    <p style="color: #FFD700; margin: 5px 0 0 0;">${champ.reward.split(' ').slice(1).join(' ')}</p>
                </div>
            </div>
        </div>
    `).join('');
}

// Load awards section
function loadAwards() {
    const container = document.getElementById('awardsContent');
    if (!container) return;
    
    // Sample awards data
    const awards = [
        { icon: 'ðŸŽ¯', title: 'Sharpshooter', desc: 'Highest accuracy this month', winner: 'AimBot2000', value: '94.2%' },
        { icon: 'ðŸ’€', title: 'Eliminator', desc: 'Most kills in a single game', winner: 'DeathDealer', value: '47 kills' },
        { icon: 'ðŸ›¡ï¸', title: 'Survivor', desc: 'Longest survival time', winner: 'TankFortress', value: '45:32' },
        { icon: 'âš¡', title: 'Speed Demon', desc: 'Fastest victory', winner: 'BlitzKrieg', value: '2:15' },
        { icon: 'ðŸ¤', title: 'Team Player', desc: 'Most assists this week', winner: 'SupportKing', value: '89 assists' }
    ];
    
    container.innerHTML = awards.map(award => `
        <div style="display: flex; align-items: center; background: linear-gradient(135deg, rgba(255,105,180,0.15) 0%, rgba(255,20,147,0.05) 100%); border: 1px solid rgba(255,105,180,0.3); border-radius: 12px; padding: 15px; margin-bottom: 12px;">
            <div style="font-size: 2.5rem; margin-right: 20px;">${award.icon}</div>
            <div style="flex: 1;">
                <h3 style="color: #FF69B4; margin: 0 0 3px 0;">${award.title}</h3>
                <p style="color: #888; margin: 0; font-size: 0.9rem;">${award.desc}</p>
            </div>
            <div style="text-align: right;">
                <p style="color: #fff; font-weight: bold; margin: 0;">${award.winner}</p>
                <span style="color: #FFD700;">${award.value}</span>
            </div>
        </div>
    `).join('');
}

// Define openFeature function globally for HTML onclick handlers
window.openFeature = function openFeature(feature) {
    console.log(`Opening feature: ${feature}`);

    // Track which feature is open
    if (!gameState.openedFeature) {
        gameState.openedFeature = null;
    }

    // Hide level display when any feature is opened
    const levelDisplay = document.getElementById('levelDisplayLobby');

    if (feature === 'shop') {
        // Close all other panels first
        closeAllPanels();

        // Only allow shop to open in lobby, not during gameplay
        if (typeof gameState !== 'undefined' && gameState.isInLobby) {
            gameStateManager.updateGameState({ showShop: true });
            gameState.openedFeature = 'shop';

            const bottomRightContainer = document.querySelector('.bottom-right-container');
            if (bottomRightContainer) bottomRightContainer.style.display = 'none';

            // Hide level display
            if (levelDisplay) levelDisplay.style.display = 'none';

            // Hide party boxes
            const partySlot1 = document.getElementById('partySlot1');
            const partySlot2 = document.getElementById('partySlot2');
            const playerTankSlot = document.getElementById('playerTankSlot');
            if (partySlot1) partySlot1.style.display = 'none';
            if (partySlot2) partySlot2.style.display = 'none';
            if (playerTankSlot) playerTankSlot.style.display = 'none';

            // Hide auth buttons, user info, and chat indicator
            const authButtons = document.getElementById('authButtons');
            const userInfo = document.getElementById('userInfo');
            const chatIndicator = document.querySelector('.chat-indicator');
            if (authButtons) authButtons.style.display = 'none';
            if (userInfo) userInfo.style.display = 'none';
            if (chatIndicator) chatIndicator.style.display = 'none';

            // Add shop-open class to shop button for yellow styling
            const shopButton = document.getElementById('shopButton');
            if (shopButton) {
                shopButton.classList.add('shop-open');
            }

            // Show the HTML shop screen
            const shopScreen = document.getElementById('shopScreen');
            if (shopScreen) {
                shopScreen.classList.remove('hidden');
                loadShopItems('tanks'); // Load tanks by default
            }
        } else {
            console.log('Shop can only be opened in the lobby!');
        }
    } else if (feature === 'create-map') {
        // Close all other panels first
        closeAllPanels();

        // Create Map functionality
        gameStateManager.updateGameState({ 
            showCreateMap: true,
            openedFeature: 'create-map'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        // Show the HTML screen
        const createMapScreen = document.getElementById('createMapScreen');
        if (createMapScreen) {
            createMapScreen.classList.remove('hidden');
        }
    } else if (feature === 'locker') {
        // Close all other panels first
        closeAllPanels();

        // Locker functionality - show owned items and allow equipping
        gameStateManager.updateGameState({ 
            showLocker: true,
            openedFeature: 'locker'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        // Show the HTML locker screen
        const lockerScreen = document.getElementById('lockerScreen');
        if (lockerScreen) {
            lockerScreen.classList.remove('hidden');
            loadLockerItems('colors'); // Load colors by default
            updateLockerPreview(); // Update the current loadout preview
        }
    } else if (feature === 'settings') {
        // Close all other panels first
        closeAllPanels();


        // Settings functionality - show actual settings panel
        gameStateManager.updateGameState({ 
            showSettings: true,
            openedFeature: 'settings'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        // Show the HTML settings screen
        const settingsScreen = document.getElementById('settingsScreen');
        if (settingsScreen) {
            settingsScreen.classList.remove('hidden');

            // Initialize settings UI
            if (typeof window.initSettingsUI === 'function') {
                window.initSettingsUI();
            }
        }
    } else if (feature === 'pass') {
        // Close all other panels first
        closeAllPanels();

        // Pass functionality - show battle pass screen
        gameStateManager.updateGameState({ 
            showPass: true,
            openedFeature: 'pass'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        startPassRendering();
    } else if (feature === 'friends') {
        // Close all other panels first
        closeAllPanels();

        // Friends functionality - show friends screen
        gameStateManager.updateGameState({ 
            showFriends: true,
            openedFeature: 'friends'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        startFriendsRendering();
        startFriendVehicleRendering();
    } else if (feature === 'champions') {
        // Close all other panels first
        closeAllPanels();

        // Champions functionality - show leaderboards and hall of fame
        gameStateManager.updateGameState({ 
            showChampions: true,
            openedFeature: 'champions'
        });

        const bottomRightContainer = document.querySelector('.bottom-right-container');
        if (bottomRightContainer) bottomRightContainer.style.display = 'none';

        // Hide level display
        const levelDisplay = document.getElementById('levelDisplayLobby');
        if (levelDisplay) levelDisplay.style.display = 'none';

        // Hide party boxes
        const partySlot1 = document.getElementById('partySlot1');
        const partySlot2 = document.getElementById('partySlot2');
        const playerTankSlot = document.getElementById('playerTankSlot');
        if (partySlot1) partySlot1.style.display = 'none';
        if (partySlot2) partySlot2.style.display = 'none';
        if (playerTankSlot) playerTankSlot.style.display = 'none';

        // Hide auth buttons, user info, and chat indicator
        const authButtons = document.getElementById('authButtons');
        const userInfo = document.getElementById('userInfo');
        const chatIndicator = document.querySelector('.chat-indicator');
        if (authButtons) authButtons.style.display = 'none';
        if (userInfo) userInfo.style.display = 'none';
        if (chatIndicator) chatIndicator.style.display = 'none';

        // Show the HTML champions screen
        const championsScreen = document.getElementById('championsScreen');
        if (championsScreen) {
            championsScreen.classList.remove('hidden');
            loadChampionsData('top-players'); // Load top players by default
        }
    } else if (feature === 'armor' || feature === 'upgrades') {
        console.log(`${feature} functionality coming soon!`);
        gameState.openedFeature = feature;
    }
};

// Helper function to draw close button for all features (globally accessible)
window.drawCloseButton = function drawCloseButton(ctx, canvas) {
    const btnSize = 50;
    const btnX = canvas.width - btnSize - 30;
    const btnY = 120; // Same Y position as shop

    const isMouseOverBtn = gameState.mouse &&
        gameState.mouse.x >= btnX && gameState.mouse.x <= btnX + btnSize &&
        gameState.mouse.y >= btnY && gameState.mouse.y <= btnY + btnSize;

    const btnHoverScale = isMouseOverBtn ? 1.1 : 1.0;
    const btnOpacity = isMouseOverBtn ? 1.0 : 0.8;
    const btnGlow = isMouseOverBtn ? 15 : 8;

    ctx.save();
    ctx.translate(btnX + btnSize / 2, btnY + btnSize / 2);
    ctx.scale(btnHoverScale, btnHoverScale);
    ctx.translate(-btnSize / 2, -btnSize / 2);

    const btnGradient = ctx.createRadialGradient(
        btnSize / 2, btnSize / 2, 0,
        btnSize / 2, btnSize / 2, btnSize / 2
    );
    btnGradient.addColorStop(0, `rgba(255, 120, 120, ${btnOpacity})`);
    btnGradient.addColorStop(0.7, `rgba(255, 80, 80, ${btnOpacity * 0.8})`);
    btnGradient.addColorStop(1, `rgba(200, 50, 50, ${btnOpacity * 0.6})`);

    ctx.fillStyle = btnGradient;
    ctx.fillRect(0, 0, btnSize, btnSize);

    ctx.strokeStyle = `rgba(255, 100, 100, ${btnOpacity})`;
    ctx.lineWidth = 2;
    ctx.shadowBlur = btnGlow;
    ctx.shadowColor = '#ff6464';
    ctx.strokeRect(0, 0, btnSize, btnSize);
    ctx.shadowBlur = 0;

    ctx.strokeStyle = `rgba(255, 255, 255, ${btnOpacity})`;
    ctx.lineWidth = isMouseOverBtn ? 4 : 3;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 3;
    ctx.shadowColor = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(15, 15);
    ctx.lineTo(35, 35);
    ctx.moveTo(35, 15);
    ctx.lineTo(15, 35);
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.restore();

    // Store click area
    if (!window.featureClickAreas) window.featureClickAreas = {};
    window.featureClickAreas.closeButton = {
        x: btnX, y: btnY, width: btnSize, height: btnSize, action: 'close'
    };
}

// Game Mode Modal functionality - Only custom maps, no default modes

// Function to get player count for each game mode
function getGameModePlayerCount(modeId) {
    // Return the actual tracked player count for this mode
    return gameModePlayers[modeId] || 0;
}

// Function to get saved maps from localStorage (all vehicle types)
function getSavedMaps() {
    // Get tank maps
    const tankMaps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]')
        .map(m => ({ ...m, vehicleType: m.vehicleType || 'tank' }));
    
    // Get jet maps
    const jetMaps = JSON.parse(localStorage.getItem('thefortz.jetMaps') || '[]')
        .map(m => ({ ...m, vehicleType: 'jet' }));
    
    // Get race maps
    const raceMaps = JSON.parse(localStorage.getItem(STORAGE_KEYS.RACE_MAPS) || '[]')
        .map(m => ({ ...m, vehicleType: 'race' }));
    
    // Combine all maps
    return [...tankMaps, ...jetMaps, ...raceMaps];
}

// Function to filter and display maps based on search term
function filterGameModes(searchTerm) {
    const list = document.getElementById('gameModeList');
    if (!list) return;

    // Clear existing items
    list.innerHTML = '';

    // Get saved maps
    const maps = getSavedMaps();

    // Check if "show created maps only" is checked
    const showCreatedOnly = document.getElementById('showCreatedMapsOnly')?.checked || false;

    // Filter maps based on search term and created maps filter
    const filteredMaps = maps.filter(map => {
        // If showing created maps only, only show user-created maps
        if (showCreatedOnly && !map.isUserCreated) {
            return false;
        }

        // Apply search filter
        if (!searchTerm) return true; // Show all if search is empty

        const term = searchTerm.toLowerCase();
        return map.name.toLowerCase().includes(term);
    });

    // Display filtered maps
    filteredMaps.forEach(map => {
        const item = document.createElement('div');
        item.className = 'game-mode-item' + (gameState.selectedMap === map.id ? ' selected' : '');
        item.onclick = () => selectMap(map.id);

        // Create image/thumbnail
        const imgElement = document.createElement('img');
        imgElement.className = 'game-mode-image';
        imgElement.alt = map.name;

        if (map.thumbnail) {
            imgElement.src = map.thumbnail;
        } else {
            // Create a placeholder if no thumbnail
            imgElement.style.background = 'linear-gradient(135deg, rgba(10, 20, 40, 0.9), rgba(5, 10, 25, 0.9))';
            imgElement.style.display = 'flex';
            imgElement.style.alignItems = 'center';
            imgElement.style.justifyContent = 'center';
            imgElement.style.color = 'rgba(255, 255, 255, 0.5)';
            imgElement.alt = 'ðŸ—ºï¸';
        }

        // Create info container
        const infoDiv = document.createElement('div');
        infoDiv.className = 'game-mode-info';
        const objectCount = map.objects ? map.objects.length : 0;
        const createdDate = new Date(map.created).toLocaleDateString();
        
        // Get vehicle type badge
        const vehicleType = map.vehicleType || 'tank';
        const vehicleEmoji = vehicleType === 'tank' ? 'ðŸ›¡ï¸' : vehicleType === 'jet' ? 'âœˆï¸' : 'ðŸŽï¸';
        const vehicleBadgeColor = vehicleType === 'tank' ? '#4a9eff' : vehicleType === 'jet' ? '#9b59b6' : '#2ecc71';
        
        infoDiv.innerHTML = `
            <span class="game-mode-abbr">${map.name}</span>
            <span style="background: ${vehicleBadgeColor}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 8px;">${vehicleEmoji} ${vehicleType.toUpperCase()}</span>
            <br><span class="game-mode-count" style="font-size: 0.8rem; opacity: 0.7;">${objectCount} Objects - ${createdDate}</span>
        `;

        item.appendChild(imgElement);
        item.appendChild(infoDiv);
        list.appendChild(item);
    });

    // Show "no results" message if no matches found
    if (filteredMaps.length === 0) {
        const noResults = document.createElement('div');
        noResults.style.cssText = 'color: rgba(255, 255, 255, 0.6); font-size: 1.2rem; padding: 40px; text-align: center; width: 100%;';

        if (maps.length === 0) {
            noResults.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                    <div style="font-size: 3rem;">ðŸ—ºï¸</div>
                    <div>No maps created yet</div>
                    <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.4);">Create your first map to get started!</div>
                </div>
            `;
        } else if (showCreatedOnly) {
            noResults.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                    <div style="font-size: 3rem;">ðŸ—ºï¸</div>
                    <div>No created maps found</div>
                    <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.4);">Create your first map to get started!</div>
                </div>
            `;
        } else {
            noResults.textContent = `No maps found matching "${searchTerm}"`;
        }
        list.appendChild(noResults);
    }
}

// Function to select a map
function selectMap(mapId) {
    gameState.selectedMap = mapId;

    // Update UI to show selection
    const items = document.querySelectorAll('.game-mode-item');
    items.forEach(item => {
        item.classList.remove('selected');
    });

    const selectedItem = Array.from(items).find(item => {
        return item.onclick.toString().includes(mapId);
    });

    if (selectedItem) {
        selectedItem.classList.add('selected');
    }

    // Find the map
    const maps = getSavedMaps();
    const selectedMapData = maps.find(m => m.id === mapId);

    if (selectedMapData) {
        // Update play button text to show selected map name
        const playButtonMapName = document.getElementById('playButtonMapName');
        if (playButtonMapName) {
            playButtonMapName.textContent = selectedMapData.name.toUpperCase();
        }

        // Get the vehicle type from the map (default to 'tank' if not specified)
        const mapVehicleType = selectedMapData.vehicleType || 'tank';
        
        // Switch to the correct vehicle type if different from current
        if (mapVehicleType !== gameState.selectedVehicleType) {
            console.log(`ðŸš— Switching vehicle type to ${mapVehicleType} for map "${selectedMapData.name}"`);
            
            // Use the selectVehicleType function to switch vehicle and update lobby
            if (typeof window.selectVehicleType === 'function') {
                window.selectVehicleType(mapVehicleType);
            }
        }
        
        // Update lobby background with the selected map
        updateLobbyBackgroundWithMap(selectedMapData, mapVehicleType);

        // Dispatch map selection event for integration system
        if (typeof window.gameEvents !== 'undefined') {
            window.gameEvents.dispatch('mapSelected', {
                mapId: mapId,
                mapName: selectedMapData.name,
                mapData: selectedMapData
            });
        }

        showNotification(`Map "${selectedMapData.name}" selected!`, '#00f7ff', 24);
    }
}

// Update lobby background with a specific map
function updateLobbyBackgroundWithMap(mapData, vehicleType) {
    console.log(`ðŸ—ºï¸ Updating lobby background with map: ${mapData.name} (${vehicleType})`);
    
    // Get the correct canvas for this vehicle type
    const tankCanvas = document.getElementById('tankLobbyBackground');
    const jetCanvas = document.getElementById('jetLobbyBackground');
    const raceCanvas = document.getElementById('raceLobbyBackground');
    
    // Hide all canvases first
    if (tankCanvas) tankCanvas.style.display = 'none';
    if (jetCanvas) jetCanvas.style.display = 'none';
    if (raceCanvas) raceCanvas.style.display = 'none';
    
    // Stop any existing background animations
    if (window.tankBackgroundAnimationId) {
        cancelAnimationFrame(window.tankBackgroundAnimationId);
        window.tankBackgroundAnimationId = null;
    }
    
    // Show the correct canvas and render the map
    if (vehicleType === 'tank' && tankCanvas) {
        tankCanvas.style.display = 'block';
        
        // Load the map into MapRenderer
        if (window.MapRenderer && typeof window.MapRenderer.loadMap === 'function') {
            window.MapRenderer.loadMap(mapData, () => {
                console.log('âœ… Tank map loaded into MapRenderer:', mapData.name);
                // Re-initialize lobby background to render the new map
                if (typeof initializeLobbyBackground === 'function') {
                    initializeLobbyBackground();
                }
            });
        } else if (typeof initializeLobbyBackground === 'function') {
            initializeLobbyBackground();
        }
        
        // Also update DOM renderer if available
        if (window.DOMMapRenderer) {
            window.DOMMapRenderer.currentMap = mapData;
        }
    } else if (vehicleType === 'jet' && jetCanvas) {
        jetCanvas.style.display = 'block';
        // Render jet map on lobby background
        if (typeof startJetLobbyBackgroundWithMap === 'function') {
            startJetLobbyBackgroundWithMap(jetCanvas, mapData);
        }
    } else if (vehicleType === 'race' && raceCanvas) {
        raceCanvas.style.display = 'block';
        // Render race map on lobby background
        if (typeof startRaceLobbyBackgroundWithMap === 'function') {
            startRaceLobbyBackgroundWithMap(raceCanvas, mapData);
        }
    }
}

// Expose selectMap to window
window.selectMap = selectMap;

window.openBattleRoyal = function () {
    const modal = document.getElementById('gameModeModal');
    const searchInput = document.getElementById('gameModeSearch');

    if (!modal) return;

    // Clear search input
    if (searchInput) {
        searchInput.value = '';
    }

    // Auto-select most played map if no map is currently selected
    if (!gameState.selectedMap) {
        const maps = getSavedMaps();
        if (maps.length > 0) {
            // Get play counts and find most played map
            const playCountsStr = localStorage.getItem('thefortz.mapPlays') || '{}';
            const playCounts = JSON.parse(playCountsStr);

            let mostPlayedMap = null;
            let maxPlays = -1;

            maps.forEach(map => {
                const plays = playCounts[String(map.id)] || 0;
                if (plays > maxPlays) {
                    maxPlays = plays;
                    mostPlayedMap = map;
                }
            });

            // If no plays recorded, select the newest map
            if (!mostPlayedMap) {
                mostPlayedMap = maps.sort((a, b) => new Date(b.created) - new Date(a.created))[0];
            }

            if (mostPlayedMap) {
                selectMap(mostPlayedMap.id);
            }
        }
    }

    // Populate all game modes initially
    filterGameModes('');

    // Add search event listener
    if (searchInput) {
        // Remove old listener if exists
        const newInput = searchInput.cloneNode(true);
        searchInput.parentNode.replaceChild(newInput, searchInput);

        // Add new listener
        newInput.addEventListener('input', (e) => {
            filterGameModes(e.target.value);
        });
    }

    // Show modal
    modal.classList.remove('hidden');

    // Update button to show current selection
    const maps = getSavedMaps();
    const selectedMapData = gameState.selectedMap ? maps.find(m => m.id === gameState.selectedMap) : null;
    const mapButton = document.querySelector('.map-button');

    if (mapButton) {
        // Always show default map text, no image rendering
        mapButton.textContent = 'Map';
    }
};

window.closeGameModeModal = function () {
    const modal = document.getElementById('gameModeModal');
    if (modal) modal.classList.add('hidden');
};

// Filter functionality removed - only showing created maps now

window.scrollGameModeList = function (direction) {
    const list = document.getElementById('gameModeList');
    if (!list) return;

    const scrollAmount = 320; // Width of one game mode item (280px) + gap (30px) + extra (10px)

    if (direction === 'left') {
        list.scrollBy({
            left: -scrollAmount,
            behavior: 'smooth'
        });
    } else if (direction === 'right') {
        list.scrollBy({
            left: scrollAmount,
            behavior: 'smooth'
        });
    }
};

window.selectGameMode = function (modeId) {
    gameState.selectedGameMode = modeId;

    // Update visual selection
    const items = document.querySelectorAll('.game-mode-item');
    items.forEach(item => item.classList.remove('selected'));
    if (event && event.currentTarget) {
        event.currentTarget.classList.add('selected');
    }

    // Reconnect lobby to show new map for this mode
    if (lobbySocket) {
        lobbySocket.close();
        lobbySocket = null;
    }
    connectLobbyToServer();

    console.log(`Selected game mode: ${modeId}`);
};

// Function to change game mode (sends to server)
window.changeGameMode = function (mode) {
    networkSystem.sendChangeGameMode(mode);
};

// Pass rendering is now in pass.js

// Create Map functionality is in tankCreatmap.js, jetCreatmap.js, and raceCreatmap.js

// Fix missing closeShop function (define IMMEDIATELY at top level)
window.closeShop = function () {
    if (typeof gameState !== 'undefined') {
        gameStateManager.updateGameState({ showShop: false });
        window.shopClickAreas = {};

        // Update shop button appearance
        const shopButton = document.getElementById('shopButton');
        if (shopButton) {
            shopButton.classList.remove('shop-open');
        }

        // Show game buttons when shop is closed
        const gameButtons = document.getElementById('gameButtons');
        if (gameButtons) gameButtons.style.display = 'flex';
    }
};

// Lobby shop rendering system
let lobbyShopAnimationId = null;

function startLobbyShopRendering() {
    if (lobbyShopAnimationId) return; // Already running

    const canvas = getCurrentLobbyCanvas();
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    function renderLobbyShop() {
        if (gameState.isInLobby && gameState.showShop) {
            // Initialize scroll systems if needed
            if (!window.shopRowScrollOffsets) window.shopRowScrollOffsets = {};
            if (!window.shopTargetScrollOffsets) window.shopTargetScrollOffsets = {};
            if (!window.shopScrollOffsetY) window.shopScrollOffsetY = 0;
            if (!window.shopTargetScrollOffsetY) window.shopTargetScrollOffsetY = 0;

            // Smooth scroll interpolation for all rows
            const colorOrder = ['blue', 'camo', 'desert', 'purple', 'red'];
            colorOrder.forEach(color => {
                // Initialize if not exists
                if (typeof window.shopRowScrollOffsets[color] === 'undefined') {
                    window.shopRowScrollOffsets[color] = 0;
                }
                if (typeof window.shopTargetScrollOffsets[color] === 'undefined') {
                    window.shopTargetScrollOffsets[color] = 0;
                }

                const current = window.shopRowScrollOffsets[color];
                const target = window.shopTargetScrollOffsets[color];
                const diff = target - current;

                // Smooth lerp with higher precision
                if (Math.abs(diff) > 0.5) {
                    window.shopRowScrollOffsets[color] = current + diff * 0.15;
                } else {
                    window.shopRowScrollOffsets[color] = target;
                }
            });

            // Smooth vertical scrolling
            const verticalDiff = window.shopTargetScrollOffsetY - window.shopScrollOffsetY;
            if (Math.abs(verticalDiff) > 0.5) {
                window.shopScrollOffsetY += verticalDiff * 0.15;
            } else {
                window.shopScrollOffsetY = window.shopTargetScrollOffsetY;
            }

            // Save the current canvas state
            ctx.save();

            // Draw shop on top of the lobby background
            drawShop();

            ctx.restore();

            lobbyShopAnimationId = requestAnimationFrame(renderLobbyShop);
        } else {
            lobbyShopAnimationId = null;
        }
    }

    renderLobbyShop();
}

function stopLobbyShopRendering() {
    if (lobbyShopAnimationId) {
        cancelAnimationFrame(lobbyShopAnimationId);
        lobbyShopAnimationId = null;
    }

    // Remove scroll buttons
    const buttonContainer = document.getElementById('shopScrollButtons');
    if (buttonContainer) buttonContainer.remove();

    // Clear the lobby background canvas to remove shop overlay
    const canvas = getCurrentLobbyCanvas();
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Redraw the lobby background if needed
        if (gameState.isInLobby) {
            // Only restart tank background if we're in tank mode
            if (!window.currentLobbyVehicleType || window.currentLobbyVehicleType === 'tank') {
                initializeLobbyBackground(); // This should redraw the lobby
            }
        }
    }
}

// Add lobby shop click handler
function setupLobbyShopHandler() {
    const lobbyCanvas = getCurrentLobbyCanvas();
    if (!lobbyCanvas) return;

    lobbyCanvas.addEventListener('mousedown', (e) => {
        if (e.button === 0 && gameState.isInLobby && gameState.showShop) {
            e.preventDefault();
            handleShopClick(e);
        }
    });

    // Add scroll support for shop (vertical and horizontal per row)
    lobbyCanvas.addEventListener('wheel', (e) => {
        if (gameState.isInLobby && gameState.showShop) {
            e.preventDefault();
            const scrollSpeed = 60;

            // Initialize all scroll systems properly
            if (!window.shopScrollOffsetY) window.shopScrollOffsetY = 0;
            if (!window.shopTargetScrollOffsetY) window.shopTargetScrollOffsetY = 0;
            if (!window.shopRowScrollOffsets) window.shopRowScrollOffsets = {};
            if (!window.shopTargetScrollOffsets) window.shopTargetScrollOffsets = {};
            if (!window.shopRowAreas) window.shopRowAreas = {};

            const rect = lobbyCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            console.log(`Mouse at: ${mouseX}, ${mouseY}, deltaX: ${e.deltaX}, deltaY: ${e.deltaY}, shift: ${e.shiftKey}`);

            // Find which row the mouse is over
            let targetRow = null;
            let rowInfo = null;

            for (const [color, area] of Object.entries(window.shopRowAreas)) {
                const rowStartY = area.y - (window.shopScrollOffsetY || 0);
                const rowEndY = rowStartY + area.height;

                console.log(`Checking row ${color}: rowY ${rowStartY}-${rowEndY}, mouseY: ${mouseY}`);

                if (mouseY >= rowStartY && mouseY <= rowEndY && mouseX > 80 && mouseX < lobbyCanvas.width - 80) {
                    targetRow = color;
                    rowInfo = area;
                    console.log(`Mouse is over row: ${targetRow}`);
                    break;
                }
            }

            // Determine scroll type
            let isHorizontalScroll = false;
            let scrollDelta = 0;

            // Check for horizontal scroll intent
            if (targetRow && (Math.abs(e.deltaX) > 2 || (e.shiftKey && Math.abs(e.deltaY) > 2))) {
                isHorizontalScroll = true;
                scrollDelta = Math.abs(e.deltaX) > 2 ? e.deltaX : e.deltaY;
                console.log(`Horizontal scroll detected for ${targetRow}, delta: ${scrollDelta}`);
            }

            if (isHorizontalScroll && targetRow && rowInfo) {
                // Initialize scroll offsets for this row if needed
                if (typeof window.shopRowScrollOffsets[targetRow] === 'undefined') {
                    window.shopRowScrollOffsets[targetRow] = 0;
                    console.log(`Initialized row scroll offset for ${targetRow}`);
                }
                if (typeof window.shopTargetScrollOffsets[targetRow] === 'undefined') {
                    window.shopTargetScrollOffsets[targetRow] = 0;
                    console.log(`Initialized target scroll offset for ${targetRow}`);
                }

                // Calculate scroll parameters
                const itemWidth = SHOP_CONFIG.SQUARE_SIZE + SHOP_CONFIG.GRID_SPACING;
                const scrollAmount = scrollDelta > 0 ? itemWidth * 1.5 : -itemWidth * 1.5;
                const currentOffset = window.shopTargetScrollOffsets[targetRow] || 0;
                const newOffset = currentOffset + scrollAmount;

                // Calculate max horizontal scroll for this row
                const totalRowWidth = rowInfo.itemCount * itemWidth;
                const viewportWidth = lobbyCanvas.width - 160;
                const maxScrollX = Math.max(0, totalRowWidth - viewportWidth + 40);

                // Apply new offset with bounds
                window.shopTargetScrollOffsets[targetRow] = Math.max(0, Math.min(maxScrollX, newOffset));

                console.log(`Horizontal scroll ${targetRow}: ${currentOffset} -> ${window.shopTargetScrollOffsets[targetRow]} (max: ${maxScrollX})`);
                console.log(`Row has ${rowInfo.itemCount} items, totalWidth: ${totalRowWidth}, viewportWidth: ${viewportWidth}`);

                return; // Exit early for horizontal scroll
            }

            // Vertical scrolling (default behavior)
            const verticalDelta = e.deltaY;
            window.shopTargetScrollOffsetY += verticalDelta > 0 ? scrollSpeed : -scrollSpeed;

            // Calculate max vertical scroll
            const contentHeight = Object.keys(window.shopRowAreas || {}).length * (SHOP_CONFIG.SQUARE_SIZE + 120);
            const viewportHeight = lobbyCanvas.height - 160;
            const maxScrollY = Math.max(0, contentHeight - viewportHeight);

            // Clamp vertical scroll
            window.shopTargetScrollOffsetY = Math.max(0, Math.min(maxScrollY, window.shopTargetScrollOffsetY));

            console.log(`Vertical scroll: ${window.shopScrollOffsetY} -> ${window.shopTargetScrollOffsetY} (max: ${maxScrollY})`);
        }
    });

    // Add touch support for mobile devices
    let touchStartX = 0;
    let touchStartY = 0;
    let touchCurrentRow = null;

    lobbyCanvas.addEventListener('touchstart', (e) => {
        if (gameState.isInLobby && gameState.showShop) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = lobbyCanvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;

            // Find which row the touch started in
            if (window.shopRowAreas) {
                for (const [color, area] of Object.entries(window.shopRowAreas)) {
                    const rowStartY = area.y - (window.shopScrollOffsetY || 0);
                    const rowEndY = rowStartY + area.height;
                    if (touchStartY >= rowStartY && touchStartY <= rowEndY) {
                        touchCurrentRow = color;
                        break;
                    }
                }
            }
        }
    });

    lobbyCanvas.addEventListener('touchmove', (e) => {
        if (gameState.isInLobby && gameState.showShop) {
            e.preventDefault();
        }
    });

    lobbyCanvas.addEventListener('touchend', (e) => {
        if (gameState.isInLobby && gameState.showShop) {
            e.preventDefault();
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const rect = lobbyCanvas.getBoundingClientRect();
                const touchEndX = touch.clientX - rect.left;
                const touchEndY = touch.clientY - rect.top;

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                // If we started in a row and moved horizontally more than vertically
                if (touchCurrentRow && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                    // Initialize scroll offsets consistently
                    if (!window.shopRowScrollOffsets) {
                        window.shopRowScrollOffsets = {};
                    }
                    if (!window.shopTargetScrollOffsets) {
                        window.shopTargetScrollOffsets = {};
                    }

                    if (typeof window.shopRowScrollOffsets[touchCurrentRow] === 'undefined') {
                        window.shopRowScrollOffsets[touchCurrentRow] = 0;
                    }
                    if (typeof window.shopTargetScrollOffsets[touchCurrentRow] === 'undefined') {
                        window.shopTargetScrollOffsets[touchCurrentRow] = window.shopRowScrollOffsets[touchCurrentRow];
                    }

                    const rowArea = window.shopRowAreas[touchCurrentRow];
                    const itemWidth = rowArea.itemWidth;
                    const scrollAmount = deltaX > 0 ? -itemWidth * 2 : itemWidth * 2; // Swipe right = scroll left
                    window.shopTargetScrollOffsets[touchCurrentRow] += scrollAmount;

                    // Calculate max horizontal scroll for this row
                    const totalRowWidth = rowArea.itemCount * rowArea.itemWidth;
                    const viewportWidth = lobbyCanvas.width - 160;
                    const maxScrollX = Math.max(0, totalRowWidth - viewportWidth + 40);

                    // Clamp target scroll
                    window.shopTargetScrollOffsets[touchCurrentRow] = Math.max(0, Math.min(maxScrollX, window.shopTargetScrollOffsets[touchCurrentRow]));
                }
                // Vertical scrolling for touch
                else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 30) {
                    // Initialize target vertical scroll if needed
                    if (typeof window.shopTargetScrollOffsetY === 'undefined') {
                        window.shopTargetScrollOffsetY = window.shopScrollOffsetY || 0;
                    }

                    const scrollSpeed = 60;
                    window.shopTargetScrollOffsetY += deltaY > 0 ? -scrollSpeed * 3 : scrollSpeed * 3; // Swipe down = scroll up

                    // Calculate max vertical scroll
                    const contentHeight = Object.keys(window.shopRowAreas).length * (SHOP_CONFIG.SQUARE_SIZE + 120);
                    const viewportHeight = lobbyCanvas.height - 160;
                    const maxScrollY = Math.max(0, contentHeight - viewportHeight);

                    // Clamp target vertical scroll
                    window.shopTargetScrollOffsetY = Math.max(0, Math.min(maxScrollY, window.shopTargetScrollOffsetY));
                }

                touchCurrentRow = null;
            }
        }
    });
}

// Vehicle type selection function
function selectVehicleType(type) {
    console.log(`Selected vehicle type: ${type}`);
    
    // Update button states
    const tankBtn = document.getElementById('tankBtn');
    const jetBtn = document.getElementById('jetBtn');
    
    if (type === 'tank') {
        tankBtn.classList.add('active');
        jetBtn.classList.remove('active');
        
        // Show tank customization options
        gameState.selectedVehicleType = 'tank';
        
        // Update UI to show tank-related options
        console.log('Tank mode activated - showing tank customization');
        
    } else if (type === 'jet') {
        jetBtn.classList.add('active');
        tankBtn.classList.remove('active');
        
        // Show jet customization options (future feature)
        gameState.selectedVehicleType = 'jet';
        
        // Update UI to show jet-related options
        console.log('Jet mode activated - jet customization coming soon!');
        
        // For now, show a notification that jets are coming soon
        if (typeof showNotification === 'function') {
            showNotification('Jets Coming Soon!', '#FFA500', 32);
        }
    }
}

// Make functions global for onclick handlers
window.openFeature = openFeature;
window.joinGame = joinGame;
window.returnToLobby = returnToLobby;
window.selectVehicleType = selectVehicleType;
window.leaveLobby = function () {
    console.log('Going to lobby...');
    // Close shop if open
    if (gameState.showShop) {
        gameStateManager.updateGameState({ showShop: false });
        stopLobbyShopRendering();
    }

    // Reset to initial lobby state without reloading
    gameState.isInLobby = true;
    gameState.isConnected = false;

    // Show lobby screen if it's hidden
    const lobbyScreen = document.getElementById('lobbyScreen');
    if (lobbyScreen && lobbyScreen.classList.contains('hidden')) {
        lobbyScreen.classList.remove('hidden');
        lobbyScreen.style.animation = 'fadeIn 0.5s ease-out';
    }

    // Hide any game elements that might be showing
    const gameMapArea = document.getElementById('gameMapArea');
    const ui = document.getElementById('ui');
    const scoreProgress = document.getElementById('scoreProgressContainer');
    const centerBoxes = document.getElementById('centerBottomBoxes');

    if (gameMapArea) gameMapArea.classList.add('hidden');
    if (ui) ui.classList.add('hidden');
    if (scoreProgress) scoreProgress.classList.add('hidden');
    if (centerBoxes) centerBoxes.classList.add('hidden');

    // Render DOM map to lobby
    if (window.DOMMapRenderer && window.DOMMapRenderer.initialized) {
        window.DOMMapRenderer.renderToLobby();
    }

    // Make sure lobby background is running (only for tank mode)
    if (!window.currentLobbyVehicleType || window.currentLobbyVehicleType === 'tank') {
        initializeLobbyBackground();
    }
};



// Render tank on lobby preview canvas (uses animated GIFs)
function renderTankOnCanvas(canvasId, tankConfig) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    // Use GIF images for lobby preview
    const { tankImg, weaponImg } = getCurrentTankImages(tankConfig, true);

    if (!tankImg || !weaponImg || !tankImg.complete || !weaponImg.complete) {
        return;
    }

    // Only clear canvas if we're in tank mode to avoid conflicts
    if (gameState.selectedVehicleType === 'tank' || !gameState.selectedVehicleType) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    } else {
        // Don't clear if another vehicle type is selected
        return;
    }

    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);

    // Simple continuous 360-degree rotation - 2x slower
    const rotation = (Date.now() * 0.00005) % (Math.PI * 2);
    ctx.rotate(rotation);

    // Draw tank body (use GIF for animated lobby preview)
    const size = Math.min(canvas.width, canvas.height) * 0.66; // 10% bigger (0.6 * 1.1)
    const tankScale = size / Math.max(tankImg.width, tankImg.height);
    ctx.drawImage(
        tankImg,
        -tankImg.width * tankScale / 2,
        -tankImg.height * tankScale / 2,
        tankImg.width * tankScale,
        tankImg.height * tankScale
    );

    // Draw weapon (use GIF for animated lobby preview) - 20% bigger
    const weaponScale = size / Math.max(weaponImg.width, weaponImg.height); // Normal size for lobby preview
    ctx.drawImage(
        weaponImg,
        -weaponImg.width * weaponScale / 2,
        -weaponImg.height * weaponScale / 2,
        weaponImg.width * weaponScale,
        weaponImg.height * weaponScale
    );

    ctx.restore();
}

// Animate lobby tank previews
function animateLobbyTanks() {
    if (gameState.isInLobby && imagesLoaded) {
        const canvas = document.getElementById('playerTankCanvas');
        if (!canvas) {
            requestAnimationFrame(animateLobbyTanks);
            return;
        }
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Render based on selected vehicle type
        if (gameState.selectedVehicleType === 'tank') {
            renderTankOnCanvas('playerTankCanvas', gameState.selectedTank);
        } else if (gameState.selectedVehicleType === 'jet') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderLobbyJet(ctx, centerX, centerY, gameState.selectedJet);
        } else if (gameState.selectedVehicleType === 'race') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderLobbyRace(ctx, centerX, centerY, gameState.selectedRace);
        }

        // Render party member tanks if they exist
        if (window.partyMembers && window.partyMembers.length > 0) {
            window.partyMembers.forEach((member, index) => {
                const slotNumber = index + 1;
                const canvasId = `partyTank${slotNumber}Canvas`;
                if (member && member.selectedTank) {
                    renderTankOnCanvas(canvasId, member.selectedTank);
                }
            });
        }

        requestAnimationFrame(animateLobbyTanks);
    }
}

// Initialize on DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
    // Set default vehicle type for lobby background
    window.currentLobbyVehicleType = 'tank';
    
    // Only initialize tank background if we're starting with tank selected AND maps exist
    if (!gameState.selectedVehicleType || gameState.selectedVehicleType === 'tank') {
        // Check if tank maps exist
        const allMaps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]');
        const tankMaps = allMaps.filter(map => !map.vehicleType || map.vehicleType === 'tank');
        
        if (tankMaps.length > 0) {
            // Has tank maps - render background
            renderLobbyBackground();
            initializeLobbyBackground();
        } else {
            // No tank maps - show "No maps created" and update play button
            updateLobbyBackgroundNoMaps('tank');
            updatePlayButtonForVehicle('tank', []);
        }
    }

    // Initialize currency display
    updateFortzDisplay();

    // Initialize map button with default text
    const mapButton = document.querySelector('.map-button');
    if (mapButton) {
        mapButton.textContent = 'Map';
        mapButton.style.backgroundImage = 'none';
    }

    // Initialize shop category
    window.currentShopCategory = 'tanks';

    // Initialize shop scroll offsets
    window.shopScrollOffset = 0;
    window.shopScrollOffsetX = 0;
    window.shopScrollOffsetY = 0;
    window.shopTargetScrollOffsetY = 0; // Initialize target offset

    // Setup lobby shop handlers
    setupLobbyShopHandler();

    // Setup input handlers
    setupInputHandlers();

    // Start animating lobby tank previews
    setTimeout(() => {
        if (imagesLoaded) {
            animateLobbyTanks();
        } else {
            // Wait for images to load
            const checkInterval = setInterval(() => {
                if (imagesLoaded) {
                    clearInterval(checkInterval);
                    animateLobbyTanks();
                }
            }, 100);
        }
    }, 100);

    // Window resize handler
    window.addEventListener('resize', () => {
        const tankCanvas = document.getElementById('tankLobbyBackground');
        const jetCanvas = document.getElementById('jetLobbyBackground');
        const raceCanvas = document.getElementById('raceLobbyBackground');
        
        if (tankCanvas) {
            // Full screen tank canvas for map rendering
            tankCanvas.width = window.innerWidth;
            tankCanvas.height = window.innerHeight;
        }
        if (jetCanvas) {
            jetCanvas.width = window.innerWidth;
            jetCanvas.height = window.innerHeight;
        }
        if (raceCanvas) {
            raceCanvas.width = window.innerWidth;
            raceCanvas.height = window.innerHeight;
        }

        if (canvas) {
            resizeCanvas();
        }
    });
});
// Game mode modal is now handled with HTML elements above

// Locker rendering is now in locker.js

// Add click handlers for new panels
document.addEventListener('click', (e) => {
    const lobbyCanvas = getCurrentLobbyCanvas();
    const rect = lobbyCanvas?.getBoundingClientRect();
    if (!rect) return;

    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check for close button click on any feature
    if (window.featureClickAreas?.closeButton) {
        const area = window.featureClickAreas.closeButton;
        if (x >= area.x && x <= area.x + area.width && y >= area.y && y <= area.y + area.height) {
            closeAllPanels();
            return;
        }
    }

    if (gameState.showGameModes && window.gameModeClickAreas) {
        for (const [id, area] of Object.entries(window.gameModeClickAreas)) {
            if (x >= area.x && x <= area.x + area.width && y >= area.y && y <= area.y + area.height) {
                gameState.selectedGameMode = area.mode;
                console.log('Selected game mode:', area.mode);

                // Show confirmation message
                const modeNames = {
                    'ffa': 'Free For All',
                    'tdm': 'Team Deathmatch',
                    'ctf': 'Capture the Flag',
                    'koth': 'King of the Hill',
                    'br': 'Battle Royale'
                };
                showNotification(`${modeNames[area.mode]} selected!`, '#00f7ff', 24);

                // If in game, immediately change the map
                if (gameState.isConnected) {
                    window.changeGameMode(area.mode);
                }
            }
        }
    }

    if (gameState.showLocker && window.lockerClickAreas) {
        for (const [id, area] of Object.entries(window.lockerClickAreas)) {
            if (x >= area.x && x <= area.x + area.width && y >= area.y && y <= area.y + area.height) {
                const key = area.category === 'colors' ? 'color' : area.category === 'bodies' ? 'body' : 'weapon';
                gameState.selectedTank[key] = area.item;
                console.log('Equipped:', area.item);
            }
        }
    }

    if (gameState.showSettings && settingSliders) {
        for (const [id, slider] of Object.entries(settingSliders)) {
            if (slider.category === 'sound' && x >= slider.x && x <= slider.x + slider.width &&
                y >= slider.y && y <= slider.y + slider.height) {
                const value = Math.round(((x - slider.x) / slider.width) * 100);
                gameState.settings.sound[slider.type] = Math.max(0, Math.min(100, value));
            } else if (slider.category === 'graphics' && x >= slider.x && x <= slider.x + slider.width &&
                y >= slider.y && y <= slider.y + slider.height) {
                gameState.settings.graphics.quality = slider.quality;
            }
        }
    }

    if (gameState.showPass && window.passClickAreas) {
        for (const [id, area] of Object.entries(window.passClickAreas)) {
            if (x >= area.x && x <= area.x + area.width && y >= area.y && y <= area.y + area.height) {
                // Claim the reward
                const tier = PASS_TIERS.find(t => t.tier === area.tier);
                if (tier && !tier.claimed) {
                    tier.claimed = true;
                    // Award the reward based on tier
                    if (tier.reward.includes('Fortz')) {
                        const amount = parseInt(tier.reward);
                        if (!isNaN(amount)) {
                            gameState.fortzCurrency += amount;
                            updateFortzDisplay();
                        }
                    }
                    console.log(`Claimed reward: ${tier.reward}`);
                }
            }
        }
    }

    // Create map clicks are now handled by handleMapCreatorClick in tankCreatmap.js
});

// Close panels with ESC key and handle chat input
document.addEventListener('keydown', (e) => {
    // Handle chat modal
    const chatModal = document.getElementById('chatModal');
    const chatInput = document.getElementById('chatInput');

    if (chatModal && !chatModal.classList.contains('hidden')) {
        if (e.key === 'Enter') {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) {
                // Send chat message (functionality to be implemented)
                console.log('Chat message:', message);
                // TODO: Send to server/party members
            }
            chatInput.value = '';
            chatModal.classList.add('hidden');
        } else if (e.key === 'Escape') {
            e.preventDefault();
            chatInput.value = '';
            chatModal.classList.add('hidden');
        }
        return;
    }

    // ESC key closes any open feature
    if (e.key === 'Escape') {
        if (gameState.showGameModes || gameState.showLocker || gameState.showSettings || gameState.showShop ||
            gameState.showPass || gameState.showCreateMap || gameState.showFriends) {
            e.preventDefault();
            closeAllPanels();
        }
    }
});
// Shop category switching
window.switchShopCategory = function (category) {
    // Update tabs
    const tabs = document.querySelectorAll('.shop-category-tab');
    tabs.forEach(tab => {
        if (tab.dataset.category === category) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update content
    const tanksTab = document.getElementById('tanksTab');
    const jetsTab = document.getElementById('jetsTab');
    const raceTab = document.getElementById('raceTab');
    const musicTab = document.getElementById('musicTab');

    // Hide all tabs first
    tanksTab.classList.add('hidden');
    jetsTab.classList.add('hidden');
    raceTab.classList.add('hidden');
    musicTab.classList.add('hidden');

    if (category === 'tanks') {
        tanksTab.classList.remove('hidden');
        loadShopItems('tanks');
    } else if (category === 'jets') {
        jetsTab.classList.remove('hidden');
        loadShopItems('jets');
    } else if (category === 'race') {
        raceTab.classList.remove('hidden');
        loadShopItems('race');
    } else if (category === 'music') {
        musicTab.classList.remove('hidden');
        loadShopItems('music');
    }
};

// Vehicle stats configuration - now handled by WeaponSystem
function getTankStats(weapon, color = 'blue') {
    if (weaponSystem) {
        return weaponSystem.getTankStats(weapon, color);
    }
    
    // Fallback if WeaponSystem not initialized
    return {
        health: 100,
        damage: 10,
        fireRate: 1.0
    };
}

function getJetStats(jetType, color = 'purple') {
    // Ship index (0-2)
    const shipOrder = ['ship1', 'ship2', 'ship3'];
    const shipIndex = shipOrder.indexOf(jetType);
    const shipIdx = shipIndex >= 0 ? shipIndex : 0;
    
    // Color index (0-2) - purple < red < gold
    const colorOrder = ['purple', 'red', 'gold'];
    const colorIndex = colorOrder.indexOf(color);
    const colorIdx = colorIndex >= 0 ? colorIndex : 0;
    
    // TRULY CONTINUOUS: globalIndex = colorIdx * 3 ships + shipIdx
    // This makes red ship1 start right after purple ship3
    const globalIndex = colorIdx * 3 + shipIdx;
    
    // Base stats for purple ship1
    const baseHealth = 80;
    const baseDamage = 15;
    const baseFireRate = 2.0;
    
    // Each step adds these increments (9 total items: 3 colors x 3 ships)
    const healthPerStep = 15;   // 80 to 200 over 9 items
    const damagePerStep = 5;    // 15 to 55 over 9 items
    const fireRatePerStep = 0.1; // 2.0 to 2.8 over 9 items
    
    return {
        health: baseHealth + globalIndex * healthPerStep,
        damage: baseDamage + globalIndex * damagePerStep,
        fireRate: Math.round((baseFireRate + globalIndex * fireRatePerStep) * 10) / 10
    };
}

function getRaceStats(carType) {
    const stats = {
        endurance: { damage: 5, health: 150, fireRate: 0.5 },
        highspec: { damage: 10, health: 100, fireRate: 1.0 },
        touring: { damage: 8, health: 120, fireRate: 0.8 },
        safety: { damage: 6, health: 130, fireRate: 0.6 }
    };
    return stats[carType] || { damage: 5, health: 150, fireRate: 0.5 };
}

// Load shop items
function loadShopItems(category) {
    if (category === 'tanks') {
        loadTankItems();
    } else if (category === 'jets') {
        loadJetItems();
    } else if (category === 'race') {
        loadRaceItems();
    } else if (category === 'music') {
        loadMusicItems();
    }
}

// Load tank items
function loadTankItems() {
    const container = document.getElementById('tanksTab');
    if (!container) return;

    // Clear and rebuild the entire tab content
    container.innerHTML = '';
    
    // Create shop wrapper with scroll buttons
    const shopWrapper = document.createElement('div');
    shopWrapper.className = 'new-shop-wrapper';
    
    // Left scroll button
    const leftBtn = document.createElement('button');
    leftBtn.className = 'new-scroll-button new-scroll-button-left';
    leftBtn.innerHTML = 'â€¹';
    leftBtn.onclick = () => {
        const scrollContainer = document.getElementById('newShopScrollContainer');
        if (scrollContainer) scrollContainer.scrollBy({ left: -400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(leftBtn);
    
    // Scroll container
    const scrollContainer = document.createElement('div');
    scrollContainer.className = 'new-shop-scroll-container';
    scrollContainer.id = 'newShopScrollContainer';
    
    // Shop grid
    const shopGrid = document.createElement('div');
    shopGrid.className = 'new-shop-grid';
    
    // Tank items configuration
    const colors = ['blue', 'camo', 'desert', 'purple', 'red'];
    const weapons = ['turret_01_mk1', 'turret_01_mk2', 'turret_01_mk3', 'turret_01_mk4', 'turret_02_mk1', 'turret_02_mk2', 'turret_02_mk3', 'turret_02_mk4'];
    const weaponNames = { 
        turret_01_mk1: 'MK1', turret_01_mk2: 'MK2', turret_01_mk3: 'MK3', turret_01_mk4: 'MK4',
        turret_02_mk1: 'MK5', turret_02_mk2: 'MK6', turret_02_mk3: 'MK7', turret_02_mk4: 'MK8'
    };
    const colorNames = { blue: 'Blue', camo: 'Camo', desert: 'Desert', purple: 'Purple', red: 'Red' };
    const rarityMap = { blue: 'common', camo: 'rare', desert: 'rare', purple: 'epic', red: 'legendary' };
    
    const prices = {
        blue: { turret_01_mk1: 0, turret_01_mk2: 500, turret_01_mk3: 1000, turret_01_mk4: 2000, turret_02_mk1: 2500, turret_02_mk2: 3000, turret_02_mk3: 3500, turret_02_mk4: 4000 },
        camo: { turret_01_mk1: 300, turret_01_mk2: 800, turret_01_mk3: 1300, turret_01_mk4: 2300, turret_02_mk1: 2800, turret_02_mk2: 3300, turret_02_mk3: 3800, turret_02_mk4: 4300 },
        desert: { turret_01_mk1: 500, turret_01_mk2: 1000, turret_01_mk3: 1500, turret_01_mk4: 2500, turret_02_mk1: 3000, turret_02_mk2: 3500, turret_02_mk3: 4000, turret_02_mk4: 4500 },
        purple: { turret_01_mk1: 800, turret_01_mk2: 1300, turret_01_mk3: 1800, turret_01_mk4: 2800, turret_02_mk1: 3300, turret_02_mk2: 3800, turret_02_mk3: 4300, turret_02_mk4: 4800 },
        red: { turret_01_mk1: 1200, turret_01_mk2: 1700, turret_01_mk3: 2200, turret_01_mk4: 3200, turret_02_mk1: 3700, turret_02_mk2: 4200, turret_02_mk3: 4700, turret_02_mk4: 5200 }
    };

    // Generate all tank items
    colors.forEach(color => {
        weapons.forEach(weapon => {
            const price = prices[color][weapon];
            const isOwned = isShopComboOwned(color, weapon);
            const isEquipped = isShopComboEquipped(color, weapon);
            const rarity = rarityMap[color];
            
            // Shop item card
            const item = document.createElement('div');
            item.className = `new-shop-item rarity-${rarity}` + (isEquipped ? ' equipped' : '') + (isOwned ? ' owned' : '');
            
            // Rarity badge
            const badge = document.createElement('div');
            badge.className = 'new-rarity-badge';
            badge.innerHTML = 'â˜…';
            item.appendChild(badge);
            
            // Vehicle stats (damage, health, fire rate) - positioned left of image
            // Stats now scale with BOTH weapon AND color (keeps going up!)
            const tankStats = getTankStats(weapon, color);
            const statsDiv = document.createElement('div');
            statsDiv.className = 'vehicle-stats-vertical';
            statsDiv.innerHTML = `
                <div class="stat-item-vertical">
                    <img src="/assets/health.png" alt="Health" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${tankStats.health}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/damage.png" alt="Damage" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${tankStats.damage}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/fireRate.png" alt="Fire Rate" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${tankStats.fireRate}</span>
                </div>
            `;
            item.appendChild(statsDiv);
            
            // Item image area with tank preview
            const imageArea = document.createElement('div');
            imageArea.className = 'new-item-image';
            
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            renderShopTankPreview(canvas, color, weapon);
            imageArea.appendChild(canvas);
            item.appendChild(imageArea);
            
            // Item info
            const info = document.createElement('div');
            info.className = 'new-item-info';
            
            const name = document.createElement('h3');
            name.className = 'new-item-name';
            name.textContent = `${colorNames[color]} ${weaponNames[weapon]}`;
            info.appendChild(name);
            
            // Footer with price and buy button
            const footer = document.createElement('div');
            footer.className = 'new-item-footer';
            
            const priceDiv = document.createElement('div');
            priceDiv.className = 'new-item-price';
            if (isEquipped) {
                priceDiv.innerHTML = '<span class="equipped-text">âœ“ EQUIPPED</span>';
            } else if (isOwned) {
                priceDiv.innerHTML = '<span class="owned-text">OWNED</span>';
            } else if (price === 0) {
                priceDiv.innerHTML = '<span class="free-text">FREE</span>';
            } else {
                priceDiv.innerHTML = `<img src="/assets/images/ui/fortz-coin.png" class="coin-icon" alt="Fortz"><span class="price-text">${price}</span>`;
            }
            footer.appendChild(priceDiv);
            
            const buyBtn = document.createElement('button');
            buyBtn.className = 'new-buy-button';
            buyBtn.innerHTML = isEquipped ? 'âœ“' : (isOwned ? 'âš¡' : 'ðŸ›’');
            if (!isEquipped) {
                buyBtn.onclick = (e) => {
                    e.stopPropagation();
                    purchaseOrEquipShopCombo(color, weapon, price);
                };
            }
            footer.appendChild(buyBtn);
            
            info.appendChild(footer);
            item.appendChild(info);
            
            // Click handler for whole card
            if (!isEquipped) {
                item.onclick = () => purchaseOrEquipShopCombo(color, weapon, price);
            }
            
            shopGrid.appendChild(item);
        });
    });
    
    scrollContainer.appendChild(shopGrid);
    
    // Add scroll performance optimization
    let scrollTimeout;
    scrollContainer.addEventListener('scroll', () => {
        scrollContainer.classList.add('scrolling');
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            scrollContainer.classList.remove('scrolling');
        }, 150);
    }, { passive: true });
    
    shopWrapper.appendChild(scrollContainer);
    
    // Right scroll button
    const rightBtn = document.createElement('button');
    rightBtn.className = 'new-scroll-button new-scroll-button-right';
    rightBtn.innerHTML = 'â€º';
    rightBtn.onclick = () => {
        const sc = document.getElementById('newShopScrollContainer');
        if (sc) sc.scrollBy({ left: 400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(rightBtn);
    
    container.appendChild(shopWrapper);
}

// Load jet items - same style as tanks
function loadJetItems() {
    const container = document.getElementById('jetsTab');
    if (!container) return;

    // Clear and rebuild the entire tab content
    container.innerHTML = '';
    
    // Create shop wrapper with scroll buttons
    const shopWrapper = document.createElement('div');
    shopWrapper.className = 'new-shop-wrapper';
    
    // Left scroll button
    const leftBtn = document.createElement('button');
    leftBtn.className = 'new-scroll-button new-scroll-button-left';
    leftBtn.innerHTML = 'â€¹';
    leftBtn.onclick = () => {
        const scrollContainer = document.getElementById('jetsScrollContainer');
        if (scrollContainer) scrollContainer.scrollBy({ left: -400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(leftBtn);
    
    // Scroll container
    const scrollContainer = document.createElement('div');
    scrollContainer.className = 'new-shop-scroll-container';
    scrollContainer.id = 'jetsScrollContainer';
    
    // Shop grid
    const shopGrid = document.createElement('div');
    shopGrid.className = 'new-shop-grid';
    
    // Jet items configuration - Order: purple â†’ red â†’ gold (stats keep increasing!)
    const jetTypes = ['ship1', 'ship2', 'ship3'];
    const jetColors = ['purple', 'red', 'gold']; // Purple first, then red, then gold (best)
    const jetNames = { ship1: 'Fighter', ship2: 'Bomber', ship3: 'Interceptor' };
    const colorNames = { purple: 'Purple', red: 'Red', gold: 'Gold' };
    const rarityMap = { purple: 'common', red: 'rare', gold: 'legendary' }; // Purple=common, Red=rare, Gold=legendary
    
    // Prices increase with color tier: purple < red < gold
    const jetPrices = {
        ship1: { purple: 500, red: 1500, gold: 3000 },
        ship2: { purple: 1000, red: 2500, gold: 4500 },
        ship3: { purple: 2000, red: 4000, gold: 6500 }
    };

    // Generate all jet items - GROUP BY COLOR (purple together, red together, gold together)
    jetColors.forEach(color => {
        jetTypes.forEach(jetType => {
            const price = jetPrices[jetType][color];
            const isOwned = isJetComboOwned(jetType, color);
            const isEquipped = isJetComboEquipped(jetType, color);
            const rarity = rarityMap[color];
            
            // Shop item card
            const item = document.createElement('div');
            item.className = `new-shop-item rarity-${rarity}` + (isEquipped ? ' equipped' : '') + (isOwned ? ' owned' : '');
            
            // Rarity badge
            const badge = document.createElement('div');
            badge.className = 'new-rarity-badge';
            badge.innerHTML = 'âœˆï¸';
            item.appendChild(badge);
            
            // Vehicle stats (damage, health, fire rate) - positioned left of image
            // Stats now scale with color: purple < red < gold (keeps going up!)
            const jetStats = getJetStats(jetType, color);
            const statsDiv = document.createElement('div');
            statsDiv.className = 'vehicle-stats-vertical';
            statsDiv.innerHTML = `
                <div class="stat-item-vertical">
                    <img src="/assets/health.png" alt="Health" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${jetStats.health}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/damage.png" alt="Damage" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${jetStats.damage}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/fireRate.png" alt="Fire Rate" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${jetStats.fireRate}</span>
                </div>
            `;
            item.appendChild(statsDiv);
            
            // Item image area with jet preview
            const imageArea = document.createElement('div');
            imageArea.className = 'new-item-image';
            
            const img = document.createElement('img');
            img.src = `/assets/jet/spr_${jetType}_${color}.png`;
            imageArea.appendChild(img);
            item.appendChild(imageArea);
            
            // Item info
            const info = document.createElement('div');
            info.className = 'new-item-info';
            
            const name = document.createElement('h3');
            name.className = 'new-item-name';
            name.textContent = `${colorNames[color]} ${jetNames[jetType]}`;
            info.appendChild(name);
            
            // Footer with price and buy button
            const footer = document.createElement('div');
            footer.className = 'new-item-footer';
            
            const priceDiv = document.createElement('div');
            priceDiv.className = 'new-item-price';
            if (isEquipped) {
                priceDiv.innerHTML = '<span class="equipped-text">âœ“ EQUIPPED</span>';
            } else if (isOwned) {
                priceDiv.innerHTML = '<span class="owned-text">OWNED</span>';
            } else {
                priceDiv.innerHTML = `<img src="/assets/images/ui/fortz-coin.png" class="coin-icon" alt="Fortz"><span class="price-text">${price}</span>`;
            }
            footer.appendChild(priceDiv);
            
            const buyBtn = document.createElement('button');
            buyBtn.className = 'new-buy-button';
            buyBtn.innerHTML = isEquipped ? 'âœ“' : (isOwned ? 'âš¡' : 'ðŸ›’');
            if (!isEquipped) {
                buyBtn.onclick = (e) => {
                    e.stopPropagation();
                    purchaseOrEquipJetCombo(jetType, color, price);
                };
            }
            footer.appendChild(buyBtn);
            
            info.appendChild(footer);
            item.appendChild(info);
            
            // Click handler for whole card
            if (!isEquipped) {
                item.onclick = () => purchaseOrEquipJetCombo(jetType, color, price);
            }
            
            shopGrid.appendChild(item);
        });
    });
    
    scrollContainer.appendChild(shopGrid);
    
    // Add scroll performance optimization
    let scrollTimeout;
    scrollContainer.addEventListener('scroll', () => {
        scrollContainer.classList.add('scrolling');
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            scrollContainer.classList.remove('scrolling');
        }, 150);
    }, { passive: true });
    
    shopWrapper.appendChild(scrollContainer);
    
    // Right scroll button
    const rightBtn = document.createElement('button');
    rightBtn.className = 'new-scroll-button new-scroll-button-right';
    rightBtn.innerHTML = 'â€º';
    rightBtn.onclick = () => {
        const sc = document.getElementById('jetsScrollContainer');
        if (sc) sc.scrollBy({ left: 400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(rightBtn);
    
    container.appendChild(shopWrapper);
}

// Load race car items - same style as tanks and jets
function loadRaceItems() {
    const container = document.getElementById('raceTab');
    if (!container) return;

    // Clear and rebuild the entire tab content
    container.innerHTML = '';
    
    // Create shop wrapper with scroll buttons
    const shopWrapper = document.createElement('div');
    shopWrapper.className = 'new-shop-wrapper';
    
    // Left scroll button
    const leftBtn = document.createElement('button');
    leftBtn.className = 'new-scroll-button new-scroll-button-left';
    leftBtn.innerHTML = 'â€¹';
    leftBtn.onclick = () => {
        const scrollContainer = document.getElementById('raceScrollContainer');
        if (scrollContainer) scrollContainer.scrollBy({ left: -400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(leftBtn);
    
    // Scroll container
    const scrollContainer = document.createElement('div');
    scrollContainer.className = 'new-shop-scroll-container';
    scrollContainer.id = 'raceScrollContainer';
    
    // Shop grid
    const shopGrid = document.createElement('div');
    shopGrid.className = 'new-shop-grid';
    
    // Race car items configuration - only include existing combinations
    const raceCarData = [
        // Endurance cars
        { type: 'endurance', color: 'blue', price: 800, rarity: 'common' },
        { type: 'endurance', color: 'red', price: 1000, rarity: 'common' },
        { type: 'endurance', color: 'white', price: 900, rarity: 'common' },
        { type: 'endurance', color: 'yellow', price: 1100, rarity: 'common' },
        { type: 'endurance', color: 'purple', price: 1200, rarity: 'common' },
        
        // High-spec cars
        { type: 'highspec', color: 'blue', price: 2500, rarity: 'legendary' },
        { type: 'highspec', color: 'red', price: 3000, rarity: 'legendary' },
        { type: 'highspec', color: 'white', price: 2800, rarity: 'legendary' },
        { type: 'highspec', color: 'yellow', price: 3200, rarity: 'legendary' },
        { type: 'highspec', color: 'purple', price: 3500, rarity: 'legendary' },
        
        // Touring cars
        { type: 'touring', color: 'blue', price: 1200, rarity: 'rare' },
        { type: 'touring', color: 'red', price: 1500, rarity: 'rare' },
        { type: 'touring', color: 'white', price: 1300, rarity: 'rare' },
        { type: 'touring', color: 'yellow', price: 1600, rarity: 'rare' },
        { type: 'touring', color: 'purple', price: 1800, rarity: 'rare' },
        
        // Safety cars (only available colors)
        { type: 'safety', color: 'blue', price: 1800, rarity: 'epic' },
        { type: 'safety', color: 'red', price: 2000, rarity: 'epic' },
        { type: 'safety', color: 'white', price: 1900, rarity: 'epic' },
        { type: 'safety', color: 'green', price: 2100, rarity: 'epic' },
        { type: 'safety', color: 'grey', price: 1950, rarity: 'epic' }
    ];
    
    const carNames = { 
        endurance: 'Endurance', 
        highspec: 'High-Spec', 
        touring: 'Touring', 
        safety: 'Safety'
    };
    const colorNames = { 
        blue: 'Blue', red: 'Red', white: 'White', yellow: 'Yellow', 
        purple: 'Purple', green: 'Green', grey: 'Grey' 
    };

    // Generate race car items from the data
    raceCarData.forEach(carData => {
        const { type: carType, color, price, rarity } = carData;
        const isOwned = isRaceComboOwned(carType, color);
        const isEquipped = isRaceComboEquipped(carType, color);
            
            // Shop item card
            const item = document.createElement('div');
            item.className = `new-shop-item rarity-${rarity}` + (isEquipped ? ' equipped' : '') + (isOwned ? ' owned' : '');
            
            // Rarity badge
            const badge = document.createElement('div');
            badge.className = 'new-rarity-badge';
            badge.innerHTML = 'ðŸŽï¸';
            item.appendChild(badge);
            
            // Vehicle stats (damage, health, fire rate) - positioned left of image
            const raceStats = getRaceStats(carType);
            const statsDiv = document.createElement('div');
            statsDiv.className = 'vehicle-stats-vertical';
            statsDiv.innerHTML = `
                <div class="stat-item-vertical">
                    <img src="/assets/health.png" alt="Health" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${raceStats.health}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/damage.png" alt="Damage" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${raceStats.damage}</span>
                </div>
                <div class="stat-item-vertical">
                    <img src="/assets/fireRate.png" alt="Fire Rate" class="stat-icon-vertical">
                    <span class="stat-value-vertical">${raceStats.fireRate}</span>
                </div>
            `;
            item.appendChild(statsDiv);
            
            // Item image area with race car preview
            const imageArea = document.createElement('div');
            imageArea.className = 'new-item-image';
            
            const img = document.createElement('img');
            // Use the renamed PNG files
            img.src = `/assets/race/sprites/cars/${carType}_${color}.png`;
            imageArea.appendChild(img);
            item.appendChild(imageArea);
            
            // Item info
            const info = document.createElement('div');
            info.className = 'new-item-info';
            
            const name = document.createElement('h3');
            name.className = 'new-item-name';
            name.textContent = `${colorNames[color]} ${carNames[carType]}`;
            info.appendChild(name);
            
            // Footer with price and buy button
            const footer = document.createElement('div');
            footer.className = 'new-item-footer';
            
            const priceDiv = document.createElement('div');
            priceDiv.className = 'new-item-price';
            if (isEquipped) {
                priceDiv.innerHTML = '<span class="equipped-text">âœ“ EQUIPPED</span>';
            } else if (isOwned) {
                priceDiv.innerHTML = '<span class="owned-text">OWNED</span>';
            } else {
                priceDiv.innerHTML = `<img src="/assets/images/ui/fortz-coin.png" class="coin-icon" alt="Fortz"><span class="price-text">${price}</span>`;
            }
            footer.appendChild(priceDiv);
            
            const buyBtn = document.createElement('button');
            buyBtn.className = 'new-buy-button';
            buyBtn.innerHTML = isEquipped ? 'âœ“' : (isOwned ? 'âš¡' : 'ðŸ›’');
            if (!isEquipped) {
                buyBtn.onclick = (e) => {
                    e.stopPropagation();
                    purchaseOrEquipRaceCombo(carType, color, price);
                };
            }
            footer.appendChild(buyBtn);
            
            info.appendChild(footer);
            item.appendChild(info);
            
        // Click handler for whole card
        if (!isEquipped) {
            item.onclick = () => purchaseOrEquipRaceCombo(carType, color, price);
        }
        
        shopGrid.appendChild(item);
    });
    
    scrollContainer.appendChild(shopGrid);
    
    // Add scroll performance optimization
    let scrollTimeout;
    scrollContainer.addEventListener('scroll', () => {
        scrollContainer.classList.add('scrolling');
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            scrollContainer.classList.remove('scrolling');
        }, 150);
    }, { passive: true });
    
    shopWrapper.appendChild(scrollContainer);
    
    // Right scroll button
    const rightBtn = document.createElement('button');
    rightBtn.className = 'new-scroll-button new-scroll-button-right';
    rightBtn.innerHTML = 'â€º';
    rightBtn.onclick = () => {
        const sc = document.getElementById('raceScrollContainer');
        if (sc) sc.scrollBy({ left: 400, behavior: 'smooth' });
    };
    shopWrapper.appendChild(rightBtn);
    
    container.appendChild(shopWrapper);
}

function getShopColorHex(color) {
    const colors = { blue: '#3498db', camo: '#27ae60', desert: '#f39c12', purple: '#9b59b6', red: '#e74c3c' };
    return colors[color] || '#ffffff';
}

function isShopComboOwned(color, weapon) {
    if (weaponSystem) {
        return weaponSystem.isShopComboOwned(color, weapon);
    }
    
    // Fallback if WeaponSystem not initialized
    const ownedItems = window.gameState.ownedItems || { colors: [], weapons: [] };
    const colorOwned = ownedItems.colors?.includes(color) || color === 'blue';
    const weaponOwned = ownedItems.weapons?.includes(weapon) || weapon === 'turret_01_mk1';
    return colorOwned && weaponOwned;
}

function isShopComboEquipped(color, weapon) {
    if (weaponSystem) {
        return weaponSystem.isShopComboEquipped(color, weapon);
    }
    
    // Fallback if WeaponSystem not initialized
    const selectedTank = window.gameState.selectedTank || {};
    return selectedTank.color === color && selectedTank.weapon === weapon;
}

function isJetComboOwned(jetType, color) {
    const ownedItems = window.gameState.ownedItems || { jets: [] };
    const jetId = `${jetType}_${color}`;
    return ownedItems.jets?.includes(jetId) || jetId === 'ship1_purple'; // Default jet is purple (base tier)
}

function isJetComboEquipped(jetType, color) {
    const selectedJet = window.gameState.selectedJet || { type: 'ship1', color: 'purple' };
    return selectedJet.type === jetType && selectedJet.color === color;
}

function isRaceComboOwned(carType, color) {
    const ownedItems = window.gameState.ownedItems || { race: [] };
    const raceId = `${carType}_${color}`;
    return ownedItems.race?.includes(raceId) || raceId === 'endurance_blue'; // Default race car
}

function isRaceComboEquipped(carType, color) {
    const selectedRace = window.gameState.selectedRace || { type: 'endurance', color: 'blue' };
    return selectedRace.type === carType && selectedRace.color === color;
}

// Shop image preloading is now handled by ImageLoader
// This function is kept for backward compatibility but delegates to ImageLoader
function preloadShopTankImages() {
    return imageLoader.preloadShopTankImages();
}

// Call preload early
preloadShopTankImages();

// Shop tank animations now handled by WeaponSystem

function renderShopTankPreview(canvas, color, weapon) {
    if (weaponSystem) {
        return weaponSystem.renderShopTankPreview(canvas, color, weapon);
    }
    
    // Fallback rendering if WeaponSystem not initialized
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2);
}

// Stop all shop tank animations (call when closing shop)
function stopShopTankAnimations() {
    if (weaponSystem) {
        weaponSystem.stopShopTankAnimations();
    }
}

async function purchaseOrEquipShopCombo(color, weapon, price) {
    if (weaponSystem) {
        return weaponSystem.purchaseOrEquipShopCombo(color, weapon, price);
    }
    
    // Fallback if WeaponSystem not initialized
    const isOwned = isShopComboOwned(color, weapon);
    
    if (!isOwned && price > 0) {
        const currentFortz = window.gameState.fortzCurrency || 0;
        if (currentFortz < price) {
            showNotification(`Not enough Fortz! Need ${price}`, '#ff5050', 24);
            return;
        }
        
        window.gameState.fortzCurrency -= price;
        
        if (!window.gameState.ownedItems) {
            window.gameState.ownedItems = { colors: ['blue'], bodies: ['body_halftrack'], weapons: ['turret_01_mk1'] };
        }
        if (!window.gameState.ownedItems.colors.includes(color)) {
            window.gameState.ownedItems.colors.push(color);
        }
        if (!window.gameState.ownedItems.weapons.includes(weapon)) {
            window.gameState.ownedItems.weapons.push(weapon);
        }
        
        showNotification(`Purchased!`, '#4CAF50', 24);
    }
    
    // Equip
    if (!window.gameState.selectedTank) {
        window.gameState.selectedTank = { color: 'blue', body: 'body_halftrack', weapon: 'turret_01_mk1' };
    }
    window.gameState.selectedTank.color = color;
    window.gameState.selectedTank.weapon = weapon;
    
    showNotification(`Equipped!`, '#2196F3', 24);
    updateFortzDisplay();
    // savePlayerProgress(); // TODO: Implement save function
    loadTankItems(); // Refresh grid
    
    // Update lobby preview
    updateLobbyVehiclePreview();
}

async function purchaseOrEquipJetCombo(jetType, color, price) {
    const isOwned = isJetComboOwned(jetType, color);
    const jetId = `${jetType}_${color}`;
    
    if (!isOwned && price > 0) {
        const currentFortz = window.gameState.fortzCurrency || 0;
        if (currentFortz < price) {
            showNotification(`Not enough Fortz! Need ${price}`, '#ff5050', 24);
            return;
        }
        
        window.gameState.fortzCurrency -= price;
        
        if (!window.gameState.ownedItems) {
            window.gameState.ownedItems = { colors: ['blue'], bodies: ['body_halftrack'], weapons: ['turret_01_mk1'], jets: ['ship1_gold'] };
        }
        if (!window.gameState.ownedItems.jets) {
            window.gameState.ownedItems.jets = ['ship1_gold'];
        }
        if (!window.gameState.ownedItems.jets.includes(jetId)) {
            window.gameState.ownedItems.jets.push(jetId);
        }
        
        showNotification(`Purchased!`, '#4CAF50', 24);
    }
    
    // Equip
    if (!window.gameState.selectedJet) {
        window.gameState.selectedJet = { type: 'ship1', color: 'purple' };
    }
    window.gameState.selectedJet.type = jetType;
    window.gameState.selectedJet.color = color;
    
    showNotification(`Equipped!`, '#2196F3', 24);
    updateFortzDisplay();
    // savePlayerProgress(); // TODO: Implement save function
    loadJetItems(); // Refresh grid
    
    // Update lobby preview
    updateLobbyVehiclePreview();
}

async function purchaseOrEquipRaceCombo(carType, color, price) {
    const isOwned = isRaceComboOwned(carType, color);
    const raceId = `${carType}_${color}`;
    
    if (!isOwned && price > 0) {
        const currentFortz = window.gameState.fortzCurrency || 0;
        if (currentFortz < price) {
            showNotification(`Not enough Fortz! Need ${price}`, '#ff5050', 24);
            return;
        }
        
        window.gameState.fortzCurrency -= price;
        
        if (!window.gameState.ownedItems) {
            window.gameState.ownedItems = { colors: ['blue'], bodies: ['body_halftrack'], weapons: ['turret_01_mk1'], jets: ['ship1_gold'], race: ['endurance_blue'] };
        }
        if (!window.gameState.ownedItems.race) {
            window.gameState.ownedItems.race = ['endurance_blue'];
        }
        if (!window.gameState.ownedItems.race.includes(raceId)) {
            window.gameState.ownedItems.race.push(raceId);
        }
        
        showNotification(`Purchased!`, '#4CAF50', 24);
    }
    
    // Equip
    if (!window.gameState.selectedRace) {
        window.gameState.selectedRace = { type: 'endurance', color: 'blue' };
    }
    window.gameState.selectedRace.type = carType;
    window.gameState.selectedRace.color = color;
    
    showNotification(`Equipped!`, '#2196F3', 24);
    updateFortzDisplay();
    // savePlayerProgress(); // TODO: Implement save function
    loadRaceItems(); // Refresh grid
    
    // Update lobby preview
    updateLobbyVehiclePreview();
}

// Load music items
function loadMusicItems() {
    const grid = document.getElementById('musicItemsGrid');
    if (!grid) return;

    grid.innerHTML = '';

    // Define music items
    const musicItems = [
        { id: 'music_1', name: 'Battle Theme', price: 500, description: 'Epic battle music', icon: 'ðŸŽµ' },
        { id: 'music_2', name: 'Victory March', price: 750, description: 'Triumphant victory theme', icon: 'ðŸŽ¶' },
        { id: 'music_3', name: 'Stealth Mode', price: 600, description: 'Sneaky stealth music', icon: 'ðŸŽ¼' },
        { id: 'music_4', name: 'Boss Fight', price: 1000, description: 'Intense boss battle', icon: 'ðŸŽ¸' },
        { id: 'music_5', name: 'Chill Vibes', price: 400, description: 'Relaxing background music', icon: 'ðŸŽ¹' },
        { id: 'music_6', name: 'Electronic Beat', price: 800, description: 'Modern electronic music', icon: 'ðŸŽ§' }
    ];

    musicItems.forEach(item => {
        createShopItemCard(item, grid, 'music');
    });
}

// Create shop item card
function createShopItemCard(item, container, category = 'tank') {
    const card = document.createElement('div');
    const isOwned = checkIfOwned(item);
    card.className = 'shop-item-card' + (isOwned ? ' owned' : '');

    // Preview
    const preview = document.createElement('div');
    preview.className = 'shop-item-preview';

    // Render tank or music icon
    if (category === 'tank' && item.bodyImage && item.turretImage) {
        const canvas = document.createElement('canvas');
        canvas.width = 160;
        canvas.height = 160;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        preview.appendChild(canvas);

        // Render tank on canvas
        renderTankPreview(canvas, item);
    } else if (item.icon) {
        preview.innerHTML = `<div class="shop-item-icon">${item.icon}</div>`;
    }

    // Info
    const info = document.createElement('div');
    info.className = 'shop-item-info';

    const name = document.createElement('div');
    name.className = 'shop-item-name';
    name.textContent = item.name;

    const description = document.createElement('div');
    description.className = 'shop-item-description';
    description.textContent = item.description;

    const price = document.createElement('div');
    price.className = 'shop-item-price';

    if (item.price === 0) {
        price.innerHTML = `<span style="color: #00ff88;">FREE</span>`;
    } else {
        price.innerHTML = `<img src="/assets/images/ui/fortz-coin.png" alt="Fortz"> <span>${item.price}</span>`;
    }

    const buyBtn = document.createElement('button');
    buyBtn.className = 'shop-item-buy-btn';

    if (isOwned) {
        buyBtn.textContent = 'OWNED';
        buyBtn.className += ' owned-btn';
        buyBtn.disabled = true;
    } else if (gameState.fortzCurrency < item.price) {
        buyBtn.textContent = 'INSUFFICIENT FORTZ';
        buyBtn.disabled = true;
    } else {
        buyBtn.textContent = 'BUY NOW';
        buyBtn.onclick = () => buyShopItem(item, category);
    }

    info.appendChild(name);
    info.appendChild(description);
    info.appendChild(price);
    info.appendChild(buyBtn);

    card.appendChild(preview);
    card.appendChild(info);
    container.appendChild(card);
}

// Render tank preview on canvas - using consolidated ImageLoader
function renderTankPreview(canvas, item) {
    // Determine tank configuration from item
    let colorFolder = 'blue';
    if (item.type === 'color') {
        colorFolder = item.id;
    }

    // Extract body and weapon from image paths
    let body = 'body_halftrack';
    let weapon = 'turret_01_mk1';
    
    if (item.bodyImage) {
        const bodyMatch = item.bodyImage.match(/([^/]+)\.png$/);
        if (bodyMatch) {
            body = bodyMatch[1].replace(`${colorFolder}_`, '');
        }
    }
    
    if (item.turretImage) {
        const weaponMatch = item.turretImage.match(/([^/]+)\.png$/);
        if (weaponMatch) {
            weapon = weaponMatch[1].replace(`${colorFolder}_`, '');
        }
    }

    const tankConfig = { color: colorFolder, body, weapon };
    
    // Use consolidated ImageLoader function
    imageLoader.renderTankOnCanvas(canvas.id, tankConfig, { 
        scale: 0.4, 
        rotation: -Math.PI / 2 
    });
}

// Check if item is owned
function checkIfOwned(item) {
    if (item.type === 'color') {
        return gameState.ownedItems.colors.includes(item.id);
    } else if (item.type === 'body') {
        return gameState.ownedItems.bodies.includes(item.id);
    } else if (item.type === 'weapon') {
        return gameState.ownedItems.weapons.includes(item.id);
    }
    return false;
}

// Buy shop item
function buyShopItem(item, category) {
    if (gameState.fortzCurrency < item.price) {
        showNotification('Not enough Fortz!', '#ff6464', 24);
        return;
    }

    // Deduct currency
    gameState.fortzCurrency -= item.price;
    updateFortzDisplay();

    // Add to owned items
    if (item.type === 'color' && !gameState.ownedItems.colors.includes(item.id)) {
        gameState.ownedItems.colors.push(item.id);
    } else if (item.type === 'body' && !gameState.ownedItems.bodies.includes(item.id)) {
        gameState.ownedItems.bodies.push(item.id);
    } else if (item.type === 'weapon' && !gameState.ownedItems.weapons.includes(item.id)) {
        gameState.ownedItems.weapons.push(item.id);
    }

    // Save to storage
    savePlayerProgress();

    // Show notification
    showNotification(`Purchased ${item.name}!`, '#00ff88', 24);

    // Reload shop items to update UI
    if (category === 'music') {
        loadMusicItems();
    } else {
        loadTankItems();
    }
}


// Locker category switching
window.switchLockerCategory = function (category) {
    // Update tabs
    const tabs = document.querySelectorAll('.locker-category-tab');
    tabs.forEach(tab => {
        if (tab.dataset.category === category) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update content
    const colorsTab = document.getElementById('colorsTab');
    const bodiesTab = document.getElementById('bodiesTab');
    const weaponsTab = document.getElementById('weaponsTab');

    colorsTab.classList.add('hidden');
    bodiesTab.classList.add('hidden');
    weaponsTab.classList.add('hidden');

    if (category === 'colors') {
        colorsTab.classList.remove('hidden');
        loadLockerItems('colors');
    } else if (category === 'bodies') {
        bodiesTab.classList.remove('hidden');
        loadLockerItems('bodies');
    } else if (category === 'weapons') {
        weaponsTab.classList.remove('hidden');
        loadLockerItems('weapons');
    }
};

// Load locker items
function loadLockerItems(category) {
    let grid, items;

    if (category === 'colors') {
        grid = document.getElementById('colorsItemsGrid');
        items = [
            { id: 'blue', name: 'Blue', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk1.png' },
            { id: 'camo', name: 'Camo', bodyImage: 'camo_body_halftrack.png', turretImage: 'camo_turret_01_mk1.png' },
            { id: 'desert', name: 'Desert', bodyImage: 'desert_body_halftrack.png', turretImage: 'desert_turret_01_mk1.png' },
            { id: 'purple', name: 'Purple', bodyImage: 'purple_body_halftrack.png', turretImage: 'purple_turret_01_mk1.png' },
            { id: 'red', name: 'Red', bodyImage: 'red_body_halftrack.png', turretImage: 'red_turret_01_mk1.png' }
        ];
    } else if (category === 'bodies') {
        grid = document.getElementById('bodiesItemsGrid');
        items = [
            { id: 'body_halftrack', name: 'Halftrack', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk1.png' },
            { id: 'body_tracks', name: 'Full Tracks', bodyImage: 'body_tracks.png', turretImage: 'blue_turret_01_mk1.png' }
        ];
    } else if (category === 'weapons') {
        grid = document.getElementById('weaponsItemsGrid');
        items = [
            { id: 'turret_01_mk1', name: 'Basic Turret', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk1.png' },
            { id: 'turret_01_mk2', name: 'Turret MK2', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk2.png' },
            { id: 'turret_01_mk3', name: 'Turret MK3', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk3.png' },
            { id: 'turret_01_mk4', name: 'Turret MK4', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_01_mk4.png' },
            { id: 'turret_02_mk1', name: 'Light Cannon', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_02_mk1.png' },
            { id: 'turret_02_mk2', name: 'Heavy Cannon', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_02_mk2.png' },
            { id: 'turret_02_mk3', name: 'Plasma Cannon', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_02_mk3.png' },
            { id: 'turret_02_mk4', name: 'Ultimate Cannon', bodyImage: 'blue_body_halftrack.png', turretImage: 'blue_turret_02_mk4.png' }
        ];
    }

    if (!grid) return;
    grid.innerHTML = '';

    items.forEach(item => {
        createLockerItemCard(item, grid, category);
    });
}

// Create locker item card
function createLockerItemCard(item, container, category) {
    const card = document.createElement('div');
    const isOwned = checkIfItemOwned(item, category);
    const isEquipped = checkIfItemEquipped(item, category);

    card.className = 'locker-item-card';
    if (isEquipped) card.className += ' equipped';
    if (!isOwned) card.className += ' locked';

    // Preview
    const preview = document.createElement('div');
    preview.className = 'locker-item-preview';

    const canvas = document.createElement('canvas');
    canvas.width = 160;
    canvas.height = 160;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    preview.appendChild(canvas);

    // Render tank on canvas
    if (isOwned) {
        renderLockerTankPreview(canvas, item, category);
    } else {
        // Show locked icon
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '60px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ðŸ”’', canvas.width / 2, canvas.height / 2);
    }

    // Info
    const info = document.createElement('div');
    info.className = 'locker-item-info';

    const name = document.createElement('div');
    name.className = 'locker-item-name';
    name.textContent = item.name;

    const status = document.createElement('div');
    status.className = 'locker-item-status';
    if (isEquipped) {
        status.textContent = 'âœ“ Equipped';
    } else if (!isOwned) {
        status.textContent = 'ðŸ”’ Locked - Purchase in Shop';
    } else {
        status.textContent = 'Click to equip';
    }

    const equipBtn = document.createElement('button');
    equipBtn.className = 'locker-equip-btn';

    if (isEquipped) {
        equipBtn.textContent = 'EQUIPPED';
        equipBtn.disabled = true;
    } else if (!isOwned) {
        equipBtn.textContent = 'LOCKED';
        equipBtn.disabled = true;
    } else {
        equipBtn.textContent = 'EQUIP';
        equipBtn.onclick = () => equipLockerItem(item, category);
    }

    info.appendChild(name);
    info.appendChild(status);
    info.appendChild(equipBtn);

    card.appendChild(preview);
    card.appendChild(info);
    container.appendChild(card);
}

// Check if item is owned
function checkIfItemOwned(item, category) {
    if (category === 'colors') {
        return gameState.ownedItems.colors.includes(item.id);
    } else if (category === 'bodies') {
        return gameState.ownedItems.bodies.includes(item.id);
    } else if (category === 'weapons') {
        return gameState.ownedItems.weapons.includes(item.id);
    }
    return false;
}

// Check if item is equipped
function checkIfItemEquipped(item, category) {
    if (category === 'colors') {
        return gameState.selectedTank.color === item.id;
    } else if (category === 'bodies') {
        return gameState.selectedTank.body === item.id;
    } else if (category === 'weapons') {
        return gameState.selectedTank.weapon === item.id;
    }
    return false;
}

// Equip locker item
function equipLockerItem(item, category) {
    if (category === 'colors') {
        gameState.selectedTank.color = item.id;
        document.getElementById('currentColor').textContent = item.name;
    } else if (category === 'bodies') {
        gameState.selectedTank.body = item.id;
        document.getElementById('currentBody').textContent = item.name;
    } else if (category === 'weapons') {
        gameState.selectedTank.weapon = item.id;
        document.getElementById('currentWeapon').textContent = item.name;
    }

    // Save to storage
    savePlayerProgress();

    // Show notification
    showNotification(`Equipped ${item.name}!`, '#FFD700', 24);

    // Update locker preview
    updateLockerPreview();

    // Reload items to update UI
    loadLockerItems(category);

    // Update party tank preview if it exists
    if (typeof updatePlayerTankPreview === 'function') {
        updatePlayerTankPreview();
    }
}

// Render tank preview in locker - using consolidated ImageLoader
function renderLockerTankPreview(canvas, item, category) {
    let colorFolder = gameState.selectedTank.color;
    
    // Adjust color based on category
    if (category === 'colors') {
        colorFolder = item.id;
    }

    // Extract body and weapon from item
    let body = gameState.selectedTank.body;
    let weapon = gameState.selectedTank.weapon;
    
    if (category === 'bodies') {
        body = item.id;
    } else if (category === 'weapons') {
        weapon = item.id;
    }

    const tankConfig = { color: colorFolder, body, weapon };
    
    // Use consolidated ImageLoader function
    imageLoader.renderTankOnCanvas(canvas.id, tankConfig, { 
        scale: 0.4, 
        rotation: -Math.PI / 2 
    });
}

// Update locker preview (main loadout display) - using consolidated ImageLoader
function updateLockerPreview() {
    const canvas = document.getElementById('lockerTankPreview');
    if (!canvas) return;

    // Use consolidated ImageLoader function
    imageLoader.renderTankOnCanvas('lockerTankPreview', gameState.selectedTank, { 
        scale: 0.5, 
        rotation: -Math.PI / 2 
    });

    // Update text labels
    const colorNames = { blue: 'Blue', camo: 'Camo', desert: 'Desert', purple: 'Purple', red: 'Red' };
    const bodyNames = { body_halftrack: 'Halftrack', body_tracks: 'Full Tracks' };
    const weaponNames = {
        turret_01_mk1: 'Basic Turret', turret_01_mk2: 'Turret MK2', turret_01_mk3: 'Turret MK3', turret_01_mk4: 'Turret MK4',
        turret_02_mk1: 'Light Cannon', turret_02_mk2: 'Heavy Cannon', turret_02_mk3: 'Plasma Cannon', turret_02_mk4: 'Ultimate Cannon'
    };

    const currentColorEl = document.getElementById('currentColor');
    const currentBodyEl = document.getElementById('currentBody');
    const currentWeaponEl = document.getElementById('currentWeapon');

    if (currentColorEl) currentColorEl.textContent = colorNames[gameState.selectedTank.color] || gameState.selectedTank.color;
    if (currentBodyEl) currentBodyEl.textContent = bodyNames[gameState.selectedTank.body] || gameState.selectedTank.body;
    if (currentWeaponEl) currentWeaponEl.textContent = weaponNames[gameState.selectedTank.weapon] || gameState.selectedTank.weapon;
}

// REMOVED: Duplicate function - using the main one below

// Update lobby vehicle preview based on selected type
function updateLobbyVehiclePreview() {
    const canvas = document.getElementById('playerTankCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const vehicleType = window.gameState?.selectedVehicleType || 'tank';
    
    if (vehicleType === 'tank') {
        // Show tank preview
        const selectedTank = window.gameState?.selectedTank || { color: 'blue', body: 'body_halftrack', weapon: 'turret_01_mk1' };
        renderLobbyTank(ctx, centerX, centerY, selectedTank);
    } else if (vehicleType === 'jet') {
        // Show jet preview
        const selectedJet = window.gameState?.selectedJet || { type: 'ship1', color: 'purple' };
        renderLobbyJet(ctx, centerX, centerY, selectedJet);
    } else if (vehicleType === 'race') {
        // Show race car preview
        const selectedRace = window.gameState?.selectedRace || { type: 'endurance', color: 'blue' };
        renderLobbyRaceCar(ctx, centerX, centerY, selectedRace);
    }
}

// Render tank in lobby - using consolidated ImageLoader
function renderLobbyTank(ctx, centerX, centerY, tank) {
    // Create a temporary canvas for the tank rendering
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = ctx.canvas.width;
    tempCanvas.height = ctx.canvas.height;
    tempCanvas.id = 'temp-lobby-tank-' + Date.now();
    
    // Use consolidated ImageLoader function
    imageLoader.renderTankOnCanvas(tempCanvas.id, tank, { scale: 0.6 });
    
    // Copy the result to the target context
    setTimeout(() => {
        ctx.drawImage(tempCanvas, 0, 0);
    }, 50); // Small delay to allow image loading
}

// REMOVED: Duplicate function that was causing flickering - using the cached version below

// REMOVED: Duplicate function that was causing flickering - using the cached version below

// Initialize vehicle type on game start
if (!window.gameState) window.gameState = {};
if (!window.gameState.selectedVehicleType) {
    window.gameState.selectedVehicleType = 'tank';
}

// Simple vehicle preview management
let vehiclePreviewInterval;

// Update preview when page loads
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        updateLobbyVehiclePreview();
    }, 1000);
});

// New Locker System - Figma Design Implementation
// lockerState is already declared earlier in the file

// Vehicle selection in locker
window.selectLockerVehicle = function(vehicle) {
    if (vehicle !== lockerState.selectedVehicle && !lockerState.isAnimating) {
        lockerState.isAnimating = true;
        lockerState.selectedVehicle = vehicle;
        
        // Update button positions and states
        updateLockerVehicleButtons(vehicle);
        
        // Update customization options (this also resets customization state)
        updateLockerCustomizationOptions(vehicle);
        
        // Update preview
        updateLockerVehiclePreview(vehicle);
        
        // Clear status and reset select button
        const statusEl = document.getElementById('lockerItemStatus');
        if (statusEl) {
            statusEl.textContent = '';
            statusEl.className = 'locker-item-status';
        }
        const selectBtn = document.getElementById('lockerSelectBtn');
        if (selectBtn) {
            selectBtn.classList.remove('selected');
            selectBtn.querySelector('.fortnite-text').textContent = 'SELECT';
        }
        
        // Reset animation flag
        setTimeout(() => {
            lockerState.isAnimating = false;
        }, 500);
    }
};

function updateLockerVehicleButtons(selectedVehicle) {
    const vehicles = ['jet', 'tank', 'race'];
    const buttons = document.querySelectorAll('.locker-vehicle-btn');
    
    // Helper function to get vehicle index
    const getVehicleIndex = (vehicle) => vehicles.indexOf(vehicle);
    
    // Helper function to calculate button position
    const getButtonPosition = (vehicle) => {
        const currentIndex = getVehicleIndex(selectedVehicle);
        const vehicleIndex = getVehicleIndex(vehicle);
        const diff = vehicleIndex - currentIndex;
        
        if (diff === 0) return 'center';
        if (diff === -1 || diff === 2) return 'left';
        if (diff === 1 || diff === -2) return 'right';
        return 'center';
    };
    
    buttons.forEach(btn => {
        const vehicle = btn.dataset.vehicle;
        const position = getButtonPosition(vehicle);
        
        // Remove all position classes and active state
        btn.classList.remove('active');
        btn.removeAttribute('data-position');
        
        // Set new position
        btn.setAttribute('data-position', position);
        
        // Set active state
        if (vehicle === selectedVehicle) {
            btn.classList.add('active');
        }
        
        // Update text opacity
        const textSpan = btn.querySelector('.locker-vehicle-text');
        if (textSpan) {
            textSpan.style.opacity = vehicle === selectedVehicle ? '1' : '0.7';
        }
    });
    
    // Update preview label
    const label = document.getElementById('lockerSelectedVehicle');
    if (label) {
        label.textContent = selectedVehicle.toUpperCase();
    }
}

function updateLockerCustomizationOptions(vehicle) {
    const container = document.getElementById('lockerCustomizationOptions');
    if (!container) return;
    
    const customizationOptions = {
        tank: [
            { label: 'WEAPON', type: 'weapon' },
            { label: 'BODY', type: 'body' },
            { label: 'COLOR', type: 'color' }
        ],
        jet: [
            { label: 'JET TYPE', type: 'type' },
            { label: 'COLOR', type: 'color' }
        ],
        race: [
            { label: 'CAR TYPE', type: 'type' },
            { label: 'COLOR', type: 'color' }
        ]
    };
    
    const options = customizationOptions[vehicle] || [];
    
    container.innerHTML = '';
    options.forEach(option => {
        const button = document.createElement('button');
        button.className = 'locker-option-btn';
        button.dataset.type = option.type;
        button.onclick = () => openCustomizationPanel(option.type);
        
        const span = document.createElement('span');
        span.className = 'fortnite-text locker-option-text';
        span.textContent = option.label;
        
        button.appendChild(span);
        container.appendChild(button);
    });
    
    // Reset customization state when vehicle changes
    lockerCustomizationState.currentType = null;
    lockerCustomizationState.currentIndex = 0;
    lockerCustomizationState.items = [];
}

// Locker preview animation
let lockerPreviewAnimationId = null;

function updateLockerVehiclePreview(vehicle) {
    // Cancel any existing animation
    if (lockerPreviewAnimationId) {
        cancelAnimationFrame(lockerPreviewAnimationId);
        lockerPreviewAnimationId = null;
    }
    
    // Update stats display
    updateLockerStats(vehicle);
    
    // Start animation loop for locker preview
    animateLockerPreview(vehicle);
}

// Update locker stats display based on vehicle type
function updateLockerStats(vehicle) {
    let stats = { damage: 10, health: 100, fireRate: 1.0 };
    
    if (vehicle === 'tank') {
        const selectedTank = window.gameState?.selectedTank || { color: 'blue', weapon: 'turret_01_mk1' };
        stats = getTankStats(selectedTank.weapon, selectedTank.color);
    } else if (vehicle === 'jet') {
        const selectedJet = window.gameState?.selectedJet || { type: 'ship1', color: 'purple' };
        stats = getJetStats(selectedJet.type, selectedJet.color);
    } else if (vehicle === 'race') {
        const selectedRace = window.gameState?.selectedRace || { type: 'endurance' };
        stats = getRaceStats(selectedRace.type);
    }
    
    // Update DOM elements
    const damageEl = document.getElementById('lockerStatDamage');
    const healthEl = document.getElementById('lockerStatHealth');
    const fireRateEl = document.getElementById('lockerStatFireRate');
    
    if (damageEl) damageEl.textContent = stats.damage;
    if (healthEl) healthEl.textContent = stats.health;
    if (fireRateEl) fireRateEl.textContent = stats.fireRate;
}

function animateLockerPreview(vehicle) {
    const canvas = document.getElementById('lockerVehiclePreview');
    if (!canvas) return;
    
    // Check if locker is still visible
    const lockerScreen = document.getElementById('lockerScreen');
    if (!lockerScreen || lockerScreen.classList.contains('hidden')) {
        lockerPreviewAnimationId = null;
        return;
    }
    
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // If a customization type is selected, use that preview
    if (lockerCustomizationState.currentType && lockerCustomizationState.items.length > 0) {
        const type = lockerCustomizationState.currentType;
        const currentItem = lockerCustomizationState.items[lockerCustomizationState.currentIndex];
        if (currentItem) {
            animateLockerPreviewWithItem(vehicle, type, currentItem);
            lockerPreviewAnimationId = requestAnimationFrame(() => animateLockerPreview(vehicle));
            return;
        }
    }
    
    // Default: show full vehicle with current selection
    if (vehicle === 'tank') {
        const selectedTank = window.gameState?.selectedTank || { color: 'blue', body: 'body_halftrack', weapon: 'turret_01_mk1' };
        renderLockerTank(ctx, centerX, centerY, selectedTank);
    } else if (vehicle === 'jet') {
        const selectedJet = window.gameState?.selectedJet || { type: 'ship1', color: 'purple' };
        renderLockerJet(ctx, centerX, centerY, selectedJet);
    } else if (vehicle === 'race') {
        const selectedRace = window.gameState?.selectedRace || { type: 'endurance', color: 'blue' };
        renderLockerRace(ctx, centerX, centerY, selectedRace);
    }
    
    // Continue animation
    lockerPreviewAnimationId = requestAnimationFrame(() => animateLockerPreview(vehicle));
}

// Stop locker preview animation
function stopLockerPreviewAnimation() {
    if (lockerPreviewAnimationId) {
        cancelAnimationFrame(lockerPreviewAnimationId);
        lockerPreviewAnimationId = null;
    }
}

// Render functions for locker preview - using GIF images like lobby
function renderLockerTank(ctx, centerX, centerY, tank) {
    const { color, body, weapon } = tank;
    
    // Use GIF images from lobby cache (same as lobby box)
    const tankImg = lobbyTankImages[color]?.[body];
    const weaponImg = lobbyWeaponImages[color]?.[weapon];
    
    if (!tankImg || !weaponImg || !tankImg.complete || !weaponImg.complete) {
        // Images not loaded yet, skip this frame
        return;
    }
    
    // Clear canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    ctx.save();
    ctx.translate(centerX, centerY);
    
    // Slow rotation like lobby preview
    const rotation = (Date.now() * 0.00005) % (Math.PI * 2);
    ctx.rotate(rotation);
    
    // Draw tank body (GIF)
    const size = Math.min(ctx.canvas.width, ctx.canvas.height) * 0.7;
    const tankScale = size / Math.max(tankImg.width, tankImg.height);
    ctx.drawImage(
        tankImg,
        -tankImg.width * tankScale / 2,
        -tankImg.height * tankScale / 2,
        tankImg.width * tankScale,
        tankImg.height * tankScale
    );
    
    // Draw weapon (GIF)
    const weaponScale = size / Math.max(weaponImg.width, weaponImg.height);
    ctx.drawImage(
        weaponImg,
        -weaponImg.width * weaponScale / 2,
        -weaponImg.height * weaponScale / 2,
        weaponImg.width * weaponScale,
        weaponImg.height * weaponScale
    );
    
    ctx.restore();
}

function renderLockerJet(ctx, centerX, centerY, jet) {
    // Create a temporary canvas for the jet rendering
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = ctx.canvas.width;
    tempCanvas.height = ctx.canvas.height;
    tempCanvas.id = 'temp-locker-jet-' + Date.now();
    
    // Use consolidated ImageLoader function
    imageLoader.renderJetOnCanvas(tempCanvas.id, jet, { scale: 1.0 });
    
    // Copy the result to the target context
    setTimeout(() => {
        ctx.drawImage(tempCanvas, 0, 0);
    }, 50); // Small delay to allow image loading
}

function renderLockerRace(ctx, centerX, centerY, race) {
    // Create a temporary canvas for the race car rendering
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = ctx.canvas.width;
    tempCanvas.height = ctx.canvas.height;
    tempCanvas.id = 'temp-locker-race-' + Date.now();
    
    // Use consolidated ImageLoader function
    imageLoader.renderRaceOnCanvas(tempCanvas.id, race, { scale: 1.0 });
    
    // Copy the result to the target context
    setTimeout(() => {
        ctx.drawImage(tempCanvas, 0, 0);
    }, 50); // Small delay to allow image loading
}

// Upgrade system
window.upgradeVehicle = function() {
    if (lockerState.upgradeLevel < 10) {
        lockerState.upgradeLevel++;
        updateUpgradeBars();
        showNotification(`Upgraded to level ${lockerState.upgradeLevel}!`, '#10b981', 24);
    } else {
        showNotification('Max level reached!', '#f59e0b', 24);
    }
};

function updateUpgradeBars() {
    const container = document.getElementById('lockerUpgradeBars');
    if (!container) return;
    
    container.innerHTML = '';
    
    for (let i = 0; i < 10; i++) {
        const bar = document.createElement('div');
        bar.className = `locker-upgrade-bar ${i < lockerState.upgradeLevel ? 'filled' : 'empty'}`;
        container.appendChild(bar);
    }
}

// Locker customization state
let lockerCustomizationState = {
    currentType: null, // 'weapon', 'body', 'color', 'jet', 'race'
    currentIndex: 0,
    items: []
};

// Available items for customization
const LOCKER_ITEMS = {
    tank: {
        weapon: ['turret_01_mk1', 'turret_01_mk2', 'turret_01_mk3', 'turret_01_mk4'],
        body: ['body_halftrack', 'body_tracks'],
        color: ['blue', 'camo', 'desert', 'purple', 'red']
    },
    jet: {
        type: ['ship1', 'ship2', 'ship3'],
        color: ['purple', 'red', 'gold']  // Order: purple (base) â†’ red â†’ gold (best)
    },
    race: {
        type: ['endurance', 'sport', 'muscle'],
        color: ['blue', 'red', 'yellow', 'green']
    }
};

// Open customization panel for specific type
window.openCustomizationPanel = function(type) {
    const vehicle = lockerState.selectedVehicle;
    
    // Set active button
    const buttons = document.querySelectorAll('.locker-option-btn');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.type === type) {
            btn.classList.add('active');
        }
    });
    
    // Get items for this type
    let items = [];
    if (vehicle === 'tank') {
        items = LOCKER_ITEMS.tank[type] || [];
    } else if (vehicle === 'jet') {
        items = LOCKER_ITEMS.jet[type] || [];
    } else if (vehicle === 'race') {
        items = LOCKER_ITEMS.race[type] || [];
    }
    
    lockerCustomizationState.currentType = type;
    lockerCustomizationState.items = items;
    
    // Find current selected index
    let currentItem = null;
    if (vehicle === 'tank') {
        if (type === 'weapon') currentItem = gameState.selectedTank?.weapon;
        else if (type === 'body') currentItem = gameState.selectedTank?.body;
        else if (type === 'color') currentItem = gameState.selectedTank?.color;
    } else if (vehicle === 'jet') {
        if (type === 'type') currentItem = gameState.selectedJet?.type;
        else if (type === 'color') currentItem = gameState.selectedJet?.color;
    } else if (vehicle === 'race') {
        if (type === 'type') currentItem = gameState.selectedRace?.type;
        else if (type === 'color') currentItem = gameState.selectedRace?.color;
    }
    
    lockerCustomizationState.currentIndex = items.indexOf(currentItem);
    if (lockerCustomizationState.currentIndex < 0) lockerCustomizationState.currentIndex = 0;
    
    // Update preview
    updateLockerPreviewForType();
    updateLockerItemStatus();
};

// Scroll through items
window.scrollLockerItems = function(direction) {
    if (!lockerCustomizationState.currentType || lockerCustomizationState.items.length === 0) {
        // If no type selected, default to weapon for tank
        if (lockerState.selectedVehicle === 'tank') {
            openCustomizationPanel('weapon');
        } else if (lockerState.selectedVehicle === 'jet') {
            openCustomizationPanel('type');
        } else if (lockerState.selectedVehicle === 'race') {
            openCustomizationPanel('type');
        }
        return;
    }
    
    const items = lockerCustomizationState.items;
    lockerCustomizationState.currentIndex += direction;
    
    // Wrap around
    if (lockerCustomizationState.currentIndex < 0) {
        lockerCustomizationState.currentIndex = items.length - 1;
    } else if (lockerCustomizationState.currentIndex >= items.length) {
        lockerCustomizationState.currentIndex = 0;
    }
    
    updateLockerPreviewForType();
    updateLockerItemStatus();
    
    // Update stats when scrolling through items
    updateLockerStatsForCurrentItem();
};

// Update locker stats based on current preview item
function updateLockerStatsForCurrentItem() {
    const vehicle = lockerState.selectedVehicle;
    const type = lockerCustomizationState.currentType;
    const items = lockerCustomizationState.items;
    const index = lockerCustomizationState.currentIndex;
    const currentItem = items[index];
    
    if (!currentItem) return;
    
    let stats = { damage: 10, health: 100, fireRate: 1.0 };
    
    if (vehicle === 'tank') {
        const selectedTank = window.gameState?.selectedTank || { color: 'blue', weapon: 'turret_01_mk1' };
        if (type === 'weapon') {
            stats = getTankStats(currentItem, selectedTank.color);
        } else if (type === 'color') {
            stats = getTankStats(selectedTank.weapon, currentItem);
        } else {
            stats = getTankStats(selectedTank.weapon, selectedTank.color);
        }
    } else if (vehicle === 'jet') {
        const selectedJet = window.gameState?.selectedJet || { type: 'ship1', color: 'purple' };
        if (type === 'type') {
            stats = getJetStats(currentItem, selectedJet.color);
        } else if (type === 'color') {
            stats = getJetStats(selectedJet.type, currentItem);
        } else {
            stats = getJetStats(selectedJet.type, selectedJet.color);
        }
    } else if (vehicle === 'race') {
        if (type === 'type') {
            stats = getRaceStats(currentItem);
        } else {
            const selectedRace = window.gameState?.selectedRace || { type: 'endurance' };
            stats = getRaceStats(selectedRace.type);
        }
    }
    
    // Update DOM elements
    const damageEl = document.getElementById('lockerStatDamage');
    const healthEl = document.getElementById('lockerStatHealth');
    const fireRateEl = document.getElementById('lockerStatFireRate');
    
    if (damageEl) damageEl.textContent = stats.damage;
    if (healthEl) healthEl.textContent = stats.health;
    if (fireRateEl) fireRateEl.textContent = stats.fireRate;
}

// Update preview based on current customization type
function updateLockerPreviewForType() {
    const vehicle = lockerState.selectedVehicle;
    const type = lockerCustomizationState.currentType;
    const items = lockerCustomizationState.items;
    const index = lockerCustomizationState.currentIndex;
    const currentItem = items[index];
    
    if (!currentItem) return;
    
    // Update label
    const label = document.getElementById('lockerSelectedVehicle');
    if (label) {
        const displayNames = {
            turret_01_mk1: 'MK1', turret_01_mk2: 'MK2', turret_01_mk3: 'MK3', turret_01_mk4: 'MK4',
            body_halftrack: 'HALFTRACK', body_tracks: 'FULL TRACKS',
            blue: 'BLUE', camo: 'CAMO', desert: 'DESERT', purple: 'PURPLE', red: 'RED',
            ship1: 'FIGHTER', ship2: 'BOMBER', ship3: 'STEALTH',
            gold: 'GOLD', green: 'GREEN', yellow: 'YELLOW',
            endurance: 'ENDURANCE', sport: 'SPORT', muscle: 'MUSCLE'
        };
        label.textContent = displayNames[currentItem] || currentItem.toUpperCase();
    }
    
    // Render preview with current item highlighted
    animateLockerPreviewWithItem(vehicle, type, currentItem);
}

// Animate preview with specific item
function animateLockerPreviewWithItem(vehicle, type, item) {
    const canvas = document.getElementById('lockerVehiclePreview');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    if (vehicle === 'tank') {
        // Build tank config with current preview item
        const tankConfig = {
            color: type === 'color' ? item : (gameState.selectedTank?.color || 'blue'),
            body: type === 'body' ? item : (gameState.selectedTank?.body || 'body_halftrack'),
            weapon: type === 'weapon' ? item : (gameState.selectedTank?.weapon || 'turret_01_mk1')
        };
        
        // Render based on type - show only body or weapon if selected
        if (type === 'body') {
            renderLockerTankBodyOnly(ctx, centerX, centerY, tankConfig);
        } else if (type === 'weapon') {
            renderLockerTankWeaponOnly(ctx, centerX, centerY, tankConfig);
        } else {
            renderLockerTank(ctx, centerX, centerY, tankConfig);
        }
    } else if (vehicle === 'jet') {
        const jetConfig = {
            type: type === 'type' ? item : (gameState.selectedJet?.type || 'ship1'),
            color: type === 'color' ? item : (gameState.selectedJet?.color || 'purple')
        };
        renderLockerJet(ctx, centerX, centerY, jetConfig);
    } else if (vehicle === 'race') {
        const raceConfig = {
            type: type === 'type' ? item : (gameState.selectedRace?.type || 'endurance'),
            color: type === 'color' ? item : (gameState.selectedRace?.color || 'blue')
        };
        renderLockerRace(ctx, centerX, centerY, raceConfig);
    }
}

// Render only tank body
function renderLockerTankBodyOnly(ctx, centerX, centerY, tank) {
    const { color, body } = tank;
    const tankImg = lobbyTankImages[color]?.[body];
    
    if (!tankImg || !tankImg.complete) return;
    
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.save();
    ctx.translate(centerX, centerY);
    
    const rotation = (Date.now() * 0.00005) % (Math.PI * 2);
    ctx.rotate(rotation);
    
    const size = Math.min(ctx.canvas.width, ctx.canvas.height) * 0.7;
    const tankScale = size / Math.max(tankImg.width, tankImg.height);
    ctx.drawImage(tankImg, -tankImg.width * tankScale / 2, -tankImg.height * tankScale / 2, tankImg.width * tankScale, tankImg.height * tankScale);
    
    ctx.restore();
}

// Render only tank weapon
function renderLockerTankWeaponOnly(ctx, centerX, centerY, tank) {
    if (weaponSystem) {
        return weaponSystem.renderLockerTankWeaponOnly(ctx, centerX, centerY, tank);
    }
    
    // Fallback if WeaponSystem not initialized
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

// Update item status (owned/selected/locked)
function updateLockerItemStatus() {
    const statusEl = document.getElementById('lockerItemStatus');
    const selectBtn = document.getElementById('lockerSelectBtn');
    if (!statusEl || !selectBtn) return;
    
    const vehicle = lockerState.selectedVehicle;
    const type = lockerCustomizationState.currentType;
    const items = lockerCustomizationState.items;
    const index = lockerCustomizationState.currentIndex;
    const currentItem = items[index];
    
    if (!currentItem) {
        statusEl.textContent = '';
        statusEl.className = 'locker-item-status';
        return;
    }
    
    const isOwned = checkLockerItemOwned(vehicle, type, currentItem);
    const isSelected = checkLockerItemSelected(vehicle, type, currentItem);
    
    statusEl.className = 'locker-item-status';
    selectBtn.classList.remove('selected');
    
    if (isSelected) {
        statusEl.textContent = 'âœ“ SELECTED';
        statusEl.classList.add('selected');
        selectBtn.classList.add('selected');
        selectBtn.querySelector('.fortnite-text').textContent = 'SELECTED';
    } else if (isOwned) {
        statusEl.textContent = 'OWNED';
        statusEl.classList.add('owned');
        selectBtn.querySelector('.fortnite-text').textContent = 'SELECT';
    } else {
        statusEl.textContent = 'ðŸ”’ LOCKED';
        statusEl.classList.add('locked');
        selectBtn.querySelector('.fortnite-text').textContent = 'BUY IN SHOP';
    }
}

// Check if item is owned
function checkLockerItemOwned(vehicle, type, item) {
    const owned = gameState.ownedItems || { colors: ['blue'], bodies: ['body_halftrack'], weapons: ['turret_01_mk1'], jets: ['ship1_gold'], race: ['endurance_blue'] };
    
    if (vehicle === 'tank') {
        if (type === 'color') return owned.colors?.includes(item) || item === 'blue';
        if (type === 'body') return owned.bodies?.includes(item) || item === 'body_halftrack';
        if (type === 'weapon') return owned.weapons?.includes(item) || item === 'turret_01_mk1';
    } else if (vehicle === 'jet') {
        const jetId = `${gameState.selectedJet?.type || 'ship1'}_${item}`;
        if (type === 'type') {
            const jetIdByType = `${item}_${gameState.selectedJet?.color || 'purple'}`;
            return owned.jets?.includes(jetIdByType) || jetIdByType === 'ship1_purple';
        }
        return owned.jets?.includes(jetId) || jetId === 'ship1_purple';
    } else if (vehicle === 'race') {
        const raceId = `${gameState.selectedRace?.type || 'endurance'}_${item}`;
        if (type === 'type') {
            const raceIdByType = `${item}_${gameState.selectedRace?.color || 'blue'}`;
            return owned.race?.includes(raceIdByType) || raceIdByType === 'endurance_blue';
        }
        return owned.race?.includes(raceId) || raceId === 'endurance_blue';
    }
    return false;
}

// Check if item is currently selected
function checkLockerItemSelected(vehicle, type, item) {
    if (vehicle === 'tank') {
        if (type === 'color') return gameState.selectedTank?.color === item;
        if (type === 'body') return gameState.selectedTank?.body === item;
        if (type === 'weapon') return gameState.selectedTank?.weapon === item;
    } else if (vehicle === 'jet') {
        if (type === 'type') return gameState.selectedJet?.type === item;
        if (type === 'color') return gameState.selectedJet?.color === item;
    } else if (vehicle === 'race') {
        if (type === 'type') return gameState.selectedRace?.type === item;
        if (type === 'color') return gameState.selectedRace?.color === item;
    }
    return false;
}

// Select current item
window.selectLockerItem = function() {
    const vehicle = lockerState.selectedVehicle;
    const type = lockerCustomizationState.currentType;
    const items = lockerCustomizationState.items;
    const index = lockerCustomizationState.currentIndex;
    const currentItem = items[index];
    
    if (!currentItem) return;
    
    const isOwned = checkLockerItemOwned(vehicle, type, currentItem);
    const isSelected = checkLockerItemSelected(vehicle, type, currentItem);
    
    if (isSelected) {
        showNotification('Already selected!', '#f59e0b', 24);
        return;
    }
    
    if (!isOwned) {
        // Open shop to buy the item
        closeAllPanels();
        setTimeout(() => {
            openFeature('shop');
            showNotification('Find and buy this item in the Shop!', '#3b82f6', 24);
        }, 100);
        return;
    }
    
    // Apply selection
    if (vehicle === 'tank') {
        if (!gameState.selectedTank) {
            gameState.selectedTank = { color: 'blue', body: 'body_halftrack', weapon: 'turret_01_mk1' };
        }
        if (type === 'color') gameState.selectedTank.color = currentItem;
        if (type === 'body') gameState.selectedTank.body = currentItem;
        if (type === 'weapon') gameState.selectedTank.weapon = currentItem;
    } else if (vehicle === 'jet') {
        if (!gameState.selectedJet) {
            gameState.selectedJet = { type: 'ship1', color: 'purple' };
        }
        if (type === 'type') gameState.selectedJet.type = currentItem;
        if (type === 'color') gameState.selectedJet.color = currentItem;
    } else if (vehicle === 'race') {
        if (!gameState.selectedRace) {
            gameState.selectedRace = { type: 'endurance', color: 'blue' };
        }
        if (type === 'type') gameState.selectedRace.type = currentItem;
        if (type === 'color') gameState.selectedRace.color = currentItem;
    }
    
    showNotification('Item selected!', '#10b981', 24);
    updateLockerItemStatus();
    
    // Update stats display after selection
    updateLockerStats(vehicle);
    
    // Update lobby preview
    if (typeof renderTankOnCanvas === 'function' && vehicle === 'tank') {
        renderTankOnCanvas('playerTankCanvas', gameState.selectedTank);
    }
    
    // Save progress
    if (typeof saveUserProgress === 'function') {
        saveUserProgress();
    }
};

// Initialize locker when opened
function initializeNewLocker() {
    // Reset customization state
    lockerCustomizationState.currentType = null;
    lockerCustomizationState.currentIndex = 0;
    lockerCustomizationState.items = [];
    
    updateLockerVehicleButtons(lockerState.selectedVehicle);
    updateLockerCustomizationOptions(lockerState.selectedVehicle);
    updateLockerVehiclePreview(lockerState.selectedVehicle);
    
    // Clear status
    const statusEl = document.getElementById('lockerItemStatus');
    if (statusEl) {
        statusEl.textContent = '';
        statusEl.className = 'locker-item-status';
    }
    
    // Reset select button
    const selectBtn = document.getElementById('lockerSelectBtn');
    if (selectBtn) {
        selectBtn.classList.remove('selected');
        selectBtn.querySelector('.fortnite-text').textContent = 'SELECT';
    }
    
    // Remove active from option buttons
    const buttons = document.querySelectorAll('.locker-option-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
}

// Hook into existing locker opening
// Global function to open features
window.openFeature = function(featureName) {
    // Close all other features first
    closeAllPanels();
    
    // Hide vehicle type buttons when opening a feature
    const vehicleButtons = document.querySelector('.vehicle-type-buttons');
    if (vehicleButtons) {
        vehicleButtons.style.display = 'none';
    }
    
    // Map feature names to screen IDs and game state properties
    const featureMap = {
        'create-map': { screenId: 'createMapScreen', stateKey: 'showCreateMap' },
        'locker': { screenId: 'lockerScreen', stateKey: 'showLocker' },
        'shop': { screenId: 'shopScreen', stateKey: 'showShop' },
        'settings': { screenId: 'settingsScreen', stateKey: 'showSettings' },
        'pass': { screenId: 'passScreen', stateKey: 'showPass' },
        'friends': { screenId: 'friendsScreen', stateKey: 'showFriends' },
        'tanks': { screenId: 'shopScreen', stateKey: 'showShop' },
        'weapons': { screenId: 'shopScreen', stateKey: 'showShop' },
        'champions': { screenId: 'championsScreen', stateKey: 'showChampions' }
    };
    
    const feature = featureMap[featureName];
    if (!feature) {
        console.warn(`Unknown feature: ${featureName}`);
        return;
    }
    
    // Set game state
    gameState.openedFeature = featureName;
    if (feature.stateKey && gameState.hasOwnProperty(feature.stateKey)) {
        gameState[feature.stateKey] = true;
    }
    
    // Show the screen if it exists
    if (feature.screenId) {
        const screen = document.getElementById(feature.screenId);
        if (screen) {
            screen.classList.remove('hidden');
        } else {
            console.warn(`Screen not found: ${feature.screenId}`);
            if (typeof showNotification === 'function') {
                showNotification(`${featureName.toUpperCase()} feature coming soon!`, '#a855f7', 24);
            }
            return;
        }
    }
    
    // Handle feature-specific initialization
    if (featureName === 'locker') {
        initializeNewLocker();
        if (typeof startLockerRendering === 'function') {
            startLockerRendering();
        }
    } else if (featureName === 'shop' || featureName === 'tanks' || featureName === 'weapons') {
        if (typeof startShopRendering === 'function') {
            startShopRendering();
        }
    } else if (featureName === 'champions') {
        if (typeof loadChampionsData === 'function') {
            loadChampionsData('top-players');
        }
    } else if (featureName === 'friends') {
        // Initialize friends tab
        switchFriendsTab('online');
    }
};

// Function to close all panels
window.closeAllPanels = function() {
    // Hide all feature screens
    const featureScreens = document.querySelectorAll('.feature-screen');
    featureScreens.forEach(screen => {
        screen.classList.add('hidden');
    });
    
    // Show vehicle type buttons again
    const vehicleButtons = document.querySelector('.vehicle-type-buttons');
    if (vehicleButtons) {
        vehicleButtons.style.display = 'flex';
    }
    
    // Reset all game state properties
    gameStateManager.updateGameState({
        showLocker: false,
        showShop: false,
        showSettings: false,
        showCreateMap: false,
        showPass: false,
        showFriends: false,
        showChampions: false,
        openedFeature: null
    });
    
    // Stop any feature-specific rendering
    if (typeof stopLockerRendering === 'function') {
        stopLockerRendering();
    }
    if (typeof stopShopRendering === 'function') {
        stopShopRendering();
    }
    if (typeof stopLockerPreviewAnimation === 'function') {
        stopLockerPreviewAnimation();
    }
    
    // Hide any interactive button containers
    const buttonContainers = ['lockerButtons', 'shopButtons', 'passButtons', 'settingsButtons'];
    buttonContainers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
            container.classList.add('hidden');
        }
    });
};

// Friends tab switching function
window.switchFriendsTab = function(tabName) {
    // Update tab buttons
    const tabs = document.querySelectorAll('.friends-tab');
    tabs.forEach(tab => {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });
    
    // Show/hide tab content
    const tabContents = document.querySelectorAll('.friends-tab-content');
    tabContents.forEach(content => {
        content.classList.add('hidden');
    });
    
    const activeContent = document.getElementById(`friendsTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
    if (activeContent) {
        activeContent.classList.remove('hidden');
    }
};

// Friends action functions
window.inviteFriend = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`Invite sent to ${username}!`, '#4CAF50', 20);
    }
    console.log(`Inviting ${username} to party`);
};

window.messageFriend = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`Opening chat with ${username}...`, '#00f7ff', 20);
    }
    console.log(`Messaging ${username}`);
};

window.spectateFriend = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`Spectating ${username}...`, '#ffa500', 20);
    }
    console.log(`Spectating ${username}`);
};

window.acceptFriendRequest = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`${username} is now your friend!`, '#4CAF50', 20);
    }
    console.log(`Accepted friend request from ${username}`);
};

window.declineFriendRequest = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`Friend request declined`, '#ff6464', 20);
    }
    console.log(`Declined friend request from ${username}`);
};

window.sendFriendRequest = function() {
    const input = document.getElementById('addFriendInput');
    if (input && input.value.trim()) {
        const username = input.value.trim();
        if (typeof showNotification === 'function') {
            showNotification(`Friend request sent to ${username}!`, '#ff69b4', 20);
        }
        input.value = '';
        console.log(`Sent friend request to ${username}`);
    }
};

window.viewProfile = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`Viewing ${username}'s profile...`, '#9370db', 20);
    }
    console.log(`Viewing profile of ${username}`);
};

window.removeFriend = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`${username} removed from friends`, '#ff6464', 20);
    }
    console.log(`Removed ${username} from friends`);
};

window.blockUser = function(username) {
    if (typeof showNotification === 'function') {
        showNotification(`${username} has been blocked`, '#888', 20);
    }
    console.log(`Blocked ${username}`);
};

window.filterFriends = function() {
    const searchInput = document.getElementById('friendSearchInput');
    if (!searchInput) return;
    
    const searchTerm = searchInput.value.toLowerCase();
    const friendCards = document.querySelectorAll('.friend-card');
    
    friendCards.forEach(card => {
        const nameElement = card.querySelector('.friend-name');
        if (nameElement) {
            const name = nameElement.textContent.toLowerCase();
            if (name.includes(searchTerm)) {
                card.style.display = 'flex';
            } else {
                card.style.display = 'none';
            }
        }
    });
};

// Duplicate function removed - using the main one above

function updateVehicleButtons() {
    const buttons = ['tankBtn', 'jetBtn', 'raceBtn'];
    const vehicleTypes = ['tank', 'jet', 'race'];
    
    buttons.forEach((btnId, index) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.remove('active');
            if (vehicleTypes[index] === gameState.selectedVehicleType) {
                btn.classList.add('active');
            }
        }
    });
}

// Duplicate renderLobbyTank function removed - using the main one above

function renderLobbyJet(ctx, centerX, centerY, jet) {
    if (!jet) return;
    
    const { type, color } = jet;
    const imagePath = `/assets/jet/spr_${type}_${color}.png`;
    
    // Continuous rotation like tank
    const rotation = (Date.now() * 0.00005) % (Math.PI * 2);
    
    // Use cached image if available
    let jetImg = imageLoader.jetImageCache[imagePath];
    if (jetImg) {
        if (jetImg.complete) {
            const scale = 1.0;
            const jetWidth = jetImg.width * scale;
            const jetHeight = jetImg.height * scale;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            ctx.drawImage(jetImg, -jetWidth / 2, -jetHeight / 2, jetWidth, jetHeight);
            ctx.restore();
            return;
        }
    }
    
    // Load and cache image
    jetImg = imageLoader.loadJetImage(imagePath);
    jetImg.onload = () => {
        
        // Render immediately after loading
        const scale = 1.0;
        const jetWidth = jetImg.width * scale;
        const jetHeight = jetImg.height * scale;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        ctx.drawImage(jetImg, -jetWidth / 2, -jetHeight / 2, jetWidth, jetHeight);
        ctx.restore();
    };
    jetImg.src = imagePath;
}

function renderLobbyRace(ctx, centerX, centerY, race) {
    if (!race) return;
    
    const { type, color } = race;
    // Use new consolidated cars folder
    const imagePath = `/assets/race/sprites/cars/${type}_${color}.png`;
    
    // Continuous rotation like tank
    const rotation = (Date.now() * 0.00005) % (Math.PI * 2);
    
    // Use cached image if available
    let raceImg = imageLoader.raceImageCache[imagePath];
    if (raceImg) {
        if (raceImg.complete) {
            const scale = 1.0;
            const raceWidth = raceImg.width * scale;
            const raceHeight = raceImg.height * scale;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            ctx.drawImage(raceImg, -raceWidth / 2, -raceHeight / 2, raceWidth, raceHeight);
            ctx.restore();
            return;
        }
    }
    
    // Load and cache image
    raceImg = imageLoader.loadRaceImage(imagePath);
    raceImg.onload = () => {
        
        // Render immediately after loading
        const scale = 1.0;
        const raceWidth = raceImg.width * scale;
        const raceHeight = raceImg.height * scale;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        ctx.drawImage(raceImg, -raceWidth / 2, -raceHeight / 2, raceWidth, raceHeight);
        ctx.restore();
    };
    raceImg.src = imagePath;
}

// Simple initialization
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        updateVehicleButtons();
        updateLobbyVehiclePreview(gameState.selectedVehicleType);
    }, 500);
});

// Clean and simple - just like the locker!

// Function to stop any interfering rendering systems
function stopInterferingRenderers() {
    // Stop any animation frames that might be running
    const canvas = document.getElementById('playerTankCanvas');
    if (canvas && canvas._animationId) {
        cancelAnimationFrame(canvas._animationId);
        canvas._animationId = null;
        console.log('ðŸ›‘ Stopped canvas animation frame');
    }
    
    // Clear any intervals that might be rendering
    for (let i = 1; i < 99999; i++) {
        window.clearInterval(i);
    }
    console.log('ðŸ›‘ Cleared all intervals');
}

// REMOVED: Duplicate function - using the main one below

// Canvas management helper - no longer needed, keeping for reference
function enableCanvasDetective() {
    // Debugging function removed - canvas conflicts resolved
    console.log('Canvas detective mode disabled - conflicts resolved');
}

// Select vehicle type and manage canvas rendering
window.selectVehicleType = function(vehicleType) {
    console.log(`ðŸŽ¯ Selecting vehicle: ${vehicleType}`);
    
    // Set the current lobby vehicle type FIRST to stop tank animations
    window.currentLobbyVehicleType = vehicleType;
    
    // Stop tank background animation if switching away from tank
    if (vehicleType !== 'tank' && window.tankBackgroundAnimationId) {
        cancelAnimationFrame(window.tankBackgroundAnimationId);
        window.tankBackgroundAnimationId = null;
        console.log('ðŸ›‘ Stopped tank background animation');
    }
    
    // Clear any existing intervals
    if (window.lobbyRenderInterval) {
        clearInterval(window.lobbyRenderInterval);
        window.lobbyRenderInterval = null;
    }
    
    // Clear any DOM maps when switching vehicles
    if (window.DOMMapRenderer?.clearLobbyMap) {
        window.DOMMapRenderer.clearLobbyMap();
    }
    
    // Hide all background canvases first
    const tankCanvas = document.getElementById('tankLobbyBackground');
    const jetCanvas = document.getElementById('jetLobbyBackground');
    const raceCanvas = document.getElementById('raceLobbyBackground');
    
    if (tankCanvas) tankCanvas.style.display = 'none';
    if (jetCanvas) jetCanvas.style.display = 'none';
    if (raceCanvas) raceCanvas.style.display = 'none';
    
    // Show the correct canvas for the selected vehicle type
    if (vehicleType === 'tank' && tankCanvas) {
        tankCanvas.style.display = 'block';
        console.log('âœ… Showing tank canvas');
    } else if (vehicleType === 'jet' && jetCanvas) {
        jetCanvas.style.display = 'block';
        console.log('âœ… Showing jet canvas');
    } else if (vehicleType === 'race' && raceCanvas) {
        raceCanvas.style.display = 'block';
        console.log('âœ… Showing race canvas');
    }
    
    gameState.selectedVehicleType = vehicleType;
    updateVehicleButtons();
    
    // Render once - no continuous intervals needed for static vehicles
    updateLobbyVehiclePreview(vehicleType);
    
    // Check for created maps and update lobby background
    checkVehicleMapsAndUpdateLobby(vehicleType);
};

// Check if there are created maps for the vehicle type and update lobby
function checkVehicleMapsAndUpdateLobby(vehicleType) {
    console.log(`ðŸ—ºï¸ Checking maps for vehicle type: ${vehicleType}`);
    
    // ALWAYS stop tank background when switching to jet/race
    if (vehicleType === 'jet' || vehicleType === 'race') {
        // Set vehicle type FIRST to stop the animation loop
        window.currentLobbyVehicleType = vehicleType;
        
        // Cancel any pending animation frames
        if (window.tankBackgroundAnimationId) {
            cancelAnimationFrame(window.tankBackgroundAnimationId);
            window.tankBackgroundAnimationId = null;
        }
        
        console.log('ðŸ›‘ Stopped tank background animation for', vehicleType);
    }
    
    // Get saved maps from localStorage
    const allMaps = JSON.parse(localStorage.getItem(STORAGE_KEYS.TANK_MAPS) || '[]');
    
    // Filter maps by vehicle type
    const vehicleMaps = allMaps.filter(map => {
        if (vehicleType === 'tank') {
            return !map.vehicleType || map.vehicleType === 'tank';
        }
        return map.vehicleType === vehicleType;
    });
    
    console.log(`Found ${vehicleMaps.length} maps for ${vehicleType}`);
    
    // Update Play button based on whether maps exist
    updatePlayButtonForVehicle(vehicleType, vehicleMaps);
    
    // Update lobby background
    if (vehicleType === 'tank') {
        // Cancel any jet/race background animations
        if (window.vehicleBackgroundAnimationId) {
            cancelAnimationFrame(window.vehicleBackgroundAnimationId);
            window.vehicleBackgroundAnimationId = null;
        }
        window.currentLobbyVehicleType = 'tank';
        
        if (vehicleMaps.length > 0) {
            // Has tank maps - show the map background
            initializeLobbyBackground();
        } else {
            // No tank maps - show "No maps created" message
            updateLobbyBackgroundNoMaps(vehicleType);
        }
    } else if (vehicleMaps.length > 0) {
        // Show the first created map as background
        updateLobbyBackgroundWithMap(vehicleType, vehicleMaps[0]);
    } else {
        // Show "No maps created" message
        updateLobbyBackgroundNoMaps(vehicleType);
    }
}

// Update Play button based on vehicle type and available maps
function updatePlayButtonForVehicle(vehicleType, vehicleMaps) {
    const playButton = document.getElementById('joinGameBtn');
    const playButtonText = playButton?.querySelector('span:first-child');
    const playButtonSubtext = document.getElementById('playButtonMapName');
    
    if (!playButton) return;
    
    if (vehicleType === 'tank') {
        // Check if tank has any created maps
        if (vehicleMaps.length > 0) {
            // Has tank maps - can play
            playButton.onclick = () => joinGame();
            if (playButtonText) playButtonText.textContent = 'PLAY';
            if (playButtonSubtext) playButtonSubtext.textContent = vehicleMaps[0].name;
            playButton.style.background = '';
        } else {
            // No tank maps - show Create button
            playButton.onclick = () => openVehicleMapCreator('tank');
            if (playButtonText) playButtonText.textContent = 'CREATE';
            if (playButtonSubtext) playButtonSubtext.textContent = 'Create TANK Map';
            playButton.style.background = 'linear-gradient(135deg, #0066cc, #0088ff)';
        }
    } else if (vehicleMaps.length > 0) {
        // Has created maps - can play
        playButton.onclick = () => joinVehicleGame(vehicleType, vehicleMaps[0]);
        if (playButtonText) playButtonText.textContent = 'PLAY';
        if (playButtonSubtext) playButtonSubtext.textContent = vehicleMaps[0].name;
        playButton.style.background = vehicleType === 'jet' ? 
            'linear-gradient(135deg, #cc6600, #ff8800)' : 
            'linear-gradient(135deg, #cc0066, #ff0088)';
    } else {
        // No maps - show Create button
        playButton.onclick = () => openVehicleMapCreator(vehicleType);
        if (playButtonText) playButtonText.textContent = 'CREATE';
        if (playButtonSubtext) playButtonSubtext.textContent = `Create ${vehicleType.toUpperCase()} Map`;
        playButton.style.background = vehicleType === 'jet' ? 
            'linear-gradient(135deg, #cc6600, #ff8800)' : 
            'linear-gradient(135deg, #cc0066, #ff0088)';
    }
}

// Open the appropriate map creator for the vehicle type
function openVehicleMapCreator(vehicleType) {
    console.log(`Opening ${vehicleType} map creator...`);
    
    if (vehicleType === 'tank') {
        if (typeof showTankMapNameInput === 'function') {
            showTankMapNameInput();
        } else {
            alert('Tank map creator not available!');
        }
    } else if (vehicleType === 'jet') {
        if (typeof showJetMapNameInput === 'function') {
            showJetMapNameInput();
        } else {
            alert('Jet map creator not available!');
        }
    } else if (vehicleType === 'race') {
        if (typeof showRaceMapNameInput === 'function') {
            showRaceMapNameInput();
        } else {
            alert('Race map creator not available!');
        }
    }
}

// Join game with specific vehicle type and map
function joinVehicleGame(vehicleType, map) {
    console.log(`ðŸŽ® Starting ${vehicleType} game with map: ${map.name}`);
    
    // Store current game info
    window.currentVehicleGame = {
        vehicleType: vehicleType,
        map: map,
        player: {
            x: 0,
            y: 0,
            angle: 0, // Start facing right (sprite rotated 90 degrees in render)
            speed: 0,
            maxSpeed: vehicleType === 'jet' ? 8 : 6,
            acceleration: vehicleType === 'jet' ? 0.3 : 0.2,
            friction: 0.98,
            turnSpeed: vehicleType === 'jet' ? 0.05 : 0.04
        },
        keys: { w: false, a: false, s: false, d: false },
        running: true
    };
    
    // Hide lobby, show game
    document.getElementById('lobbyScreen').classList.add('hidden');
    document.getElementById('gameMapArea').classList.remove('hidden');
    
    // Show game canvas
    const gameCanvas = document.getElementById('gameCanvas');
    if (gameCanvas) {
        gameCanvas.style.display = 'block';
    }
    
    // Show UI elements
    document.getElementById('ui').classList.remove('hidden');
    
    // Set game state
    gameState.isInLobby = false;
    gameState.isConnected = true;
    
    // Start the vehicle game
    startVehicleGameLoop(vehicleType, map);
}

// Start the vehicle game loop
function startVehicleGameLoop(vehicleType, map) {
    const canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error('Game canvas not found!');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const game = window.currentVehicleGame;
    
    // Load map objects
    const mapImages = [];
    if (map.objects) {
        map.objects.forEach(obj => {
            const img = new Image();
            img.src = obj.path;
            mapImages.push({ img, obj });
        });
    }
    
    // Load vehicle sprite
    const vehicleImg = new Image();
    if (vehicleType === 'jet') {
        const jet = gameState.selectedJet || { type: 'ship1', color: 'purple' };
        vehicleImg.src = `/assets/jet/spr_${jet.type}_${jet.color}.png`;
    } else {
        const race = gameState.selectedRace || { type: 'endurance', color: 'blue' };
        vehicleImg.src = `/assets/race/sprites/cars/${race.type}_${race.color}.png`;
    }
    
    // Setup keyboard controls
    setupVehicleControls(game);
    
    // Game loop
    function gameLoop() {
        if (!game.running) return;
        
        // Update player position
        updateVehiclePlayer(game);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw background
        if (vehicleType === 'jet') {
            drawJetGameBackground(ctx, canvas, game);
        } else {
            drawRaceGameBackground(ctx, canvas, game);
        }
        
        // Draw map objects (centered on player)
        ctx.save();
        ctx.translate(canvas.width/2 - game.player.x, canvas.height/2 - game.player.y);
        
        mapImages.forEach(({ img, obj }) => {
            if (img.complete) {
                ctx.drawImage(img, obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height);
            }
        });
        
        ctx.restore();
        
        // Draw player vehicle (always centered)
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(game.player.angle + Math.PI/2); // Add 90 degrees rotation to face right
        
        // Draw thruster/exhaust effect when moving
        if (Math.abs(game.player.speed) > 0.5) {
            if (vehicleType === 'jet') {
                // Jet thruster flame
                const flameLength = 20 + Math.abs(game.player.speed) * 5;
                const gradient = ctx.createLinearGradient(-flameLength - 30, 0, -30, 0);
                gradient.addColorStop(0, 'rgba(255, 100, 0, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 100, 1)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(-30, -8);
                ctx.lineTo(-30 - flameLength, 0);
                ctx.lineTo(-30, 8);
                ctx.closePath();
                ctx.fill();
            } else {
                // Race car tire smoke when turning
                if (game.keys.a || game.keys.d) {
                    ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                    ctx.beginPath();
                    ctx.arc(-25, -15, 8, 0, Math.PI * 2);
                    ctx.arc(-25, 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        if (vehicleImg.complete) {
            const scale = vehicleType === 'jet' ? 0.8 : 0.6;
            const w = vehicleImg.width * scale;
            const h = vehicleImg.height * scale;
            ctx.drawImage(vehicleImg, -w/2, -h/2, w, h);
        } else {
            // Fallback shape
            ctx.fillStyle = vehicleType === 'jet' ? '#ff8800' : '#ff0088';
            ctx.fillRect(-30, -15, 60, 30);
        }
        
        ctx.restore();
        
        // Draw HUD
        drawVehicleHUD(ctx, canvas, vehicleType, map, game);
        
        requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
}

// Setup WASD controls for vehicle
function setupVehicleControls(game) {
    // Remove old listeners if any
    if (window.vehicleKeyDownHandler) {
        document.removeEventListener('keydown', window.vehicleKeyDownHandler);
        document.removeEventListener('keyup', window.vehicleKeyUpHandler);
    }
    
    window.vehicleKeyDownHandler = (e) => {
        const key = e.key.toLowerCase();
        if (key === 'w') game.keys.w = true;
        if (key === 'a') game.keys.a = true;
        if (key === 's') game.keys.s = true;
        if (key === 'd') game.keys.d = true;
        if (key === 'escape') exitVehicleGame();
    };
    
    window.vehicleKeyUpHandler = (e) => {
        const key = e.key.toLowerCase();
        if (key === 'w') game.keys.w = false;
        if (key === 'a') game.keys.a = false;
        if (key === 's') game.keys.s = false;
        if (key === 'd') game.keys.d = false;
    };
    
    document.addEventListener('keydown', window.vehicleKeyDownHandler);
    document.addEventListener('keyup', window.vehicleKeyUpHandler);
}

// Update vehicle player position based on WASD input
function updateVehiclePlayer(game) {
    const p = game.player;
    
    // Acceleration (W/S)
    if (game.keys.w) {
        p.speed += p.acceleration;
    }
    if (game.keys.s) {
        p.speed -= p.acceleration * 0.5; // Slower reverse
    }
    
    // Turning (A/D) - only when moving
    if (Math.abs(p.speed) > 0.1) {
        if (game.keys.a) {
            p.angle -= p.turnSpeed * (p.speed > 0 ? 1 : -1);
        }
        if (game.keys.d) {
            p.angle += p.turnSpeed * (p.speed > 0 ? 1 : -1);
        }
    }
    
    // Apply friction
    p.speed *= p.friction;
    
    // Clamp speed
    p.speed = Math.max(-p.maxSpeed/2, Math.min(p.maxSpeed, p.speed));
    
    // Update position
    p.x += Math.cos(p.angle) * p.speed;
    p.y += Math.sin(p.angle) * p.speed;
}

// Draw jet game background
function drawJetGameBackground(ctx, canvas, game) {
    // Dark space gradient
    const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
    );
    gradient.addColorStop(0, '#1a1a3e');
    gradient.addColorStop(0.3, '#0f0f2a');
    gradient.addColorStop(0.7, '#0a0a1a');
    gradient.addColorStop(1, '#000008');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw parallax stars
    ctx.fillStyle = 'white';
    for (let i = 0; i < 100; i++) {
        const starX = ((i * 137 + game.player.x * 0.1) % canvas.width + canvas.width) % canvas.width;
        const starY = ((i * 89 + game.player.y * 0.1) % canvas.height + canvas.height) % canvas.height;
        const size = (i % 3) + 1;
        ctx.beginPath();
        ctx.arc(starX, starY, size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Draw race game background
function drawRaceGameBackground(ctx, canvas, game) {
    // Green grass gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#2d5a27');
    gradient.addColorStop(0.5, '#3d7a37');
    gradient.addColorStop(1, '#2d5a27');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grass texture (parallax)
    ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
    for (let i = 0; i < 50; i++) {
        const grassX = ((i * 73 - game.player.x * 0.5) % canvas.width + canvas.width) % canvas.width;
        const grassY = ((i * 47 - game.player.y * 0.5) % canvas.height + canvas.height) % canvas.height;
        ctx.fillRect(grassX, grassY, 3, 10);
    }
}

// Draw vehicle game HUD
function drawVehicleHUD(ctx, canvas, vehicleType, map, game) {
    // Top bar with map name
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, 50);
    
    ctx.fillStyle = vehicleType === 'jet' ? '#ff8800' : '#ff0088';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    const emoji = vehicleType === 'jet' ? 'âœˆï¸' : 'ðŸŽï¸';
    ctx.fillText(`${emoji} ${map.name}`, canvas.width/2, 32);
    
    // Speed indicator
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Speed: ${Math.abs(game.player.speed).toFixed(1)}`, 20, 32);
    
    // Controls hint
    ctx.textAlign = 'right';
    ctx.fillStyle = '#aaa';
    ctx.font = '14px Arial';
    ctx.fillText('WASD to move | ESC to exit', canvas.width - 20, 32);
    
    // Position indicator
    ctx.textAlign = 'left';
    ctx.fillText(`X: ${Math.round(game.player.x)} Y: ${Math.round(game.player.y)}`, 20, canvas.height - 20);
}

// Exit vehicle game and return to lobby
function exitVehicleGame() {
    console.log('Exiting vehicle game...');
    
    if (window.currentVehicleGame) {
        window.currentVehicleGame.running = false;
    }
    
    // Remove keyboard listeners
    if (window.vehicleKeyDownHandler) {
        document.removeEventListener('keydown', window.vehicleKeyDownHandler);
        document.removeEventListener('keyup', window.vehicleKeyUpHandler);
        window.vehicleKeyDownHandler = null;
        window.vehicleKeyUpHandler = null;
    }
    
    // Return to lobby
    returnToLobby();
}

// Make exit function globally available
window.exitVehicleGame = exitVehicleGame;

// Duplicate updateLobbyBackgroundWithMap function removed - using the main one above

// Update lobby background showing "No maps created"
function updateLobbyBackgroundNoMaps(vehicleType) {
    console.log(`ðŸŽ¨ Showing no maps message for ${vehicleType}`);
    
    let canvas;
    if (vehicleType === 'tank') {
        canvas = document.getElementById('tankLobbyBackground');
    } else if (vehicleType === 'jet') {
        canvas = document.getElementById('jetLobbyBackground');
    } else if (vehicleType === 'race') {
        canvas = document.getElementById('raceLobbyBackground');
    }
    
    if (!canvas) return;
    
    // Set vehicle type FIRST to stop tank animation loop
    window.currentLobbyVehicleType = vehicleType;
    
    // Stop tank background animation
    if (window.tankBackgroundAnimationId) {
        cancelAnimationFrame(window.tankBackgroundAnimationId);
        window.tankBackgroundAnimationId = null;
    }
    
    // Stop any existing vehicle background animation
    if (window.vehicleBackgroundAnimationId) {
        cancelAnimationFrame(window.vehicleBackgroundAnimationId);
        window.vehicleBackgroundAnimationId = null;
    }
    
    // Clear canvas
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (vehicleType === 'jet') {
        startJetLobbyBackgroundNoMaps(canvas);
    } else if (vehicleType === 'race') {
        startRaceLobbyBackgroundNoMaps(canvas);
    } else {
        // Tank uses default
        initializeLobbyBackground();
    }
}

// Jet lobby background with "No maps" message
function startJetLobbyBackgroundNoMaps(canvas) {
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Create stars array once
    if (!window.jetStars) {
        window.jetStars = [];
        for (let i = 0; i < 300; i++) {
            window.jetStars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.5 + 0.1,
                brightness: Math.random()
            });
        }
    }
    
    let time = 0;
    
    function drawJetBackgroundNoMaps() {
        if (window.currentLobbyVehicleType !== 'jet') return;
        
        time += 0.01;
        
        // Dark space gradient
        const gradient = ctx.createRadialGradient(
            canvas.width/2, canvas.height/2, 0,
            canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
        );
        gradient.addColorStop(0, '#1a1a3e');
        gradient.addColorStop(0.3, '#0f0f2a');
        gradient.addColorStop(0.7, '#0a0a1a');
        gradient.addColorStop(1, '#000008');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw animated stars
        window.jetStars.forEach(star => {
            const twinkle = 0.5 + 0.5 * Math.sin(time * 2 + star.brightness * 10);
            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.8})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
            
            star.y += star.speed;
            if (star.y > canvas.height) {
                star.y = 0;
                star.x = Math.random() * canvas.width;
            }
        });
        
        // Draw "No Maps Created" message
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 80, 400, 160);
        ctx.strokeStyle = '#ff8800';
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width/2 - 200, canvas.height/2 - 80, 400, 160);
        
        ctx.fillStyle = '#ff8800';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âœˆï¸ JET MODE', canvas.width/2, canvas.height/2 - 40);
        
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText('No Maps Created', canvas.width/2, canvas.height/2);
        
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText('Click CREATE to build your first jet map!', canvas.width/2, canvas.height/2 + 40);
        
        window.vehicleBackgroundAnimationId = requestAnimationFrame(drawJetBackgroundNoMaps);
    }
    
    drawJetBackgroundNoMaps();
}

// Race lobby background with "No maps" message
function startRaceLobbyBackgroundNoMaps(canvas) {
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    let time = 0;
    
    function drawRaceBackgroundNoMaps() {
        if (window.currentLobbyVehicleType !== 'race') return;
        
        time += 0.02;
        
        // Green grass gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a3a1a');
        gradient.addColorStop(0.3, '#2d5a27');
        gradient.addColorStop(0.7, '#3d7a37');
        gradient.addColorStop(1, '#2d5a27');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grass texture
        ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
        for (let i = 0; i < 100; i++) {
            const x = (i * 37 + time * 10) % canvas.width;
            const y = (i * 23) % canvas.height;
            ctx.fillRect(x, y, 3, 10);
        }
        
        // Draw "No Maps Created" message
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 80, 400, 160);
        ctx.strokeStyle = '#ff0088';
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width/2 - 200, canvas.height/2 - 80, 400, 160);
        
        ctx.fillStyle = '#ff0088';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ðŸŽï¸ RACE MODE', canvas.width/2, canvas.height/2 - 40);
        
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText('No Maps Created', canvas.width/2, canvas.height/2);
        
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText('Click CREATE to build your first race track!', canvas.width/2, canvas.height/2 + 40);
        
        window.vehicleBackgroundAnimationId = requestAnimationFrame(drawRaceBackgroundNoMaps);
    }
    
    drawRaceBackgroundNoMaps();
}

// Jet lobby background with created map
function startJetLobbyBackgroundWithMap(canvas, map) {
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Create stars array once
    if (!window.jetStars) {
        window.jetStars = [];
        for (let i = 0; i < 300; i++) {
            window.jetStars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.5 + 0.1,
                brightness: Math.random()
            });
        }
    }
    
    // Load map objects
    const mapImages = [];
    if (map.objects) {
        map.objects.forEach(obj => {
            const img = new Image();
            img.src = obj.path;
            mapImages.push({ img, obj });
        });
    }
    
    let time = 0;
    
    function drawJetBackgroundWithMap() {
        if (window.currentLobbyVehicleType !== 'jet') return;
        
        time += 0.01;
        
        // Dark space gradient
        const gradient = ctx.createRadialGradient(
            canvas.width/2, canvas.height/2, 0,
            canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
        );
        gradient.addColorStop(0, '#1a1a3e');
        gradient.addColorStop(0.3, '#0f0f2a');
        gradient.addColorStop(0.7, '#0a0a1a');
        gradient.addColorStop(1, '#000008');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw animated stars
        window.jetStars.forEach(star => {
            const twinkle = 0.5 + 0.5 * Math.sin(time * 2 + star.brightness * 10);
            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.8})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
            
            star.y += star.speed;
            if (star.y > canvas.height) {
                star.y = 0;
                star.x = Math.random() * canvas.width;
            }
        });
        
        // Draw map objects
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(0.3, 0.3);
        
        mapImages.forEach(({ img, obj }) => {
            if (img.complete) {
                ctx.drawImage(img, obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height);
            }
        });
        
        ctx.restore();
        
        // Draw map name
        ctx.fillStyle = '#ff8800';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`âœˆï¸ ${map.name}`, canvas.width/2, 50);
        
        window.vehicleBackgroundAnimationId = requestAnimationFrame(drawJetBackgroundWithMap);
    }
    
    drawJetBackgroundWithMap();
}

// Race lobby background with created map
// Migrate old race sprite paths to new consolidated structure
function migrateRaceSpritePath(path) {
    if (!path || typeof path !== 'string') return path;
    
    // Map old folder names to new paths
    const migrations = {
        'spr_car_endurance_blue': 'cars/endurance_blue.png',
        'spr_car_endurance_red': 'cars/endurance_red.png',
        'spr_car_endurance_yellow': 'cars/endurance_yellow.png',
        'spr_car_endurance_purple': 'cars/endurance_purple.png',
        'spr_car_endurance_white': 'cars/endurance_white.png',
        'spr_car_highspec_blue': 'cars/highspec_blue.png',
        'spr_car_highspec_red': 'cars/highspec_red.png',
        'spr_car_touring_blue': 'cars/touring_blue.png',
        'spr_Track_Corner': 'tracks/track_corner.png',
        'spr_Track_Round': 'tracks/track_round.png',
        'spr_Track_Straight_Diagonal': 'tracks/track_straight_diagonal.png',
        'spr_tile_grass': 'tiles/tile_grass.png',
        'spr_tile_sand': 'tiles/tile_sand.png',
        'spr_tile_tarmac': 'tiles/tile_tarmac.png',
        'spr_house1_blue': 'houses/house1_blue.png',
        'spr_house1_orange': 'houses/house1_orange.png',
        'spr_house1_yellow': 'houses/house1_yellow.png',
        'spr_house2_blue': 'houses/house2_blue.png',
        'spr_house2_orange': 'houses/house2_orange.png',
        'spr_house2_yellow': 'houses/house2_yellow.png',
        'spr_house3_blue': 'houses/house3_blue.png',
        'spr_building': 'buildings/building.png',
        'spr_building2': 'buildings/building2.png',
        'spr_building3': 'buildings/building3.png',
        'spr_cone': 'cones/cone.png',
        'spr_cone_tipped': 'cones/cone_tipped.png',
        'spr_fuel_barrel_a': 'fuel/fuel_barrel_a.png',
        'spr_fuel_barrel_b': 'fuel/fuel_barrel_b.png',
        'spr_sign': 'sign.png',
        'spr_start': 'start.png',
        'spr_start_position': 'start_position.png',
        'spr_pit_marking': 'pit_marking.png'
    };
    
    // Check if path contains old folder pattern
    for (const [oldFolder, newPath] of Object.entries(migrations)) {
        if (path.includes(oldFolder)) {
            return '/assets/race/sprites/' + newPath;
        }
    }
    return path;
}

function startRaceLobbyBackgroundWithMap(canvas, map) {
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Load map objects with path migration
    const mapImages = [];
    if (map.objects) {
        map.objects.forEach(obj => {
            const img = new Image();
            img.src = migrateRaceSpritePath(obj.path);
            img.onerror = () => console.warn('Failed to load race sprite:', obj.path);
            mapImages.push({ img, obj });
        });
    }
    
    let time = 0;
    
    function drawRaceBackgroundWithMap() {
        if (window.currentLobbyVehicleType !== 'race') return;
        
        time += 0.02;
        
        // Green grass gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a3a1a');
        gradient.addColorStop(0.3, '#2d5a27');
        gradient.addColorStop(0.7, '#3d7a37');
        gradient.addColorStop(1, '#2d5a27');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grass texture
        ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
        for (let i = 0; i < 100; i++) {
            const x = (i * 37 + time * 10) % canvas.width;
            const y = (i * 23) % canvas.height;
            ctx.fillRect(x, y, 3, 10);
        }
        
        // Draw map objects
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(0.3, 0.3);
        
        mapImages.forEach(({ img, obj }) => {
            if (img.complete) {
                ctx.drawImage(img, obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height);
            }
        });
        
        ctx.restore();
        
        // Draw map name
        ctx.fillStyle = '#ff0088';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`ðŸŽï¸ ${map.name}`, canvas.width/2, 50);
        
        window.vehicleBackgroundAnimationId = requestAnimationFrame(drawRaceBackgroundWithMap);
    }
    
    drawRaceBackgroundWithMap();
}

// Update lobby background based on selected vehicle type
// Old updateLobbyBackgroundForVehicle removed - now using checkVehicleMapsAndUpdateLobby instead